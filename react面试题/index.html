<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="theme-color" content="#0078E7"><meta name="author" content="云游君"><meta name="copyright" content="云游君"><meta name="generator" content="Hexo 5.3.0"><meta name="theme" content="hexo-theme-yun"><title>react面试题 | 云游君的小站</title><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@900&amp;display=swap" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/star-markdown-css@0.3.3/dist/yun/yun-markdown.min.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/prism-theme-vars/base.css"><script src="https://fastly.jsdelivr.net/npm/scrollreveal/dist/scrollreveal.min.js" defer></script><script>function initScrollReveal() {
  [".post-card",".markdown-body img"].forEach((target)=> {
    ScrollReveal().reveal(target);
  })
}
document.addEventListener("DOMContentLoaded", initScrollReveal);
document.addEventListener("pjax:success", initScrollReveal);
</script><link rel="icon" type="image/svg+xml" href="/yun.svg"><link rel="mask-icon" href="/yun.svg" color="#0078E7"><link rel="preload" href="/css/hexo-theme-yun.css" as="style"><link rel="prefetch" href="/js/sidebar.js" as="script"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><link rel="preconnect" href="https://fastly.jsdelivr.net/npm/" crossorigin><script id="yun-config">
    window.Yun = {}
    window.CONFIG = {"hostname":"www.yunyoujun.cn","root":"/","title":"云游君的小站","version":"1.10.4","mode":"auto","copycode":true,"page":{"isPost":true},"i18n":{"placeholder":"搜索...","empty":"找不到您查询的内容: ${query}","hits":"找到 ${hits} 条结果","hits_time":"找到 ${hits} 条结果（用时 ${time} 毫秒）"},"anonymous_image":"https://cdn.yunyoujun.cn/img/avatar/none.jpg","say":{"api":"https://el-bot-api.vercel.app/api/words/young"},"fireworks":{"colors":null},"waline":{"config":{"enable":true,"serverURL":"https://waline.yunyoujun.cn","comment":true,"visitor":true,"emoji":["https://fastly.jsdelivr.net/gh/walinejs/emojis@latest/bilibili/","https://fastly.jsdelivr.net/gh/walinejs/emojis@latest/weibo/","https://fastly.jsdelivr.net/gh/walinejs/emojis@latest/qq/"],"locale":{"placeholder":"填写邮箱，可以收到回复通知哦～"},"requiredMeta":["nick"],"el":"#waline","lang":"zh-CN"},"cdn":"https://fastly.jsdelivr.net/npm/@waline/client@v2/dist/waline.js","dark":"html.dark"},"vendors":{"darken":"https://fastly.jsdelivr.net/npm/darken@1.5.0"}};
  </script><link rel="stylesheet" href="/css/hexo-theme-yun.css"><script src="/js/hexo-theme-yun.js" type="module"></script><link rel="alternate" href="/atom.xml" title="云游君的小站" type="application/atom+xml"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin><script async src="https://www.googletagmanager.com/gtag/js?id=G-1LL0D86CY9"></script><script>if (CONFIG.hostname === location.hostname) {
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-1LL0D86CY9');
}</script><script data-ad-client="ca-pub-2245427233262012" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(function(){
  var bp = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  if (curProtocol === 'https') {
    bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
  }
  else {
    bp.src = 'http://push.zhanzhang.baidu.com/push.js';
  }
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(bp, s);
})();</script><!-- Google Tag Manager --><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src='https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);})(window,document,'script','dataLayer','GTM-M9KWR9L');</script><!-- End Google Tag Manager --><meta name="description" content="什么是react？它是facebook在2011年发布的一个框架 react和vue大体是差不多一个开发框架，支出组件并且可以引入第三方UI库 相对vue来说它比较更原生一点，vue相对来说更容易上手。 react有什么特点？它使用虚拟dom而不是真正的dom 它可以用服务器端渲染 它遵循单向数据流或者数据绑定 vue和react的区别？react严格上针对的是mvc模式的view层，vue则是m">
<meta property="og:type" content="article">
<meta property="og:title" content="react面试题">
<meta property="og:url" content="https://www.yunyoujun.cn/react%E9%9D%A2%E8%AF%95%E9%A2%98/index.html">
<meta property="og:site_name" content="云游君的小站">
<meta property="og:description" content="什么是react？它是facebook在2011年发布的一个框架 react和vue大体是差不多一个开发框架，支出组件并且可以引入第三方UI库 相对vue来说它比较更原生一点，vue相对来说更容易上手。 react有什么特点？它使用虚拟dom而不是真正的dom 它可以用服务器端渲染 它遵循单向数据流或者数据绑定 vue和react的区别？react严格上针对的是mvc模式的view层，vue则是m">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-02-23T01:06:10.000Z">
<meta property="article:modified_time" content="2021-03-19T03:03:37.268Z">
<meta property="article:author" content="云游君">
<meta property="article:tag" content="YunYouJun">
<meta property="article:tag" content="Blog">
<meta property="article:tag" content="云游君">
<meta property="article:tag" content="博客">
<meta property="article:tag" content="云游君的小站">
<meta property="article:tag" content="yunyoujun.cn">
<meta property="article:tag" content="www.yunyoujun.cn">
<meta name="twitter:card" content="summary"><script>(function() {
  const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches
  const setting = localStorage.getItem('darken-mode') || 'auto'
  if (setting === 'dark' || (prefersDark && setting !== 'light'))
    document.documentElement.classList.toggle('dark', true)
})()</script></head><body><script src="https://code.iconify.design/2/2.1.1/iconify.min.js"></script><script>// Define global variable
IconifyProviders = {
  // Empty prefix: overwrite default API provider configuration
  '': {
    // Use custom API first, use Iconify public API as backup
    resources: [
        'https://api.iconify.design',
    ],
    // Wait for 1 second before switching API hosts
    rotate: 1000,
  },
};</script><script defer src="https://fastly.jsdelivr.net/npm/animejs@latest"></script><script defer src="/js/ui/fireworks.js" type="module"></script><canvas class="fireworks"></canvas><div class="container"><a class="sidebar-toggle hty-icon-button" id="menu-btn"><div class="hamburger hamburger--spin" type="button"><span class="hamburger-box"><span class="hamburger-inner"></span></span></div></a><div class="sidebar-toggle sidebar-overlay"></div><aside class="sidebar"><script src="/js/sidebar.js" type="module"></script><ul class="sidebar-nav"><li class="sidebar-nav-item sidebar-nav-toc hty-icon-button sidebar-nav-active" data-target="post-toc-wrap" title="文章目录"><span class="icon iconify" data-icon="ri:list-ordered"></span></li><li class="sidebar-nav-item sidebar-nav-overview hty-icon-button" data-target="site-overview-wrap" title="站点概览"><span class="icon iconify" data-icon="ri:passport-line"></span></li></ul><div class="sidebar-panel" id="site-overview-wrap"><div class="site-info fix-top"><a class="site-author-avatar" href="/about/" title="云游君"><img width="96" loading="lazy" src="/images/avatar.jpg" alt="云游君"><span class="site-author-status" title="Looking for dawn.">🌑</span></a><div class="site-author-name"><a href="/about/">云游君</a></div><span class="site-name">云游君的小站</span><sub class="site-subtitle">All at sea.</sub><div class="site-description">希望能成为一个有趣的人</div></div><nav class="site-state"><a class="site-state-item hty-icon-button icon-home" href="/" title="首页"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:home-4-line"></span></span></a><div class="site-state-item"><a href="/archives/" title="归档"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:archive-line"></span></span><span class="site-state-item-count">21</span></a></div><div class="site-state-item"><a href="/categories/" title="分类"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:folder-2-line"></span></span><span class="site-state-item-count">0</span></a></div><div class="site-state-item"><a href="/tags/" title="标签"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:price-tag-3-line"></span></span><span class="site-state-item-count">0</span></a></div><a class="site-state-item hty-icon-button" href="/about/#comment" title="留言板"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:clipboard-line"></span></span></a></nav><hr style="margin-bottom:0.5rem"><div class="links-of-author"><a class="links-of-author-item hty-icon-button" rel="noopener" href="/atom.xml" title="RSS" target="_blank" style="color:orange"><span class="icon iconify" data-icon="ri:rss-line"></span></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://qun.qq.com/qqweb/qunpro/share?_wv=3&amp;_wwv=128&amp;appChannel=share&amp;inviteCode=28OEdR&amp;appChannel=share&amp;businessType=9&amp;from=246610&amp;biz=ka" title="QQ 频道 - 小云之家" target="_blank" style="color:#12B7F5"><span class="icon iconify" data-icon="ri:qq-line"></span></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://github.com/YunYouJun" title="GitHub" target="_blank" style="color:#6e5494"><span class="icon iconify" data-icon="ri:github-line"></span></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://weibo.com/jizhideyunyoujun" title="微博" target="_blank" style="color:#E6162D"><span class="icon iconify" data-icon="ri:weibo-line"></span></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://www.douban.com/people/yunyoujun/" title="豆瓣" target="_blank" style="color:#007722"><span class="icon iconify" data-icon="ri:douban-line"></span></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://music.163.com/#/user/home?id=247102977" title="网易云音乐" target="_blank" style="color:#C20C0C"><span class="icon iconify" data-icon="ri:netease-cloud-music-line"></span></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://www.zhihu.com/people/yunyoujun/" title="知乎" target="_blank" style="color:#0084FF"><span class="icon iconify" data-icon="ri:zhihu-line"></span></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://space.bilibili.com/1579790" title="哔哩哔哩" target="_blank" style="color:#FF8EB3"><span class="icon iconify" data-icon="ri:bilibili-line"></span></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://cdn.yunyoujun.cn/img/about/white-qrcode-and-search.jpg" title="微信公众号" target="_blank" style="color:#1AAD19"><span class="icon iconify" data-icon="ri:wechat-2-line"></span></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://twitter.com/YunYouJun" title="Twitter" target="_blank" style="color:#1da1f2"><span class="icon iconify" data-icon="ri:twitter-line"></span></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://t.me/elpsycn" title="Telegram Channel" target="_blank" style="color:#0088CC"><span class="icon iconify" data-icon="ri:telegram-line"></span></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://discord.gg/nd3mPkU5j8" title="Discord" target="_blank" style="color:#5A6DE2"><span class="icon iconify" data-icon="ri:discord-line"></span></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="mailto:me@yunyoujun.cn" title="E-Mail" target="_blank" style="color:#8E71C1"><span class="icon iconify" data-icon="ri:mail-line"></span></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://travellings.link" title="Travelling" target="_blank" style="color:var(--hty-text-color)"><span class="icon iconify" data-icon="ri:train-line"></span></a></div><hr style="margin:0.5rem 1rem"><div class="links"><a class="links-item hty-icon-button" href="/links/" title="我的小伙伴们" style="color:dodgerblue"><span class="icon iconify" data-icon="ri:genderless-line"></span></a><a class="links-item hty-icon-button" href="/girls/" title="喜欢的女孩子" style="color:hotpink"><span class="icon iconify" data-icon="ri:women-line"></span></a></div><br><a class="links-item hty-icon-button" id="toggle-mode-btn" href="javascript:;" title="Mode" style="color: #f1cb64"><span class="icon iconify" data-icon="ri:contrast-2-line"></span></a></div><div class="sidebar-panel sidebar-panel-active" id="post-toc-wrap"><div class="post-toc"><div class="post-toc-content"><ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFreact%EF%BC%9F"><span class="toc-number">1.</span> <span class="toc-text">什么是react？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#react%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9%EF%BC%9F"><span class="toc-number">2.</span> <span class="toc-text">react有什么特点？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#vue%E5%92%8Creact%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">3.</span> <span class="toc-text">vue和react的区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%97%E5%87%BAReact%E7%9A%84%E4%B8%80%E4%BA%9B%E4%B8%BB%E8%A6%81%E4%BC%98%E7%82%B9%EF%BC%9F"><span class="toc-number">4.</span> <span class="toc-text">列出React的一些主要优点？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#React%E6%9C%89%E5%93%AA%E4%BA%9B%E9%99%90%E5%88%B6%EF%BC%9F"><span class="toc-number">5.</span> <span class="toc-text">React有哪些限制？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%99%9A%E6%8B%9FDOM%EF%BC%9F"><span class="toc-number">6.</span> <span class="toc-text">什么是虚拟DOM？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFJSX%EF%BC%9F"><span class="toc-number">7.</span> <span class="toc-text">什么是JSX？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%9B%B4%E6%8E%A5%E6%9B%B4%E6%96%B0-state-%E5%91%A2"><span class="toc-number">8.</span> <span class="toc-text">为什么不直接更新 state 呢 ?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-React-Hooks-%E5%A5%BD%E5%A4%84%E6%98%AF%E5%95%A5%EF%BC%9F"><span class="toc-number">9.</span> <span class="toc-text">使用 React Hooks 好处是啥？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-React-Hooks%EF%BC%9F"><span class="toc-number">10.</span> <span class="toc-text">什么是 React Hooks？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-React-Context"><span class="toc-number">11.</span> <span class="toc-text">什么是 React Context?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%AF%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="toc-number">12.</span> <span class="toc-text">什么是纯函数？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%A0%E4%BA%86%E8%A7%A3-Virtual-DOM-%E5%90%97%EF%BC%9F%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8B%E5%AE%83%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">13.</span> <span class="toc-text">你了解 Virtual DOM 吗？解释一下它的工作原理？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%B5%8F%E8%A7%88%E5%99%A8%E6%97%A0%E6%B3%95%E8%AF%BB%E5%8F%96JSX%EF%BC%9F"><span class="toc-number">14.</span> <span class="toc-text">为什么浏览器无法读取JSX？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8E-ES5-%E7%9B%B8%E6%AF%94%EF%BC%8CReact-%E7%9A%84-ES6-%E8%AF%AD%E6%B3%95%E6%9C%89%E4%BD%95%E4%B8%8D%E5%90%8C%EF%BC%9F"><span class="toc-number">15.</span> <span class="toc-text">与 ES5 相比，React 的 ES6 语法有何不同？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%A0%E7%90%86%E8%A7%A3%E2%80%9C%E5%9C%A8React%E4%B8%AD%EF%BC%8C%E4%B8%80%E5%88%87%E9%83%BD%E6%98%AF%E7%BB%84%E4%BB%B6%E2%80%9D%E8%BF%99%E5%8F%A5%E8%AF%9D%EF%BC%9F"><span class="toc-number">16.</span> <span class="toc-text">你理解“在React中，一切都是组件”这句话？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A-React-%E4%B8%AD-render-%E7%9A%84%E7%9B%AE%E7%9A%84%EF%BC%9F"><span class="toc-number">17.</span> <span class="toc-text">解释 React 中 render() 的目的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Props"><span class="toc-number">18.</span> <span class="toc-text">什么是 Props?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#React%E4%B8%AD%E7%9A%84%E7%8A%B6%E6%80%81%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%AE%83%E6%98%AF%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E7%9A%84%EF%BC%9F"><span class="toc-number">19.</span> <span class="toc-text">React中的状态是什么？它是如何使用的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%9B%B4%E6%96%B0%E7%BB%84%E4%BB%B6%E7%9A%84%E7%8A%B6%E6%80%81%EF%BC%9F"><span class="toc-number">20.</span> <span class="toc-text">如何更新组件的状态？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%A6%E7%BB%86%E8%A7%A3%E9%87%8A-React-%E7%BB%84%E4%BB%B6%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%96%B9%E6%B3%95%E3%80%82"><span class="toc-number">21.</span> <span class="toc-text">详细解释 React 组件的生命周期方法。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#React%E4%B8%AD%E7%9A%84%E5%90%88%E6%88%90%E4%BA%8B%E4%BB%B6%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">22.</span> <span class="toc-text">React中的合成事件是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%A0%E5%AF%B9-React-%E7%9A%84-refs-%E6%9C%89%E4%BB%80%E4%B9%88%E4%BA%86%E8%A7%A3%EF%BC%9F"><span class="toc-number">23.</span> <span class="toc-text">你对 React 的 refs 有什么了解？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6%EF%BC%88HOC%EF%BC%89%EF%BC%9F"><span class="toc-number">24.</span> <span class="toc-text">什么是高阶组件（HOC）？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%A0%E8%83%BD%E7%94%A8HOC%E5%81%9A%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">25.</span> <span class="toc-text">你能用HOC做什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%AF%E7%BB%84%E4%BB%B6%EF%BC%9F"><span class="toc-number">26.</span> <span class="toc-text">什么是纯组件？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#React-%E4%B8%AD-key-%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">27.</span> <span class="toc-text">React 中 key 的重要性是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MVC%E6%A1%86%E6%9E%B6%E7%9A%84%E4%B8%BB%E8%A6%81%E9%97%AE%E9%A2%98%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">28.</span> <span class="toc-text">MVC框架的主要问题是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8B-Flux%EF%BC%9F"><span class="toc-number">29.</span> <span class="toc-text">解释一下 Flux？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFRedux%EF%BC%9F"><span class="toc-number">30.</span> <span class="toc-text">什么是Redux？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redux%E9%81%B5%E5%BE%AA%E7%9A%84%E4%B8%89%E4%B8%AA%E5%8E%9F%E5%88%99%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">31.</span> <span class="toc-text">Redux遵循的三个原则是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%A0%E5%AF%B9%E2%80%9C%E5%8D%95%E4%B8%80%E4%BA%8B%E5%AE%9E%E6%9D%A5%E6%BA%90%E2%80%9D%E6%9C%89%E4%BB%80%E4%B9%88%E7%90%86%E8%A7%A3%EF%BC%9F"><span class="toc-number">32.</span> <span class="toc-text">你对“单一事实来源”有什么理解？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%97%E5%87%BA-Redux-%E7%9A%84%E7%BB%84%E4%BB%B6%E3%80%82"><span class="toc-number">33.</span> <span class="toc-text">列出 Redux 的组件。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#redux%E4%B8%AD%E9%97%B4%E4%BB%B6%EF%BC%9F"><span class="toc-number">34.</span> <span class="toc-text">redux中间件？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%9C%A8-Redux-%E4%B8%AD%E5%AE%9A%E4%B9%89-Action%EF%BC%9F"><span class="toc-number">35.</span> <span class="toc-text">如何在 Redux 中定义 Action？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A-Reducer-%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">36.</span> <span class="toc-text">解释 Reducer 的作用？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Store-%E5%9C%A8-Redux-%E4%B8%AD%E7%9A%84%E6%84%8F%E4%B9%89%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">37.</span> <span class="toc-text">Store 在 Redux 中的意义是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFReact-%E8%B7%AF%E7%94%B1%EF%BC%9F"><span class="toc-number">38.</span> <span class="toc-text">什么是React 路由？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88React-Router-v4%E4%B8%AD%E4%BD%BF%E7%94%A8-switch-%E5%85%B3%E9%94%AE%E5%AD%97-%EF%BC%9F"><span class="toc-number">39.</span> <span class="toc-text">为什么React Router v4中使用 switch 关键字 ？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-React-%E4%B8%AD%E7%9A%84%E8%B7%AF%E7%94%B1%EF%BC%9F"><span class="toc-number">40.</span> <span class="toc-text">为什么需要 React 中的路由？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#react%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%9A%84%E6%96%B9%E6%A1%88%EF%BC%9F"><span class="toc-number">41.</span> <span class="toc-text">react性能优化的方案？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8Bwebpack%EF%BC%9F"><span class="toc-number">42.</span> <span class="toc-text">介绍一下webpack？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#react%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%B8%AD%EF%BC%8C%E6%9C%80%E9%80%82%E5%90%88%E4%B8%8E%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E4%BA%A4%E4%BA%92%E7%9A%84%E6%98%AF%E5%93%AA%E4%B8%AA%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="toc-number">43.</span> <span class="toc-text">react生命周期中，最适合与服务端进行数据交互的是哪个函数？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#shouldComponentUpdate-%E6%98%AF%E5%81%9A%E4%BB%80%E4%B9%88%E7%9A%84%EF%BC%8C%EF%BC%88react-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%98%AF%E5%93%AA%E4%B8%AA%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0%EF%BC%9F%EF%BC%89"><span class="toc-number">44.</span> <span class="toc-text">shouldComponentUpdate 是做什么的，（react 性能优化是哪个周期函数？）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E5%87%BA-%E7%BB%84%E4%BB%B6-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%96%B9%E6%B3%95%E7%9A%84%E4%B8%8D%E5%90%8C%EF%BC%9F"><span class="toc-number">45.</span> <span class="toc-text">指出(组件)生命周期方法的不同？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E7%94%A8-setState-%E4%B9%8B%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">46.</span> <span class="toc-text">调用 setState 之后发生了什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#react-diff-%E5%8E%9F%E7%90%86%EF%BC%88%E5%B8%B8%E8%80%83%EF%BC%8C%E5%A4%A7%E5%8E%82%E5%BF%85%E8%80%83%EF%BC%89"><span class="toc-number">47.</span> <span class="toc-text">react diff 原理（常考，大厂必考）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BB%BA%E8%AE%AE%E4%BC%A0%E9%80%92%E7%BB%99-setState-%E7%9A%84%E5%8F%82%E6%95%B0%E6%98%AF%E4%B8%80%E4%B8%AA-callback-%E8%80%8C%E4%B8%8D%E6%98%AF%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%EF%BC%9F"><span class="toc-number">48.</span> <span class="toc-text">为什么建议传递给 setState 的参数是一个 callback 而不是一个对象？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%99%A4%E4%BA%86%E5%9C%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%AD%E7%BB%91%E5%AE%9A-this%EF%BC%8C%E8%BF%98%E6%9C%89%E5%85%B6%E5%AE%83%E6%96%B9%E5%BC%8F%E5%90%97%EF%BC%9F"><span class="toc-number">49.</span> <span class="toc-text">除了在构造函数中绑定 this，还有其它方式吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#setState%E7%AC%AC%E4%BA%8C%E4%B8%AA%E5%8F%82%E6%95%B0%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">50.</span> <span class="toc-text">setState第二个参数的作用?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%AD-%E8%B0%83%E7%94%A8-super-props-%E7%9A%84%E7%9B%AE%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">51.</span> <span class="toc-text">(在构造函数中)调用 super(props) 的目的是什么?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8-React-%E5%BD%93%E4%B8%AD-Element-%E5%92%8C-Component-%E6%9C%89%E4%BD%95%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">52.</span> <span class="toc-text">在 React 当中 Element 和 Component 有何区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E7%9A%84-%E7%8A%B6%E6%80%81-state-%E5%92%8C%E5%B1%9E%E6%80%A7-props-%E4%B9%8B%E9%97%B4%E6%9C%89%E4%BD%95%E4%B8%8D%E5%90%8C"><span class="toc-number">53.</span> <span class="toc-text">(组件的)状态(state)和属性(props)之间有何不同?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6%E5%92%8C%E9%9D%9E%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6%E5%8C%BA%E5%88%AB"><span class="toc-number">54.</span> <span class="toc-text">受控组件和非受控组件区别?</span></a></li></ol></div></div></div></aside><main class="sidebar-translate" id="content"><div id="post"><article class="hty-card post-block" itemscope itemtype="https://schema.org/Article" style="--smc-primary:#0078E7;"><link itemprop="mainEntityOfPage" href="https://www.yunyoujun.cn/react%E9%9D%A2%E8%AF%95%E9%A2%98/"><span hidden itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="name" content="云游君"><meta itemprop="description"></span><span hidden itemprop="publisher" itemscope itemtype="https://schema.org/Organization"><meta itemprop="name" content="云游君的小站"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">react面试题<a class="post-edit-link" href="https://github.com/YunYouJun/yunyoujun.github.io/tree/hexo/source/_posts/react面试题.md" target="_blank" title="编辑" rel="noopener"><span class="icon iconify" data-icon="ri:edit-line"></span></a></h1><div class="post-meta"><div class="post-time"><span class="post-meta-item-icon"><span class="icon iconify" data-icon="ri:calendar-line"></span></span> <time title="创建时间：2021-02-23 09:06:10" itemprop="dateCreated datePublished" datetime="2021-02-23T09:06:10+08:00">2021-02-23</time><span class="post-meta-divider">-</span><span class="post-meta-item-icon"><span class="icon iconify" data-icon="ri:calendar-2-line"></span></span> <time title="修改时间：2021-03-19 11:03:37" itemprop="dateModified" datetime="2021-03-19T11:03:37+08:00">2021-03-19</time></div><span class="leancloud_visitors" id="/react%E9%9D%A2%E8%AF%95%E9%A2%98/" data-flag-title="react面试题"><span class="post-meta-divider">-</span><span class="post-meta-item-icon" title="阅读次数"><span class="icon iconify" data-icon="ri:eye-line"></span> <span class="leancloud-visitors-count"></span></span></span><span class="post-meta-divider">-</span><a href="#comment"><span class="post-meta-item-icon" title="评论数"><span class="icon iconify" data-icon="ri:chat-3-line"></span> <span class="waline-comment-count" id="/react%E9%9D%A2%E8%AF%95%E9%A2%98/"></span></span></a><div class="post-classify"></div></div></header><section class="post-body" itemprop="articleBody"><div class="post-content markdown-body"><h4 id="什么是react？"><a href="#什么是react？" class="headerlink" title="什么是react？"></a>什么是react？</h4><pre><code>它是facebook在2011年发布的一个框架
react和vue大体是差不多一个开发框架，支出组件并且可以引入第三方UI库
相对vue来说它比较更原生一点，vue相对来说更容易上手。</code></pre>
<h4 id="react有什么特点？"><a href="#react有什么特点？" class="headerlink" title="react有什么特点？"></a>react有什么特点？</h4><pre><code>它使用虚拟dom而不是真正的dom
它可以用服务器端渲染
它遵循单向数据流或者数据绑定</code></pre>
<h4 id="vue和react的区别？"><a href="#vue和react的区别？" class="headerlink" title="vue和react的区别？"></a>vue和react的区别？</h4><pre><code>react严格上针对的是mvc模式的view层，vue则是mvvm模式。
操作dom的方式不同，vue使用的是指令操作dom，react是通过js进行操作。
数据绑定不同，vue实现的是双向绑定，react的数据流动是单向的。
react中state是不能直接改变的，需要使用setState改变。vue中的state不是必须的，数据主要是由data属性在vue对象中管理的。</code></pre>
<h4 id="列出React的一些主要优点？"><a href="#列出React的一些主要优点？" class="headerlink" title="列出React的一些主要优点？"></a>列出React的一些主要优点？</h4><pre><code>它提高了应用的性能
可以方便地在客户端和服务器端使用
由于 JSX，代码的可读性很好
React 很容易与 Meteor，Angular 等其他框架集成
使用React，编写UI测试用例变得非常容易</code></pre>
<h4 id="React有哪些限制？"><a href="#React有哪些限制？" class="headerlink" title="React有哪些限制？"></a>React有哪些限制？</h4><pre><code>React 只是一个库，而不是一个完整的框架
它的库非常庞大，需要时间来理解
新手程序员可能很难理解
编码变得复杂，因为它使用内联模板和 JSX</code></pre>
<h4 id="什么是虚拟DOM？"><a href="#什么是虚拟DOM？" class="headerlink" title="什么是虚拟DOM？"></a>什么是虚拟DOM？</h4><pre><code>虚拟 DOM (VDOM)是真实 DOM 在内存中的表示。UI 的表示形式保存在内存中，并与实际的 DOM 同步。这是一个发生在渲染函数被调用和元素在屏幕上显示之间的步骤，整个过程被称为调和。</code></pre>
<h4 id="什么是JSX？"><a href="#什么是JSX？" class="headerlink" title="什么是JSX？"></a>什么是JSX？</h4><pre><code>JSX 是J avaScript XML 的简写。是 React 使用的一种文件，它利用 JavaScript 的表现力和类似 HTML 的模板语法。这使得 HTML 文件非常容易理解。此文件能使应用非常可靠，并能够提高其性能。</code></pre>
<h4 id="为什么不直接更新-state-呢"><a href="#为什么不直接更新-state-呢" class="headerlink" title="为什么不直接更新 state 呢 ?"></a>为什么不直接更新 state 呢 ?</h4><pre><code>如果试图直接更新 state ，则不会重新渲染组件
要使用setState()方法来更新 state。它调度对组件state对象的更新。当state改变时，组件通过重新渲染来响应：</code></pre>
<h4 id="使用-React-Hooks-好处是啥？"><a href="#使用-React-Hooks-好处是啥？" class="headerlink" title="使用 React Hooks 好处是啥？"></a>使用 React Hooks 好处是啥？</h4><pre><code>首先，Hooks 通常支持提取和重用跨多个组件通用的有状态逻辑，而无需承担高阶组件或渲染 props 的负担。Hooks 可以轻松地操作函数组件的状态，而不需要将它们转换为类组件。

Hooks 在类中不起作用，通过使用它们，咱们可以完全避免使用生命周期方法，例如 componentDidMount、componentDidUpdate、componentWillUnmount。相反，使用像useEffect这样的内置钩子。</code></pre>
<h4 id="什么是-React-Hooks？"><a href="#什么是-React-Hooks？" class="headerlink" title="什么是 React Hooks？"></a>什么是 React Hooks？</h4><pre><code>Hooks是 React 16.8 中的新添加内容。它们允许在不编写类的情况下使用state和其他 React 特性。使用 Hooks，可以从组件中提取有状态逻辑，这样就可以独立地测试和重用它。Hooks 允许咱们在不改变组件层次结构的情况下重用有状态逻辑，这样在许多组件之间或与社区共享 Hooks 变得很容易。</code></pre>
<h4 id="什么是-React-Context"><a href="#什么是-React-Context" class="headerlink" title="什么是 React Context?"></a>什么是 React Context?</h4><pre><code>Context 通过组件树提供了一个传递数据的方法，从而避免了在每一个层级手动的传递 props 属性。</code></pre>
<h4 id="什么是纯函数？"><a href="#什么是纯函数？" class="headerlink" title="什么是纯函数？"></a>什么是纯函数？</h4><pre><code>纯函数是不依赖并且不会在其作用域之外修改变量状态的函数。本质上，纯函数始终在给定相同参数的情况下返回相同结果。</code></pre>
<h4 id="你了解-Virtual-DOM-吗？解释一下它的工作原理？"><a href="#你了解-Virtual-DOM-吗？解释一下它的工作原理？" class="headerlink" title="你了解 Virtual DOM 吗？解释一下它的工作原理？"></a>你了解 Virtual DOM 吗？解释一下它的工作原理？</h4><pre><code>Virtual DOM 是一个轻量级的 JavaScript 对象，它最初只是 real DOM 的副本。它是一个节点树，它将元素、它们的属性和内容作为对象及其属性。 React 的渲染函数从 React 组件中创建一个节点树。然后它响应数据模型中的变化来更新该树，该变化是由用户或系统完成的各种动作引起的。
Virtual DOM 工作过程有三个简单的步骤：
每当底层数据发生改变时，整个 UI 都将在 Virtual DOM 描述中重新渲染。
然后计算之前 DOM 表示与新表示的之间的差异。
完成计算后，将只用实际更改的内容更新 real DOM</code></pre>
<h4 id="为什么浏览器无法读取JSX？"><a href="#为什么浏览器无法读取JSX？" class="headerlink" title="为什么浏览器无法读取JSX？"></a>为什么浏览器无法读取JSX？</h4><pre><code>浏览器只能处理 JavaScript 对象，而不能读取常规 JavaScript 对象中的 JSX。所以为了使浏览器能够读取 JSX，首先，需要用像 Babel 这样的 JSX 转换器将 JSX 文件转换为 JavaScript 对象，然后再将其传给浏览器。</code></pre>
<h4 id="与-ES5-相比，React-的-ES6-语法有何不同？"><a href="#与-ES5-相比，React-的-ES6-语法有何不同？" class="headerlink" title="与 ES5 相比，React 的 ES6 语法有何不同？"></a>与 ES5 相比，React 的 ES6 语法有何不同？</h4><h4 id="你理解“在React中，一切都是组件”这句话？"><a href="#你理解“在React中，一切都是组件”这句话？" class="headerlink" title="你理解“在React中，一切都是组件”这句话？"></a>你理解“在React中，一切都是组件”这句话？</h4><pre><code>组件是 React 应用 UI 的构建块。这些组件将整个 UI 分成小的独立并可重用的部分。每个组件彼此独立，而不会影响 UI 的其余部分。</code></pre>
<h4 id="解释-React-中-render-的目的？"><a href="#解释-React-中-render-的目的？" class="headerlink" title="解释 React 中 render() 的目的？"></a>解释 React 中 render() 的目的？</h4><pre><code>每个React组件强制要求必须有一个 render()。它返回一个 React 元素，是原生 DOM 组件的表示。如果需要渲染多个 HTML 元素，则必须将它们组合在一个封闭标记内，例如 &lt;form&gt;、&lt;group&gt;、&lt;div&gt; 等。此函数必须保持纯净，即必须每次调用时都返回相同的结果。</code></pre>
<h4 id="什么是-Props"><a href="#什么是-Props" class="headerlink" title="什么是 Props?"></a>什么是 Props?</h4><pre><code>Props 是 React 中属性的简写。它们是只读组件，必须保持纯，即不可变。它们总是在整个应用中从父组件传递到子组件。子组件永远不能将 prop 送回父组件。这有助于维护单向数据流，通常用于呈现动态生成的数据。</code></pre>
<h4 id="React中的状态是什么？它是如何使用的？"><a href="#React中的状态是什么？它是如何使用的？" class="headerlink" title="React中的状态是什么？它是如何使用的？"></a>React中的状态是什么？它是如何使用的？</h4><pre><code>状态是 React 组件的核心，是数据的来源，必须尽可能简单。基本上状态是确定组件呈现和行为的对象。与props 不同，它们是可变的，并创建动态和交互式组件。可以通过 this.state() 访问它们</code></pre>
<h4 id="如何更新组件的状态？"><a href="#如何更新组件的状态？" class="headerlink" title="如何更新组件的状态？"></a>如何更新组件的状态？</h4><pre><code>可以用 this.setState()更新组件的状态。</code></pre>
<h4 id="详细解释-React-组件的生命周期方法。"><a href="#详细解释-React-组件的生命周期方法。" class="headerlink" title="详细解释 React 组件的生命周期方法。"></a>详细解释 React 组件的生命周期方法。</h4><pre><code>componentWillMount**()** – 在渲染之前执行，在客户端和服务器端都会执行。
componentDidMount**()** – 仅在第一次渲染后在客户端执行。
componentWillReceiveProps**()** – 当从父类接收到 props 并且在调用另一个渲染器之前调用。
shouldComponentUpdate**()** – 根据特定条件返回 true 或 false。如果你希望更新组件，请返回true 否则返回 false。默认情况下，它返回 false。
componentWillUpdate**()** – 在 DOM 中进行渲染之前调用。
componentDidUpdate**()** – 在渲染发生后立即调用。
componentWillUnmount**()** – 从 DOM 卸载组件后调用。用于清理内存空间。</code></pre>
<h4 id="React中的合成事件是什么？"><a href="#React中的合成事件是什么？" class="headerlink" title="React中的合成事件是什么？"></a>React中的合成事件是什么？</h4><pre><code>合成事件是围绕浏览器原生事件充当跨浏览器包装器的对象。它们将不同浏览器的行为合并为一个 API。这样做是为了确保事件在不同浏览器中显示一致的属性。</code></pre>
<h4 id="你对-React-的-refs-有什么了解？"><a href="#你对-React-的-refs-有什么了解？" class="headerlink" title="你对 React 的 refs 有什么了解？"></a>你对 React 的 refs 有什么了解？</h4><pre><code>Refs 是 React 中引用的简写。它是一个有助于存储对特定的 React 元素或组件的引用的属性，它将由组件渲染配置函数返回。用于对 render() 返回的特定元素或组件的引用。当需要进行 DOM 测量或向组件添加方法时，它们会派上用场。</code></pre>
<h4 id="什么是高阶组件（HOC）？"><a href="#什么是高阶组件（HOC）？" class="headerlink" title="什么是高阶组件（HOC）？"></a>什么是高阶组件（HOC）？</h4><pre><code>高阶组件是重用组件逻辑的高级方法，是一种源于 React 的组件模式。 HOC 是自定义组件，在它之内包含另一个组件。它们可以接受子组件提供的任何动态，但不会修改或复制其输入组件中的任何行为。你可以认为 HOC 是“纯（Pure）”组件。</code></pre>
<h4 id="你能用HOC做什么？"><a href="#你能用HOC做什么？" class="headerlink" title="你能用HOC做什么？"></a>你能用HOC做什么？</h4><pre><code>代码重用，逻辑和引导抽象
渲染劫持
状态抽象和控制
Props 控制</code></pre>
<h4 id="什么是纯组件？"><a href="#什么是纯组件？" class="headerlink" title="什么是纯组件？"></a>什么是纯组件？</h4><pre><code>纯（Pure） 组件是可以编写的最简单、最快的组件。它们可以替换任何只有 render() 的组件。这些组件增强了代码的简单性和应用的性能。</code></pre>
<h4 id="React-中-key-的重要性是什么？"><a href="#React-中-key-的重要性是什么？" class="headerlink" title="React 中 key 的重要性是什么？"></a>React 中 key 的重要性是什么？</h4><pre><code>key 用于识别唯一的 Virtual DOM 元素及其驱动 UI 的相应数据。它们通过回收 DOM 中当前所有的元素来帮助 React 优化渲染。这些 key 必须是唯一的数字或字符串，React 只是重新排序元素而不是重新渲染它们。这可以提高应用程序的性能。</code></pre>
<h4 id="MVC框架的主要问题是什么？"><a href="#MVC框架的主要问题是什么？" class="headerlink" title="MVC框架的主要问题是什么？"></a>MVC框架的主要问题是什么？</h4><pre><code>对 DOM 操作的代价非常高
程序运行缓慢且效率低下
内存浪费严重
由于循环依赖性，组件模型需要围绕 models 和 views 进行创建</code></pre>
<h4 id="解释一下-Flux？"><a href="#解释一下-Flux？" class="headerlink" title="解释一下 Flux？"></a>解释一下 Flux？</h4><pre><code>Flux 是一种强制单向数据流的架构模式。它控制派生数据，并使用具有所有数据权限的中心 store 实现多个组件之间的通信。整个应用中的数据更新必须只能在此处进行。 Flux 为应用提供稳定性并减少运行时的错误。</code></pre>
<h4 id="什么是Redux？"><a href="#什么是Redux？" class="headerlink" title="什么是Redux？"></a>什么是Redux？</h4><pre><code>Redux 是当今最热门的前端开发库之一。它是 JavaScript 程序的可预测状态容器，用于整个应用的状态管理。使用 Redux 开发的应用易于测试，可以在不同环境中运行，并显示一致的行为。</code></pre>
<h4 id="Redux遵循的三个原则是什么？"><a href="#Redux遵循的三个原则是什么？" class="headerlink" title="Redux遵循的三个原则是什么？"></a>Redux遵循的三个原则是什么？</h4><pre><code>单一数据源
使用纯函数进行修改
状态是只读的</code></pre>
<h4 id="你对“单一事实来源”有什么理解？"><a href="#你对“单一事实来源”有什么理解？" class="headerlink" title="你对“单一事实来源”有什么理解？"></a>你对“单一事实来源”有什么理解？</h4><pre><code>Redux 使用 “Store” 将程序的整个状态存储在同一个地方。因此所有组件的状态都存储在 Store 中，并且它们从 Store 本身接收更新。单一状态树可以更容易地跟踪随时间的变化，并调试或检查程序。</code></pre>
<h4 id="列出-Redux-的组件。"><a href="#列出-Redux-的组件。" class="headerlink" title="列出 Redux 的组件。"></a>列出 Redux 的组件。</h4><pre><code>Action – 这是一个用来描述发生了什么事情的对象。
Reducer – 这是一个确定状态将如何变化的地方。
Store – 整个程序的状态/对象树保存在Store中。
View – 只显示 Store 提供的数据。</code></pre>
<h4 id="redux中间件？"><a href="#redux中间件？" class="headerlink" title="redux中间件？"></a>redux中间件？</h4><pre><code>edux-logger：提供日志输出
redux-thunk：处理异步操作
redux-promise：处理异步操作，actionCreator的返回值是promise</code></pre>
<h4 id="如何在-Redux-中定义-Action？"><a href="#如何在-Redux-中定义-Action？" class="headerlink" title="如何在 Redux 中定义 Action？"></a>如何在 Redux 中定义 Action？</h4><pre><code>React 中的 Action 必须具有 type 属性，该属性指示正在执行的 ACTION 的类型。必须将它们定义为字符串常量，并且还可以向其添加更多的属性。在 Redux 中，action 被名为 Action Creators 的函数所创建。以下是 Action 和Action Creator 的示例：</code></pre>
<h4 id="解释-Reducer-的作用？"><a href="#解释-Reducer-的作用？" class="headerlink" title="解释 Reducer 的作用？"></a>解释 Reducer 的作用？</h4><pre><code>Reducers 是纯函数，它规定应用程序的状态怎样因响应 ACTION 而改变。Reducers 通过接受先前的状态和 action 来工作，然后它返回一个新的状态。它根据操作的类型确定需要执行哪种更新，然后返回新的值。如果不需要完成任务，它会返回原来的状态。</code></pre>
<h4 id="Store-在-Redux-中的意义是什么？"><a href="#Store-在-Redux-中的意义是什么？" class="headerlink" title="Store 在 Redux 中的意义是什么？"></a>Store 在 Redux 中的意义是什么？</h4><pre><code>Store 是一个 JavaScript 对象，它可以保存程序的状态，并提供一些方法来访问状态、调度操作和注册侦听器。应用程序的整个状态/对象树保存在单一存储中。因此，Redux 非常简单且是可预测的。我们可以将中间件传递到 store 来处理数据，并记录改变存储状态的各种操作。所有操作都通过 reducer 返回一个新状态。</code></pre>
<h4 id="什么是React-路由？"><a href="#什么是React-路由？" class="headerlink" title="什么是React 路由？"></a>什么是React 路由？</h4><pre><code>React 路由是一个构建在 React 之上的强大的路由库，它有助于向应用程序添加新的屏幕和流。这使 URL 与网页上显示的数据保持同步。它负责维护标准化的结构和行为，并用于开发单页 Web 应用。 React 路由有一个简单的API。</code></pre>
<h4 id="为什么React-Router-v4中使用-switch-关键字-？"><a href="#为什么React-Router-v4中使用-switch-关键字-？" class="headerlink" title="为什么React Router v4中使用 switch 关键字 ？"></a>为什么React Router v4中使用 switch 关键字 ？</h4><pre><code>虽然 &lt;div&gt; ** 用于封装 Router 中的多个路由，当你想要仅显示要在多个定义的路线中呈现的单个路线时，可以使用 “switch” 关键字。使用时，&lt;switch&gt;** 标记会按顺序将已定义的 URL 与已定义的路由进行匹配。找到第一个匹配项后，它将渲染指定的路径。从而绕过其它路线。</code></pre>
<h4 id="为什么需要-React-中的路由？"><a href="#为什么需要-React-中的路由？" class="headerlink" title="为什么需要 React 中的路由？"></a>为什么需要 React 中的路由？</h4><pre><code>Router 用于定义多个路由，当用户定义特定的 URL 时，如果此 URL 与 Router 内定义的任何 “路由” 的路径匹配，则用户将重定向到该特定路由。所以基本上我们需要在自己的应用中添加一个 Router 库，允许创建多个路由，每个路由都会向我们提供一个独特的视图</code></pre>
<h4 id="react性能优化的方案？"><a href="#react性能优化的方案？" class="headerlink" title="react性能优化的方案？"></a>react性能优化的方案？</h4><pre><code>重写shouldComponentUpdate来避免不必要的dom操作。
使用 production 版本的react.js。
使用key来帮助React识别列表中所有子组件的最小变化。</code></pre>
<h4 id="介绍一下webpack？"><a href="#介绍一下webpack？" class="headerlink" title="介绍一下webpack？"></a>介绍一下webpack？</h4><pre><code>webpack是一个前端模块化打包工具，主要由入口，出口，loader，plugins四个部分。前端的打包工具还有一个gulp，不过gulp侧重于前端开发的过程，而webpack侧重于模块，例如他会将css文件看作一个模块，通过css-loader将css打包成符合css的静态资源。</code></pre>
<h4 id="react生命周期中，最适合与服务端进行数据交互的是哪个函数？"><a href="#react生命周期中，最适合与服务端进行数据交互的是哪个函数？" class="headerlink" title="react生命周期中，最适合与服务端进行数据交互的是哪个函数？"></a>react生命周期中，最适合与服务端进行数据交互的是哪个函数？</h4><pre><code>componentDidMount：在这个阶段，实例和dom已经挂载完成，可以进行相关的dom操作。</code></pre>
<h4 id="shouldComponentUpdate-是做什么的，（react-性能优化是哪个周期函数？）"><a href="#shouldComponentUpdate-是做什么的，（react-性能优化是哪个周期函数？）" class="headerlink" title="shouldComponentUpdate 是做什么的，（react 性能优化是哪个周期函数？）"></a>shouldComponentUpdate 是做什么的，（react 性能优化是哪个周期函数？）</h4><pre><code>询问组件是否需要更新的一个钩子函数，判断数据是否需要重新渲染，返回一个布尔值。默认的返回值是true，需要重新render()。若如果返回值是false则不触发渲染,利用这个生命周期函数可以强制关闭不需要更新的子组件来提升渲染性能。

这个方法用来判断是否需要调用 render 方法重新描绘 dom。
因为 dom 的描绘非常消耗性能，如果我们能在 shouldComponentUpdate 方法中能够写出更优化的 dom diff 算法，可以极大的提高性能。</code></pre>
<h4 id="指出-组件-生命周期方法的不同？"><a href="#指出-组件-生命周期方法的不同？" class="headerlink" title="指出(组件)生命周期方法的不同？"></a>指出(组件)生命周期方法的不同？</h4><pre><code>componentWillMount – 多用于根组件中的应用程序配置
componentDidMount – 在这可以完成所有没有 DOM 就不能做的所有配置，并开始获取所有你需要的数据；如果需要设置事件监听，也可以在这完成
componentWillReceiveProps – 这个周期函数作用于特定的 prop 改变导致的 state 转换
shouldComponentUpdate – 如果你担心组件过度渲染，shouldComponentUpdate 是一个改善性能的地方，因为如果组件接收了新的 prop， 它可以阻止(组件)重新渲染。shouldComponentUpdate 应该返回一个布尔值来决定组件是否要重新渲染
componentWillUpdate – 很少使用。它可以用于代替组件的 componentWillReceiveProps 和 shouldComponentUpdate(但不能访问之前的 props)
componentDidUpdate – 常用于更新 DOM，响应 prop 或 state 的改变
componentWillUnmount – 在这你可以取消网络请求，或者移除所有与组件相关的事件监听器</code></pre>
<h4 id="调用-setState-之后发生了什么？"><a href="#调用-setState-之后发生了什么？" class="headerlink" title="调用 setState 之后发生了什么？"></a>调用 setState 之后发生了什么？</h4><pre><code>代码中调用 setState 函数之后，React 会将传入的参数对象与组件当前的状态合并，然后触发所谓的调和过程（Reconciliation）。

经过调和过程，React 会以相对高效的方式根据新的状态构建 React 元素树并且着手重新渲染整个 UI 界面；
在 React 得到元素树之后，React 会自动计算出新的树与老树的节点差异，然后根据差异对界面进行最小化重渲染；
在差异计算算法中，React 能够相对精确地知道哪些位置发生了改变以及应该如何改变，这就保证了按需更新，而不是全部重新渲染。</code></pre>
<h4 id="react-diff-原理（常考，大厂必考）"><a href="#react-diff-原理（常考，大厂必考）" class="headerlink" title="react diff 原理（常考，大厂必考）"></a>react diff 原理（常考，大厂必考）</h4><pre><code>把树形结构按照层级分解，只比较同级元素。
列表结构的每个单元添加唯一的 key 属性，方便比较。
React 只会匹配相同 class 的 component（这里面的 class 指的是组件的名字）
合并操作，调用 component 的 setState 方法的时候, React 将其标记为 dirty.到每一个事件循环结束, React 检查所有标记 dirty 的 component 重新绘制.
选择性子树渲染。开发人员可以重写 shouldComponentUpdate 提高 diff 的性能。</code></pre>
<h4 id="为什么建议传递给-setState-的参数是一个-callback-而不是一个对象？"><a href="#为什么建议传递给-setState-的参数是一个-callback-而不是一个对象？" class="headerlink" title="为什么建议传递给 setState 的参数是一个 callback 而不是一个对象？"></a>为什么建议传递给 setState 的参数是一个 callback 而不是一个对象？</h4><pre><code>因为 this.props 和 this.state 的更新可能是异步的，不能依赖它们的值去计算下一个 state</code></pre>
<h4 id="除了在构造函数中绑定-this，还有其它方式吗？"><a href="#除了在构造函数中绑定-this，还有其它方式吗？" class="headerlink" title="除了在构造函数中绑定 this，还有其它方式吗？"></a>除了在构造函数中绑定 this，还有其它方式吗？</h4><pre><code>你可以使用属性初始值设定项(property initializers)来正确绑定回调，create-react-app 也是默认支持的。
在回调中你可以使用箭头函数，但问题是每次组件渲染时都会创建一个新的回调。</code></pre>
<h4 id="setState第二个参数的作用"><a href="#setState第二个参数的作用" class="headerlink" title="setState第二个参数的作用?"></a>setState第二个参数的作用?</h4><pre><code>因为setState是一个异步的过程，所以说执行完setState之后不能立刻更改state里面的值。如果需要对state数据更改监听，setState提供第二个参数，就是用来监听state里面数据的更改，当数据更改完成，调用回调函数。</code></pre>
<h4 id="在构造函数中-调用-super-props-的目的是什么"><a href="#在构造函数中-调用-super-props-的目的是什么" class="headerlink" title="(在构造函数中)调用 super(props) 的目的是什么?"></a>(在构造函数中)调用 super(props) 的目的是什么?</h4><pre><code>在 super() 被调用之前，子类是不能使用 this 的，在 ES2015 中，子类必须在 constructor 中调用 super()。
传递 props 给 super() 的原因则是便于(在子类中)能在 constructor 访问 this.props。</code></pre>
<h4 id="在-React-当中-Element-和-Component-有何区别？"><a href="#在-React-当中-Element-和-Component-有何区别？" class="headerlink" title="在 React 当中 Element 和 Component 有何区别？"></a>在 React 当中 Element 和 Component 有何区别？</h4><pre><code>React Element 是描述屏幕上所见内容的数据结构，是对于 UI 的对象表述。
典型的 React Element 就是利用 JSX 构建的声明式代码片然后被转化为 createElement 的调用组合。

React Component 是一个函数或一个类，可以接收参数输入，并且返回某个 React Element</code></pre>
<h4 id="组件的-状态-state-和属性-props-之间有何不同"><a href="#组件的-状态-state-和属性-props-之间有何不同" class="headerlink" title="(组件的)状态(state)和属性(props)之间有何不同?"></a>(组件的)状态(state)和属性(props)之间有何不同?</h4><pre><code>State 是一种数据结构，用于组件挂载时所需数据的默认值。State 可能会随着时间的推移而发生突变，但多数时候是作为用户事件行为的结果。
Props(properties 的简写)则是组件的配置。props 由父组件传递给子组件，并且就子组件而言，props 是不可变的(immutable)。组件不能改变自身的 props，但是可以把其子组件的 props 放在一起(统一管理)。Props 也不仅仅是数据–回调函数也可以通过 props 传递。</code></pre>
<h4 id="受控组件和非受控组件区别"><a href="#受控组件和非受控组件区别" class="headerlink" title="受控组件和非受控组件区别?"></a>受控组件和非受控组件区别?</h4><pre><code>受控组件：
1.没有维持自己的状态
2.数据由父组件控制
3.通过 props 获取当前值，然后通过回调通知更改

非受控组件：
1、保持着自己的状态
2、数据由 DOM 控制
3、Refs 用于获取其当前值</code></pre>
</div></section><div id="reward-container"><span class="hty-icon-button button-glow" id="reward-button" title="打赏" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === &quot;none&quot;) ? &quot;block&quot; : &quot;none&quot;;"><span class="icon iconify" data-icon="ri:hand-coin-line"></span></span><div id="reward-comment">我很可爱，请给我钱</div><div id="qr" style="display:none;"><div style="display:inline-block"><a target="_blank" rel="noopener" href="https://cdn.yunyoujun.cn/img/donate/alipay-qrcode.jpg"><img loading="lazy" src="https://cdn.yunyoujun.cn/img/donate/alipay-qrcode.jpg" alt="支付宝" title="支付宝"></a><div><span style="color:#00A3EE"><span class="icon iconify" data-icon="ri:alipay-line"></span></span></div></div><div style="display:inline-block"><a target="_blank" rel="noopener" href="https://cdn.yunyoujun.cn/img/donate/qqpay-qrcode.png"><img loading="lazy" src="https://cdn.yunyoujun.cn/img/donate/qqpay-qrcode.png" alt="QQ 支付" title="QQ 支付"></a><div><span style="color:#12B7F5"><span class="icon iconify" data-icon="ri:qq-line"></span></span></div></div><div style="display:inline-block"><a target="_blank" rel="noopener" href="https://cdn.yunyoujun.cn/img/donate/wechatpay-qrcode.jpg"><img loading="lazy" src="https://cdn.yunyoujun.cn/img/donate/wechatpay-qrcode.jpg" alt="微信支付" title="微信支付"></a><div><span style="color:#2DC100"><span class="icon iconify" data-icon="ri:wechat-pay-line"></span></span></div></div></div></div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>云游君</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="https://www.yunyoujun.cn/react%E9%9D%A2%E8%AF%95%E9%A2%98/" title="react面试题">https://www.yunyoujun.cn/react%E9%9D%A2%E8%AF%95%E9%A2%98/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>本博客所有文章除特别声明外，均默认采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0 "><span class="icon iconify" data-icon="ri:creative-commons-line"></span><span class="icon iconify" data-icon="ri:creative-commons-by-line"></span><span class="icon iconify" data-icon="ri:creative-commons-nc-line"></span><span class="icon iconify" data-icon="ri:creative-commons-sa-line"></span></a> 许可协议。</li></ul></article><div class="post-nav"><div class="post-nav-item"></div><div class="post-nav-item"><a class="post-nav-next" href="/vue%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="next" title="vue面试题"><span class="post-nav-text">vue面试题</span><span class="icon iconify" data-icon="ri:arrow-right-s-line"></span></a></div></div></div><div class="hty-card" id="comment"><div class="comment-tooltip text-center"><span>如果您有任何关于博客内容的相关讨论，欢迎前往 <a href="https://github.com/YunYouJun/yunyoujun.github.io/discussions" target="_blank">GitHub Discussions</a> 与我交流。</span><br></div><div id="waline"></div><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/@waline/client@v2/dist/waline.css"><script>window.CONFIG.waline.config.path = "/react%E9%9D%A2%E8%AF%95%E9%A2%98/"</script><div class="js-Pjax"><script src="/js/comments/waline.js" type="module" defer></script></div></div></main><footer class="sidebar-translate" id="footer"><div class="beian"><a rel="noopener" href="https://beian.miit.gov.cn/" target="_blank">苏ICP备17038157号</a></div><div class="copyright"><span>&copy; 2016 – 2022 </span><a class="with-love" id="animate" target="_blank" rel="noopener" href="https://sponsors.yunyoujun.cn" title="云游君的赞助者们"><span class="icon iconify" data-icon="ri:cloud-line"></span></a><span class="author"> 云游君</span></div><div class="powered"><span>由 <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> 驱动 v5.3.0</span><span class="footer-separator">|</span><span>主题 - <a rel="noopener" href="https://github.com/YunYouJun/hexo-theme-yun" target="_blank"><span>Yun</span></a> v1.10.4</span></div><div class="footer-support"><span>本网站由</span><a class="footer-support-logo" href="https://www.upyun.com" target="blank" title="又拍云"><img height="30" src="https://cdn.yunyoujun.cn/img/logo/upyun-logo.png" alt="又拍云"></a><span>提供 CDN 加速</span></div></footer></div><a class="hty-icon-button" id="back-to-top" aria-label="back-to-top" href="#"><span class="icon iconify" data-icon="ri:arrow-up-s-line"></span><svg class="progress-circle-container" viewBox="0 0 100 100"><circle class="progress-circle" id="progressCircle" cx="50" cy="50" r="48" fill="none" stroke="#0078E7" stroke-width="2" stroke-linecap="round"></circle></svg></a></body></html>