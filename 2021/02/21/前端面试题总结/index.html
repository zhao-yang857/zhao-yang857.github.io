<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="theme-color" content="#0078E7"><meta name="author" content="sun"><meta name="copyright" content="sun"><meta name="generator" content="Hexo 5.3.0"><meta name="theme" content="hexo-theme-yun"><title>前端面试题总结 | 太阳の小屋</title><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@900&amp;display=swap" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/star-markdown-css@0.1.22/dist/yun/yun-markdown.min.css"><script src="//at.alicdn.com/t/font_1140697_ed8vp4atwoj.js" async></script><script src="https://cdn.jsdelivr.net/npm/scrollreveal/dist/scrollreveal.min.js" defer></script><script>document.addEventListener("DOMContentLoaded", () => {
  [".post-card",".post-content img"].forEach((target)=> {
    ScrollReveal().reveal(target);
  })
});
</script><link rel="shortcut icon" type="image/svg+xml" href="/feng.ico"><link rel="mask-icon" href="/feng.ico" color="#0078E7"><link rel="alternate icon" href="/yun.ico"><link rel="preload" href="/css/hexo-theme-yun.css" as="style"><link rel="preload" href="/js/utils.js" as="script"><link rel="preload" href="/js/hexo-theme-yun.js" as="script"><link rel="prefetch" href="/js/sidebar.js" as="script"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><link rel="stylesheet" href="/css/hexo-theme-yun.css"><script id="yun-config">
    const Yun = window.Yun || {};
    window.CONFIG = {"hostname":"example.com","root":"/","title":"太阳の小屋","version":"1.3.0","mode":"auto","copycode":true,"anonymous_image":"https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/avatar/none.jpg","say":{"api":"https://v1.hitokoto.cn","hitokoto":true},"fireworks":{"colors":["219, 34, 9","216, 35, 223","252, 89, 170","89, 187, 252","103, 252, 89"]}};
  </script><meta name="description" content="一、css和html 部分一、csscss 盒模型1css盒模型分为标准盒模型和怪异盒模型&#x2F;IE盒模型 基础盒模型：content(内容) + border + padding + margin 怪异盒模型&#x2F;IE盒模型：content (content + border + padding) + margin 正常情况下padding和border的设置会影响元素宽高的计算 box-sizing:">
<meta property="og:type" content="article">
<meta property="og:title" content="前端面试题总结">
<meta property="og:url" content="http://example.com/2021/02/21/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/index.html">
<meta property="og:site_name" content="太阳の小屋">
<meta property="og:description" content="一、css和html 部分一、csscss 盒模型1css盒模型分为标准盒模型和怪异盒模型&#x2F;IE盒模型 基础盒模型：content(内容) + border + padding + margin 怪异盒模型&#x2F;IE盒模型：content (content + border + padding) + margin 正常情况下padding和border的设置会影响元素宽高的计算 box-sizing:">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2021-02-21T05:52:19.000Z">
<meta property="article:modified_time" content="2022-06-07T03:03:23.171Z">
<meta property="article:author" content="sun">
<meta name="twitter:card" content="summary"><script src="/js/ui/mode.js"></script></head><body><script defer src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script defer src="/js/ui/fireworks.js"></script><canvas class="fireworks"></canvas><div class="container"><a class="sidebar-toggle hty-icon-button" id="menu-btn"><div class="hamburger hamburger--spin" type="button"><span class="hamburger-box"><span class="hamburger-inner"></span></span></div></a><div class="sidebar-toggle sidebar-overlay"></div><aside class="sidebar"><script src="/js/sidebar.js"></script><ul class="sidebar-nav"><li class="sidebar-nav-item sidebar-nav-toc hty-icon-button sidebar-nav-active" data-target="post-toc-wrap" title="Table of Contents"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-list-ordered"></use></svg></li><li class="sidebar-nav-item sidebar-nav-overview hty-icon-button" data-target="site-overview-wrap" title="Overview"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-passport-line"></use></svg></li></ul><div class="sidebar-panel" id="site-overview-wrap"><div class="site-info fix-top"><a class="site-author-avatar" href="/about/" title="sun"><img width="96" loading="lazy" src="/images/%E5%A4%B4%E5%83%8F6.jpeg" alt="sun"></a><div class="site-author-name"><a href="/about/">sun</a></div><a class="site-name" href="/about/site.html">太阳の小屋</a><sub class="site-subtitle"></sub><div class="site-desciption"></div></div><nav class="site-state"><a class="site-state-item hty-icon-button icon-home" href="/" title="首页"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-home-4-line"></use></svg></span></a><div class="site-state-item"><a href="/archives/" title="归档"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-archive-line"></use></svg></span><span class="site-state-item-count">21</span></a></div><div class="site-state-item"><a href="/categories/" title="分类"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-2-line"></use></svg></span><span class="site-state-item-count">0</span></a></div><div class="site-state-item"><a href="/tags/" title="标签"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="site-state-item-count">0</span></a></div><a class="site-state-item hty-icon-button" target="_blank" rel="noopener" href="https://yun.yunyoujun.cn" title="留言板"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-clipboard-line"></use></svg></span></a></nav><hr style="margin-bottom:0.5rem"><div class="links-of-author"><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://qm.qq.com/cgi-bin/qm/qr?k=epvxdq1sknJe9JMj6J1LsBw4a6cI_2ln&amp;jump_from=webapi" title="QQ" target="_blank" style="color:#12B7F5"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-qq-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://github.com/zhao-yang857" title="GitHub" target="_blank" style="color:#6e5494"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-github-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://music.163.com/#/user/home?id=333632364" title="网易云音乐" target="_blank" style="color:#C20C0C"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-netease-cloud-music-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://space.bilibili.com/74908726" title="哔哩哔哩" target="_blank" style="color:#FF8EB3"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-bilibili-line"></use></svg></a></div><hr style="margin:0.5rem 1rem"><div class="links"><a class="links-item hty-icon-button" href="/links/" title="我的小伙伴们" style="color:dodgerblue"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-genderless-line"></use></svg></a><a class="links-item hty-icon-button" href="/girls/" title="我喜欢的女孩儿们" style="color:hotpink"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-women-line"></use></svg></a></div><br><a class="links-item hty-icon-button" id="toggle-mode-btn" href="javascript:;" title="Mode" style="color: #f1cb64"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-contrast-2-line"></use></svg></a></div><div class="sidebar-panel sidebar-panel-active" id="post-toc-wrap"><div class="post-toc"><div class="post-toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81css%E5%92%8Chtml-%E9%83%A8%E5%88%86"><span class="toc-number">1.</span> <span class="toc-text">一、css和html 部分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81css"><span class="toc-number">1.1.</span> <span class="toc-text">一、css</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#css-%E7%9B%92%E6%A8%A1%E5%9E%8B1"><span class="toc-number">1.1.1.</span> <span class="toc-text">css 盒模型1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#box-sizing%E5%B8%B8%E7%94%A8%E7%9A%84%E5%B1%9E%E6%80%A7%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E5%88%86%E5%88%AB%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">1.1.2.</span> <span class="toc-text">box-sizing常用的属性有哪些？分别有什么作用？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">1.1.3.</span> <span class="toc-text">3、清除浮动的方式有哪些</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E4%B8%8B%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0%E5%92%8C%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%E8%A1%8C%E5%86%85%E5%9D%97%E5%85%83%E7%B4%A0%E7%9A%84%E5%85%BC%E5%AE%B9%E6%80%A7%E4%BD%BF%E7%94%A8%EF%BC%9F%EF%BC%88IE8-%E4%BB%A5%E4%B8%8B%EF%BC%89"><span class="toc-number">1.1.4.</span> <span class="toc-text">说下行内元素和块级元素的区别？行内块元素的兼容性使用？（IE8 以下）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#css%E5%86%99%E4%B8%89%E8%A7%92%E5%BD%A2"><span class="toc-number">1.1.5.</span> <span class="toc-text">css写三角形</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#css-%E9%80%89%E6%8B%A9%E5%99%A8%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">1.1.6.</span> <span class="toc-text">css 选择器有哪些</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AE%B9%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95"><span class="toc-number">1.1.7.</span> <span class="toc-text">内容水平垂直居中有哪些方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#display-none-%E5%92%8C-visibility-hidden-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">1.1.8.</span> <span class="toc-text">display: none 和 visibility: hidden 有什么区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9E%E6%B5%81%E4%B8%8E%E9%87%8D%E7%BB%98"><span class="toc-number">1.1.9.</span> <span class="toc-text">回流与重绘</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%9B%9E%E6%B5%81"><span class="toc-number">1.1.9.1.</span> <span class="toc-text">一、什么是回流?</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E9%87%8D%E7%BB%98"><span class="toc-number">1.1.9.2.</span> <span class="toc-text">二、什么是重绘?</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E4%B8%A4%E8%80%85%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.1.9.3.</span> <span class="toc-text">三、两者的区别?</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E5%8F%91%E7%94%9F%E5%9B%9E%E6%B5%81%EF%BC%9F"><span class="toc-number">1.1.9.4.</span> <span class="toc-text">四、什么时候会发生回流？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E5%A6%82%E4%BD%95%E5%87%8F%E5%B0%91%E5%9B%9E%E6%B5%81%E5%92%8C%E9%87%8D%E7%BB%98%EF%BC%9F"><span class="toc-number">1.1.9.5.</span> <span class="toc-text">五、如何减少回流和重绘？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BFC%EF%BC%88Block-Formatting-Context%EF%BC%89-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%BA%94%E7%94%A8%EF%BC%9F"><span class="toc-number">1.1.10.</span> <span class="toc-text">BFC（Block Formatting Context） 是什么？应用？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%97%E5%87%BAdisplay%E7%9A%84%E5%80%BC-%E8%AF%B4%E6%98%8E%E4%BB%96%E4%BB%AC%E7%9A%84%E4%BD%9C%E7%94%A8%E3%80%82position%E7%9A%84%E5%80%BC-relative%E5%92%8Cabsolute%E5%88%86%E5%88%AB%E6%98%AF%E7%9B%B8%E5%AF%B9%E4%BA%8E%E8%B0%81%E8%BF%9B%E8%A1%8C%E5%AE%9A%E4%BD%8D%E7%9A%84"><span class="toc-number">1.1.11.</span> <span class="toc-text">列出display的值,说明他们的作用。position的值,relative和absolute分别是相对于谁进行定位的?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CSS3%E6%96%B0%E7%89%B9%E6%80%A7%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">1.1.12.</span> <span class="toc-text">CSS3新特性有哪些？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#css3%E6%96%B0%E5%A2%9E%E7%9A%84%E4%BC%AA%E7%B1%BB"><span class="toc-number">1.1.13.</span> <span class="toc-text">css3新增的伪类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#css3%E4%B8%AD%E5%8D%95%E4%BD%8Dpx-em-rem-vh-vw-vmin-vmax%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.1.14.</span> <span class="toc-text">css3中单位px,em,rem,vh,vw,vmin,vmax的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CSS%E9%9A%90%E8%97%8F%E5%85%83%E7%B4%A0%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95-%E8%87%B3%E5%B0%91%E8%AF%B4%E5%87%BA%E4%B8%89%E7%A7%8D"><span class="toc-number">1.1.15.</span> <span class="toc-text">CSS隐藏元素的几种方法(至少说出三种)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A%E4%B8%8BCSS-sprites-%E4%BB%A5%E5%8F%8A%E4%BD%A0%E8%A6%81%E5%A6%82%E4%BD%95%E5%9C%A8%E9%A1%B5%E9%9D%A2%E6%88%96%E7%BD%91%E7%AB%99%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%AE%83"><span class="toc-number">1.1.16.</span> <span class="toc-text">解释下CSS  sprites,以及你要如何在页面或网站中使用它</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A8%E8%AE%BACSS-hacks-%E6%9D%A1%E4%BB%B6%E5%BC%95%E7%94%A8%E6%88%96%E8%80%85%E5%85%B6%E4%BB%96"><span class="toc-number">1.1.17.</span> <span class="toc-text">讨论CSS hacks, 条件引用或者其他</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#css%E9%A2%84%E7%BC%96%E8%AF%91"><span class="toc-number">1.1.18.</span> <span class="toc-text">css预编译</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8css%E9%A2%84%E7%BC%96%E8%AF%91"><span class="toc-number">1.1.18.1.</span> <span class="toc-text">为什么要用css预编译</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#css%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-number">1.1.18.2.</span> <span class="toc-text">css的缺点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BB%E6%B5%81CSS%E9%A2%84%E7%BC%96%E8%AF%91%E5%99%A8%E7%9A%84%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.1.18.3.</span> <span class="toc-text">主流CSS预编译器的介绍</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Sass%E5%92%8CLess%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">1.1.18.4.</span> <span class="toc-text">Sass和Less的比较</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9%E4%BD%BF%E7%94%A8Sass%E8%80%8C%E4%B8%8D%E6%98%AFLess%EF%BC%9F"><span class="toc-number">1.1.19.</span> <span class="toc-text">为什么选择使用Sass而不是Less？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81html"><span class="toc-number">1.2.</span> <span class="toc-text">二、html</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E9%82%A3%E5%87%A0%E7%A7%8D%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B5%8B%E8%AF%95%EF%BC%9F%E6%9C%89%E5%93%AA%E4%BA%9B%E5%86%85%E6%A0%B8-Layout-Engine"><span class="toc-number">1.2.1.</span> <span class="toc-text">常用那几种浏览器测试？有哪些内核(Layout Engine)?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTML5-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AA%E9%9C%80%E8%A6%81%E5%86%99-lt-DOCTYPE-html-gt-%EF%BC%9F"><span class="toc-number">1.2.2.</span> <span class="toc-text">HTML5 为什么只需要写&lt;!　DOCTYPE html&gt; ？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E5%AF%BC%E5%85%A5%E6%A0%B7%E5%BC%8F%E6%97%B6%EF%BC%8C%E4%BD%BF%E7%94%A8link%E5%92%8C-import%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.2.3.</span> <span class="toc-text">页面导入样式时，使用link和@import有什么区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8HTML%E5%BD%93%E4%B8%AD%E5%BC%95%E7%94%A8CSS%E7%9A%84%E4%B8%89%E7%A7%8D%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E5%AE%83%E4%BB%AC%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.2.4.</span> <span class="toc-text">在HTML当中引用CSS的三种使用方式有哪些？它们之间的区别是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#html5%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9F"><span class="toc-number">1.2.5.</span> <span class="toc-text">html5有哪些新特性？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E8%BF%B0%E4%B8%80%E4%B8%8B%E4%BD%A0%E5%AF%B9HTML%E8%AF%AD%E4%B9%89%E5%8C%96%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F"><span class="toc-number">1.2.6.</span> <span class="toc-text">简述一下你对HTML语义化的理解？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E5%A4%9A%E4%B8%AA%E6%A0%87%E7%AD%BE%E9%A1%B5%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1"><span class="toc-number">1.2.7.</span> <span class="toc-text">如何实现浏览器内多个标签页之间的通信?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#webSocket%E5%A6%82%E4%BD%95%E5%85%BC%E5%AE%B9%E4%BD%8E%E6%B5%8F%E8%A7%88%E5%99%A8%EF%BC%9F"><span class="toc-number">1.2.8.</span> <span class="toc-text">webSocket如何兼容低浏览器？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B7%E5%86%99%E5%87%BA%E4%B8%80%E4%BA%9B%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">1.2.9.</span> <span class="toc-text">请写出一些前端性能优化的方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#iframe%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="toc-number">1.2.10.</span> <span class="toc-text">iframe的优缺点？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BD%91%E9%A1%B5%E5%B8%83%E5%B1%80%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">1.2.11.</span> <span class="toc-text">网页布局有哪几种，有什么区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E8%AE%A9Chrome%E6%94%AF%E6%8C%81%E5%B0%8F%E4%BA%8E12px-%E7%9A%84%E6%96%87%E5%AD%97%EF%BC%9F"><span class="toc-number">1.2.12.</span> <span class="toc-text">怎么让Chrome支持小于12px 的文字？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Doctype%E4%BD%9C%E7%94%A8-%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F%E4%B8%8E%E6%B7%B7%E6%9D%82%E6%A8%A1%E5%BC%8F%E5%A6%82%E4%BD%95%E5%8C%BA%E5%88%86%EF%BC%9F%E5%AE%83%E4%BB%AC%E6%9C%89%E4%BD%95%E6%84%8F%E4%B9%89"><span class="toc-number">1.2.13.</span> <span class="toc-text">Doctype作用? 严格模式与混杂模式如何区分？它们有何意义?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Doctype%E6%96%87%E6%A1%A3%E7%B1%BB%E5%9E%8B%EF%BC%9F"><span class="toc-number">1.2.14.</span> <span class="toc-text">Doctype文档类型？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTML%E4%B8%8EXHTML%E2%80%94%E2%80%94%E4%BA%8C%E8%80%85%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">1.2.15.</span> <span class="toc-text">HTML与XHTML——二者有什么区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E5%85%BC%E5%AE%B9%E6%80%A7%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">1.2.16.</span> <span class="toc-text">常见兼容性问题？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.2.17.</span> <span class="toc-text">线程与进程的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AF%B9%E7%BD%91%E7%AB%99%E7%9A%84%E6%96%87%E4%BB%B6%E5%92%8C%E8%B5%84%E6%BA%90%E8%BF%9B%E8%A1%8C%E4%BC%98%E5%8C%96%EF%BC%9F"><span class="toc-number">1.2.18.</span> <span class="toc-text">如何对网站的文件和资源进行优化？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B7%E8%AF%B4%E5%87%BA%E4%B8%89%E7%A7%8D%E5%87%8F%E5%B0%91%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E6%97%B6%E9%97%B4%E7%9A%84%E6%96%B9%E6%B3%95%E3%80%82"><span class="toc-number">1.2.19.</span> <span class="toc-text">请说出三种减少页面加载时间的方法。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-FOUC%EF%BC%88%E6%97%A0%E6%A0%B7%E5%BC%8F%E5%86%85%E5%AE%B9%E9%97%AA%E7%83%81%EF%BC%89%EF%BC%9F%E4%BD%A0%E5%A6%82%E4%BD%95%E6%9D%A5%E9%81%BF%E5%85%8D-FOUC%EF%BC%9F"><span class="toc-number">1.2.20.</span> <span class="toc-text">什么是 FOUC（无样式内容闪烁）？你如何来避免 FOUC？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8form%E8%A1%A8%E5%8D%95%E4%B8%AD%EF%BC%8Cget%E6%96%B9%E5%BC%8F%E5%92%8Cpost%E6%96%B9%E5%BC%8F%E6%8F%90%E4%BA%A4%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%9C%A8%E5%AE%9E%E9%99%85%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%9F"><span class="toc-number">1.2.21.</span> <span class="toc-text">在form表单中，get方式和post方式提交数据的区别是什么？如何判断在实际开发中的应用？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8input%E8%A1%A8%E5%8D%95%E6%8E%A7%E4%BB%B6%E4%B8%AD%EF%BC%8Cvalue%E5%92%8Cplaceholder%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.2.22.</span> <span class="toc-text">在input表单控件中，value和placeholder的区别是什么？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81js-%E9%83%A8%E5%88%86"><span class="toc-number">2.</span> <span class="toc-text">二、js 部分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#js%E6%98%AF%E4%BB%80%E4%B9%88%E8%AF%AD%E8%A8%80"><span class="toc-number">2.1.</span> <span class="toc-text">js是什么语言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#js-%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%8C%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%A4%8D%E6%9D%82%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.2.</span> <span class="toc-text">js 的基本数据类型有哪些，基本数据类型和复杂数据类型的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%92%8C-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">2.3.</span> <span class="toc-text">&#x3D;&#x3D; 和 &#x3D;&#x3D;&#x3D; 有什么区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#split-%E5%92%8C-join-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.4.</span> <span class="toc-text">split () 和 join () 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#call-%E3%80%81bind-%E3%80%81apply-%E5%8C%BA%E5%88%AB"><span class="toc-number">2.5.</span> <span class="toc-text">call ()、bind ()、apply () 区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E6%9C%89%E5%93%AA%E4%BA%9B%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95"><span class="toc-number">2.6.</span> <span class="toc-text">数组有哪些操作方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%97%AD%E5%8C%85"><span class="toc-number">2.7.</span> <span class="toc-text">什么是闭包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#null-%E5%92%8C-undefined-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.8.</span> <span class="toc-text">null 和 undefined 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87"><span class="toc-number">2.9.</span> <span class="toc-text">什么是变量提升</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98"><span class="toc-number">2.10.</span> <span class="toc-text">什么是事件委托</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-number">2.11.</span> <span class="toc-text">深拷贝和浅拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#async-%E4%B8%8E-defer-%E5%8C%BA%E5%88%AB"><span class="toc-number">2.12.</span> <span class="toc-text">async 与 defer 区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cookies%EF%BC%8CsessionStorage-%E5%92%8C-localStorage-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">2.13.</span> <span class="toc-text">cookies，sessionStorage 和 localStorage 有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95"><span class="toc-number">2.14.</span> <span class="toc-text">数组去重有哪些方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%88%A9%E7%94%A8%E5%86%92%E6%B3%A1-for-%E5%BE%AA%E7%8E%AF%E5%B5%8C%E5%A5%97%EF%BC%8C%E7%84%B6%E5%90%8E-splice-%E5%8E%BB%E9%87%8D-%E5%A6%82%EF%BC%9A"><span class="toc-number">2.14.1.</span> <span class="toc-text">1.利用冒泡 for 循环嵌套，然后 splice () 去重 如：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-indexOf-%E5%8E%BB%E9%87%8D-%E5%A6%82%EF%BC%9A"><span class="toc-number">2.14.2.</span> <span class="toc-text">2.indexOf () 去重 如：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-sort-%E5%8E%BB%E9%87%8D-%E5%A6%82%EF%BC%9A"><span class="toc-number">2.14.3.</span> <span class="toc-text">3.sort () 去重 如：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-filter-%E5%8E%BB%E9%87%8D-%E5%A6%82"><span class="toc-number">2.14.4.</span> <span class="toc-text">4.filter () 去重 如:</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GET-%E5%92%8C-POST-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">2.15.</span> <span class="toc-text">GET 和 POST 有什么区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%A8%E5%9F%9F%E6%9C%89%E5%87%A0%E7%A7%8D%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">2.16.</span> <span class="toc-text">跨域有几种解决方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#typeof-%E5%92%8C-instanceof-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">2.17.</span> <span class="toc-text">typeof 和 instanceof 有什么区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81vue-%E9%83%A8%E5%88%86"><span class="toc-number">3.</span> <span class="toc-text">三、vue 部分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#vue-%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%BB%A5%E5%8F%8A%E9%A1%B5%E9%9D%A2%E5%88%9D%E6%AC%A1%E5%8A%A0%E8%BD%BD%E4%BC%9A%E8%A7%A6%E5%8F%91%E5%93%AA%E4%BA%9B%E9%92%A9%E5%AD%90"><span class="toc-number">3.1.</span> <span class="toc-text">vue 的生命周期以及页面初次加载会触发哪些钩子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#v-if-%E5%92%8C-v-for-%E5%93%AA%E4%B8%80%E4%B8%AA%E4%BC%98%E5%85%88%E7%BA%A7%E9%AB%98"><span class="toc-number">3.2.</span> <span class="toc-text">v-if 和 v-for 哪一个优先级高</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#v-if-%E5%92%8C-v-show-%E6%9C%89%E4%BB%80%E4%B9%88%E5%BC%82%E5%90%8C"><span class="toc-number">3.3.</span> <span class="toc-text">v-if 和 v-show 有什么异同</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vue-%E4%B8%AD-data-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BF%85%E9%A1%BB%E6%98%AF%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0"><span class="toc-number">3.4.</span> <span class="toc-text">vue 中 data 为什么必须是一个函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#v-for-%E9%87%8C%E9%9D%A2-key-%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">3.5.</span> <span class="toc-text">v-for 里面 key 的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E5%80%BC%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">3.6.</span> <span class="toc-text">传值方式有哪些</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%B5%E9%9D%A2%E9%97%AA%E5%8A%A8%E9%97%AE%E9%A2%98"><span class="toc-number">3.7.</span> <span class="toc-text">初始化页面闪动问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#route%E5%92%8C-router-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.8.</span> <span class="toc-text">route和 router 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vuex-%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E7%8A%B6%E6%80%81"><span class="toc-number">3.9.</span> <span class="toc-text">vuex 有哪几种状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vue-router-%E6%9C%89%E5%87%A0%E7%A7%8D%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.10.</span> <span class="toc-text">vue-router 有几种模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vue-%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">3.11.</span> <span class="toc-text">vue 实现数据双向绑定的原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E8%B7%B3%E8%BD%AC%E7%9A%84%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8A%E6%96%B9%E5%BC%8F"><span class="toc-number">3.12.</span> <span class="toc-text">路由跳转的原理以及方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%85%B6%E5%AE%83"><span class="toc-number">4.</span> <span class="toc-text">四、其它</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-MVC-%E5%92%8C-MVVM-%E5%92%8C-MVP"><span class="toc-number">4.1.</span> <span class="toc-text">什么是 MVC 和 MVVM 和 MVP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E9%9B%85%E9%99%8D%E7%BA%A7%E5%92%8C%E6%B8%90%E8%BF%9B%E5%A2%9E%E5%BC%BA"><span class="toc-number">4.2.</span> <span class="toc-text">优雅降级和渐进增强</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E9%A1%B5%E9%9D%A2%E6%9C%89%E5%93%AA%E4%B8%89%E5%B1%82%E6%9E%84%E6%88%90%EF%BC%8C%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">4.3.</span> <span class="toc-text">浏览器页面有哪三层构成，分别是什么，作用是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E9%87%8D%E6%9E%84%E6%80%8E%E4%B9%88%E6%93%8D%E4%BD%9C%EF%BC%9F"><span class="toc-number">4.4.</span> <span class="toc-text">页面重构怎么操作？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-number">4.5.</span> <span class="toc-text">前端性能优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#http-%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B"><span class="toc-number">4.6.</span> <span class="toc-text">http 请求过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-%E5%B8%B8%E8%A7%81%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-number">4.7.</span> <span class="toc-text">HTTP 常见状态码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E5%AE%8C%E6%95%B4%E7%9A%84-url-%E5%8C%85%E6%8B%AC%E5%93%AA%E5%87%A0%E9%83%A8%E5%88%86"><span class="toc-number">4.8.</span> <span class="toc-text">一个完整的 url 包括哪几部分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#webpack%E9%85%8D%E7%BD%AE%E5%85%A5%E5%8F%A3%E5%87%BA%E5%8F%A3"><span class="toc-number">4.9.</span> <span class="toc-text">webpack配置入口出口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#webpack3%E5%92%8Cwebpack4%E5%8C%BA%E5%88%AB"><span class="toc-number">4.10.</span> <span class="toc-text">webpack3和webpack4区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#es6%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-number">4.11.</span> <span class="toc-text">es6新特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98"><span class="toc-number">4.12.</span> <span class="toc-text">浏览器缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8Ddefine"><span class="toc-number">4.13.</span> <span class="toc-text">介绍define</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#express%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">4.14.</span> <span class="toc-text">express是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#require%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">4.15.</span> <span class="toc-text">require是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1%E3%80%81%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98%E4%BB%A5%E5%8F%8A%E4%BA%8B%E4%BB%B6%E6%8D%95%E8%8E%B7%EF%BC%9F"><span class="toc-number">4.16.</span> <span class="toc-text">事件冒泡、事件委托以及事件捕获？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F%E5%92%8C%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.17.</span> <span class="toc-text">发布订阅模式和观察者模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.17.1.</span> <span class="toc-text">观察者模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.17.2.</span> <span class="toc-text">发布订阅模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB"><span class="toc-number">4.17.3.</span> <span class="toc-text">区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#axios%E5%92%8Cajax%E5%92%8Cfetch%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.18.</span> <span class="toc-text">axios和ajax和fetch的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9A%82%E6%97%B6%E6%80%A7%E6%AD%BB%E5%8C%BA"><span class="toc-number">4.19.</span> <span class="toc-text">暂时性死区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ToB%E5%92%8CToC%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.20.</span> <span class="toc-text">ToB和ToC的区别</span></a></li></ol></li></ol></div></div></div></aside><main class="sidebar-translate" id="content"><div id="post"><article class="post-block" itemscope itemtype="https://schema.org/Article"><link itemprop="mainEntityOfPage" href="http://example.com/2021/02/21/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/"><span hidden itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="name" content="sun"><meta itemprop="description"></span><span hidden itemprop="publisher" itemscope itemtype="https://schema.org/Organization"><meta itemprop="name" content="太阳の小屋"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">前端面试题总结</h1><div class="post-meta"><div class="post-time" style="display:inline-block"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-line"></use></svg></span> <time title="Created: 2021-02-21 13:52:19" itemprop="dateCreated datePublished" datetime="2021-02-21T13:52:19+08:00">2021-02-21</time><span class="post-meta-divider">-</span><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-2-line"></use></svg></span> <time title="Modified: 2022-06-07 11:03:23" itemprop="dateModified" datetime="2022-06-07T11:03:23+08:00">2022-06-07</time></div><div class="post-classify"></div></div></header><section class="post-body" itemprop="articleBody"><div class="post-content markdown-body" style="--smc-primary:#0078E7;"><h2 id="一、css和html-部分"><a href="#一、css和html-部分" class="headerlink" title="一、css和html 部分"></a>一、css和html 部分</h2><h3 id="一、css"><a href="#一、css" class="headerlink" title="一、css"></a>一、css</h3><h4 id="css-盒模型1"><a href="#css-盒模型1" class="headerlink" title="css 盒模型1"></a>css 盒模型1</h4><pre><code>css盒模型分为标准盒模型和怪异盒模型/IE盒模型
基础盒模型：content(内容) + border + padding + margin
怪异盒模型/IE盒模型：content (content + border + padding) + margin
正常情况下padding和border的设置会影响元素宽高的计算
box-sizing: content-box (称为标准盒模型)     width = 元素内容的宽度
box-sizing: border-box (称为怪异盒模型/IE盒模型)    width = 元素内容的宽度 + padding + border</code></pre>
<h4 id="box-sizing常用的属性有哪些？分别有什么作用？"><a href="#box-sizing常用的属性有哪些？分别有什么作用？" class="headerlink" title="box-sizing常用的属性有哪些？分别有什么作用？"></a>box-sizing常用的属性有哪些？分别有什么作用？</h4><pre><code>box-sizing: content-box|border-box|inherit;
content-box:宽度和高度分别应用到元素的内容框。
border-box:通过从已设定的宽度和高度分别减去边框和内边距才能得到内容的宽度和高度。</code></pre>
<h4 id="3、清除浮动的方式有哪些"><a href="#3、清除浮动的方式有哪些" class="headerlink" title="3、清除浮动的方式有哪些"></a>3、清除浮动的方式有哪些</h4><pre><code>（1）父级div定义height。
（2）结尾处加空div标签clear:both。如：.clear &#123;clear:both &#125;
（3）父级div定义伪类:after和zoom。 如： .clearfix:before,.clearfix:after &#123; content: &#39;&#39;; display: table; &#125;  .clearfix:after &#123; clear: both &#125;  .clearfix &#123; *zoom: 1; /*此处是为ie6、7处理的方式 */&#125;
（4）父级div定义overflow:hidden。
（5）父级div定义overflow:auto。
（6）父级div也浮动，需要定义宽度。
（7）父级div定义display:table。
（8）结尾处加br标签clear:both。</code></pre>
<h4 id="说下行内元素和块级元素的区别？行内块元素的兼容性使用？（IE8-以下）"><a href="#说下行内元素和块级元素的区别？行内块元素的兼容性使用？（IE8-以下）" class="headerlink" title="说下行内元素和块级元素的区别？行内块元素的兼容性使用？（IE8 以下）"></a>说下行内元素和块级元素的区别？行内块元素的兼容性使用？（IE8 以下）</h4><pre><code>行内元素：会在水平方向排列，直至一行排不下才会换行，其宽度随元素的内容而变化,不能包含块级元素，设置width无效，height无效(可以设置line-height)，margin上下无效，padding上下无效。（行内元素 : span,a,label,input,img,strong,em;）

块级元素：各占据一行，垂直方向排列。其宽度自动填满其父元素宽度。（块级元素：div,p,h1,form,ul,li;）
兼容性：display:inline-block;*display:inline;*zoom:1;</code></pre>
<h4 id="css写三角形"><a href="#css写三角形" class="headerlink" title="css写三角形"></a>css写三角形</h4><pre><code>以三角形为例:
div&#123;
    width: 0;
    height: 0;
    border-left: 50px solid transparent;
    border-right: 50px solid transparent;
    border-bottom: 100px solid red;
&#125;
左右两边边长为50透明
上边边长100
显示出来的就是一个红色面积的三角</code></pre>
<h4 id="css-选择器有哪些"><a href="#css-选择器有哪些" class="headerlink" title="css 选择器有哪些"></a>css 选择器有哪些</h4><pre><code>id选择器（#id）
类选择器（.class）
标签选择器（div、p、li）
子代选择器（ul&gt;li）
后代选择器（ul li）
通配符选择器（*）
属性选择器（input[type=&quot;text&quot;]、p[class]）
伪类选择器（li:first-child、li:nth-child(n)）
相邻兄弟选择器（div+p）
通用兄弟选择器（div~p）
群组选择器（div,span,li,p）
相同权重下：内联样式（标签内部） &gt; 嵌入样式（当前文件style） &gt; 外部样式（外部文件）</code></pre>
<blockquote>
<p>可以继承的属性：</p>
</blockquote>
<pre><code>可继承的样式： font-size font-family color, UL LI DL DD DT;
不可继承的样式：border padding margin width height ;

优先级：!important &gt; id &gt; class &gt; tag
important 比 内联优先级高,但内联比 id 要高</code></pre>
<h4 id="内容水平垂直居中有哪些方法"><a href="#内容水平垂直居中有哪些方法" class="headerlink" title="内容水平垂直居中有哪些方法"></a>内容水平垂直居中有哪些方法</h4><pre><code>文本居中：text-align:center; height:100px; line-height:100px;

已知宽高：如width:20px;height:20px 

父级position:relative 内容position:absolute; left: 50%; top: 50%; margin-left:-10px; margin-top: -10px;

不知宽高：

父级position:relative 内容position:absolute; left: 50%; top: 50%; transform: translate(-50%, -50%)

父级display:flex; align-items: center; justify-content: center; (css3属性)

父级display:table; 子级 display: table-cell; vertical-align: middle;</code></pre>
<h4 id="display-none-和-visibility-hidden-有什么区别"><a href="#display-none-和-visibility-hidden-有什么区别" class="headerlink" title="display: none 和 visibility: hidden 有什么区别"></a>display: none 和 visibility: hidden 有什么区别</h4><pre><code>display: none 隐藏 不占空间 （回流 + 重绘）
visibility: hidden 隐藏 保留原有空间 （重绘）</code></pre>
<h4 id="回流与重绘"><a href="#回流与重绘" class="headerlink" title="回流与重绘"></a>回流与重绘</h4><h5 id="一、什么是回流"><a href="#一、什么是回流" class="headerlink" title="一、什么是回流?"></a>一、什么是回流?</h5><pre><code>当我们对 DOM 的修改引发了 DOM 几何尺寸的变化（比如修改元素的宽、高或隐藏元素等）时，浏览器需要重新计算元素的几何属性（其他元素的几何属性和位置也会因此受到影响），
然后再将计算的结果绘制出来。这个过程就是回流（也叫重排）。每个页面都至少发生一次回流，也就是页面第一次加载的时候。</code></pre>
<h5 id="二、什么是重绘"><a href="#二、什么是重绘" class="headerlink" title="二、什么是重绘?"></a>二、什么是重绘?</h5><pre><code>当我们对 DOM 的修改导致了样式的变化、却并未影响其几何属性（比如修改了颜色或背景色）时，
浏览器不需重新计算元素的几何属性、直接为该元素绘制新的样式（跳过了上图所示的回流环节）。这个过程叫做重绘。</code></pre>
<h5 id="三、两者的区别"><a href="#三、两者的区别" class="headerlink" title="三、两者的区别?"></a>三、两者的区别?</h5><pre><code>他们的区别很大：
回流必将引起重绘，而重绘不一定会引起回流。比如：只有颜色改变的时候就只会发生重绘而不会引起回流
当页面布局和几何属性改变时就需要回流
比如：添加或者删除可见的DOM元素，元素位置改变，元素尺寸改变——边距、填充、边框、宽度和高度，内容改变</code></pre>
<h5 id="四、什么时候会发生回流？"><a href="#四、什么时候会发生回流？" class="headerlink" title="四、什么时候会发生回流？"></a>四、什么时候会发生回流？</h5><pre><code>1、添加或者删除可见的DOM元素的时候
2、元素的位置发生改变
3、元素尺寸改变
4、内容改变
5、页面第一次渲染的时候</code></pre>
<h5 id="五、如何减少回流和重绘？"><a href="#五、如何减少回流和重绘？" class="headerlink" title="五、如何减少回流和重绘？"></a>五、如何减少回流和重绘？</h5><ol>
<li>使用 transform 替代 top</li>
<li>使用 visibility 替换 display: none。因为前者只会引起重绘，后者会引发回流（改变了布局）</li>
<li>不要把节点的属性值放在一个循环里当成循环里的变量</li>
<li>不要使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局</li>
<li>动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使用requestAnimationFrame</li>
<li>CSS 选择符从右往左匹配查找，避免节点层级过多</li>
</ol>
<h4 id="BFC（Block-Formatting-Context）-是什么？应用？"><a href="#BFC（Block-Formatting-Context）-是什么？应用？" class="headerlink" title="BFC（Block Formatting Context） 是什么？应用？"></a>BFC（Block Formatting Context） 是什么？应用？</h4><p>BFC 就是 块级格式上下文 的格式，创建了BFC的元素就是一个独立的盒子，不过只有BLock-level box可以参与创建BFC，<br>它规定了内部的Bloc-level Box 如何布局，并且与这个独立盒子里的布局不受外部影响，当然它也不会影响到外面的元素。<br>应用场景：<br>    解决margin叠加的问题<br>    用于布局（overflow: hidden）,BFC不会与浮动盒子叠加。<br>    用于清除浮动，计算BFC高度</p>
<h4 id="列出display的值-说明他们的作用。position的值-relative和absolute分别是相对于谁进行定位的"><a href="#列出display的值-说明他们的作用。position的值-relative和absolute分别是相对于谁进行定位的" class="headerlink" title="列出display的值,说明他们的作用。position的值,relative和absolute分别是相对于谁进行定位的?"></a>列出display的值,说明他们的作用。position的值,relative和absolute分别是相对于谁进行定位的?</h4><pre><code>block 象块类型元素一样显示。
inline 缺省值。象行内元素类型一样显示。
inline-block 象行内元素一样显示，但其内容象块类型元素一样显示。
list-item 象块类型元素一样显示，并添加样式列表标记。

absolute 
    生成绝对定位的元素，相对于 static 定位以外的第一个祖先元素进行定位。 
fixed （老IE不支持）
    生成绝对定位的元素，相对于浏览器窗口进行定位。 
relative 
    生成相对定位的元素，相对于其在普通流中的位置进行定位。 
 static  默认值。没有定位，元素出现在正常的流中
（忽略 top, bottom, left, right z-index 声明）。
 inherit 规定从父元素继承 position 属性的值。</code></pre>
<h4 id="CSS3新特性有哪些？"><a href="#CSS3新特性有哪些？" class="headerlink" title="CSS3新特性有哪些？"></a>CSS3新特性有哪些？</h4><pre><code>1.颜色：新增RGBA，HSLA模式
2.文字阴影（text-shadow、）
3.边框： 圆角（border-radius）边框阴影： box-shadow
4.盒子模型：box-sizing
5.背景：background-size 设置背景图片的尺寸background-origin 设置背景图片的原点background-clip 设置背景图片的裁切区域，以”，”分隔可以设置多背景，用于自适应布局
6.渐变：linear-gradient、radial-gradient
7.过渡：transition，可实现动画
8.自定义动画
9.在CSS3中唯一引入的伪元素是 ：selection.
10.媒体查询，多栏布局
11.border-image
12.2D转换：transform：translate(x，y) rotate(x，y) skew(x，y) scale(x，y)
13.3D转换</code></pre>
<h4 id="css3新增的伪类"><a href="#css3新增的伪类" class="headerlink" title="css3新增的伪类"></a>css3新增的伪类</h4><pre><code>p:first-of-type 选择属于其父元素的首个 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。
p:last-of-type 选择属于其父元素的最后 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。
p:only-of-type 选择属于其父元素唯一的 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。
p:only-child 选择属于其父元素的唯一子元素的每个 &lt;p&gt; 元素。 p:nth-child(2) 选择属于其父元素的第二个子元素的每个 &lt;p&gt; 元素。 :enabled、:disabled 控制表单控件的禁用状态。
:checked，单选框或复选框被选中。html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？</code></pre>
<h4 id="css3中单位px-em-rem-vh-vw-vmin-vmax的区别"><a href="#css3中单位px-em-rem-vh-vw-vmin-vmax的区别" class="headerlink" title="css3中单位px,em,rem,vh,vw,vmin,vmax的区别"></a>css3中单位px,em,rem,vh,vw,vmin,vmax的区别</h4><p>px：绝对单位，页面按精确像素展示</p>
<p>em：相对单位，基准点为父节点字体的大小，如果自身定义了font-size按自身来计算（浏览器默认字体是16px），整个页面内1em不是一个固定的值。</p>
<p>rem：相对单位，可理解为”root em”, 相对根节点html的字体大小来计算，CSS3新加属性，chrome/firefox/IE9+支持。</p>
<p>vw：viewpoint width，视窗宽度，1vw等于视窗宽度的1%。<br>vh：viewpoint height，视窗高度，1vh等于视窗高度的1%。<br>vmin：vw和vh中较小的那个。<br>vmax：vw和vh中较大的那个。</p>
<p>vw, vh, vmin, vmax：IE9+局部支持，chrome/firefox/safari/opera支持，ios safari 8+支持，android browser4.4+支持，chrome for android39支持</p>
<p>viewport的概念</p>
<p>移动设备上的viewport就是设备的屏幕上能用来显示我们的网页的那一块区域.</p>
<p>就是浏览器上(也可能是一个app中的webview)用来显示网页的那部分区域，但viewport又不局限于浏览器可视区域的大小，它可能比浏览器的可视区域要大，也可能比浏览器的可视区域要小。</p>
<h4 id="CSS隐藏元素的几种方法-至少说出三种"><a href="#CSS隐藏元素的几种方法-至少说出三种" class="headerlink" title="CSS隐藏元素的几种方法(至少说出三种)"></a>CSS隐藏元素的几种方法(至少说出三种)</h4><pre><code>Opacity:元素本身依然占据它自己的位置并对网页的布局起作用。它也将响应用户交互;
Visibility:与 opacity 唯一不同的是它不会响应任何用户交互。此外，元素在读屏软件中也会被隐藏;
Display:display 设为 none 任何对该元素直接打用户交互操作都不可能生效。此外，读屏软件也不会读到元素的内容。这种方式产生的效果就像元素完全不存在;
Position:不会影响布局，能让元素保持可以操作;
Clip-path:clip-path 属性还没有在 IE 或者 Edge 下被完全支持。如果要在你的 clip-path 中使用外部的 SVG 文件，浏览器支持度还要低;</code></pre>
<h4 id="解释下CSS-sprites-以及你要如何在页面或网站中使用它"><a href="#解释下CSS-sprites-以及你要如何在页面或网站中使用它" class="headerlink" title="解释下CSS  sprites,以及你要如何在页面或网站中使用它"></a>解释下CSS  sprites,以及你要如何在页面或网站中使用它</h4><pre><code>CSS Sprites其实就是把网页中一些背景图片整合到一张图片文件中，再利用CSS的“background-image”，“background- repeat”，“background-position”的组合进行背景定位，
background-position可以用数字能精确的定位出背景图片的位置。这样可以减少很多图片请求的开销，因为请求耗时比较长；请求虽然可以并发，
但是也有限制，一般浏览器都是6个。对于未来而言，就不需要这样做了，因为有了(`http2`)。</code></pre>
<h4 id="讨论CSS-hacks-条件引用或者其他"><a href="#讨论CSS-hacks-条件引用或者其他" class="headerlink" title="讨论CSS hacks, 条件引用或者其他"></a>讨论CSS hacks, 条件引用或者其他</h4><ul>
<li>hacks<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">_width针对于ie6。*width,+width针对于ie6,7。</span><br><span class="line">color: red\9;/*IE8以及以下版本浏览器*/（但是测试可以兼容到ie10。</span><br><span class="line">*+html与*html是IE特有的标签, firefox暂不支持.而*+html又为IE7特有标签（但是测试*html兼容ie6-10。*+兼容ie7-10）。</span><br><span class="line">!important 在IE中会被忽视，ie6,7,8不识别，ie9+（包括ie9）是识别的。</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hexo clean <span class="comment"># 清除缓存</span></span><br><span class="line">hexo d -g <span class="comment"># 重新部署 Hexo</span></span><br><span class="line">git add -A</span><br><span class="line">git commit -m </span><br><span class="line">git push origin hexo <span class="comment"># 备份 Hexo 源文件</span></span><br></pre></td></tr></table></figure></li>
<li>条件引用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--[if !IE]&gt;&lt;!--&gt; 除IE外都可识别 &lt;!--&lt;![endif]--&gt;</span><br><span class="line">&lt;!--[if IE]&gt; 所有的IE可识别 &lt;![endif]--&gt;</span><br><span class="line">&lt;!--[if IE 6]&gt; 仅IE6可识别 &lt;![endif]--&gt;</span><br><span class="line">&lt;!--[if lt IE 6]&gt; IE6以及IE6以下版本可识别 &lt;![endif]--&gt;</span><br><span class="line">&lt;!--[if gte IE 6]&gt; IE6以及IE6以上版本可识别 &lt;![endif]--&gt;</span><br><span class="line">&lt;!--[if IE 7]&gt; 仅IE7可识别 &lt;![endif]--&gt;</span><br><span class="line">&lt;!--[if lt IE 7]&gt; IE7以及IE7以下版本可识别 &lt;![endif]--&gt;</span><br><span class="line">&lt;!--[if gte IE 7]&gt; IE7以及IE7以上版本可识别 &lt;![endif]--&gt;</span><br><span class="line">&lt;!--[if IE 8]&gt; 仅IE8可识别 &lt;![endif]--&gt;</span><br><span class="line">&lt;!--[if IE 9]&gt; 仅IE9可识别 &lt;![endif]--&gt;</span><br></pre></td></tr></table></figure>
<h4 id="css预编译"><a href="#css预编译" class="headerlink" title="css预编译"></a>css预编译</h4>就是预先编译处理CSS。它扩展了 CSS 语言，增加了变量、Mixin、函数等编程的特性，使 CSS 更易维护和扩展。<br>CSS预编译的工作原理是提供便捷的语法和特性供开发者编写源代码，随后经过专门的编译工具将源码转化为CSS语法。<br>它从这几个方面提升了CSS开发的效率：增强编程能力；增强可复用性；增强可维护性；更便于解决浏览器兼容性。</li>
</ul>
<h5 id="为什么要用css预编译"><a href="#为什么要用css预编译" class="headerlink" title="为什么要用css预编译"></a>为什么要用css预编译</h5><pre><code>优点：
    可以提供 CSS 缺失的样式层复用机制、减少冗余代码，提高样式代码的可维护性。大大提高了开发效率。
缺点：
    调试更麻烦；
    容易造成后代选择器的滥用</code></pre>
<h5 id="css的缺点"><a href="#css的缺点" class="headerlink" title="css的缺点"></a>css的缺点</h5><p>语法不够强大，比如无法嵌套书写，导致模块化开发中需要书写很多重复的选择器；<br>没有变量和合理的样式复用机制，使得逻辑上相关的属性值必须以字面量的形式重复输出，导致难以维护。</p>
<h5 id="主流CSS预编译器的介绍"><a href="#主流CSS预编译器的介绍" class="headerlink" title="主流CSS预编译器的介绍"></a>主流CSS预编译器的介绍</h5><p>1.Sass</p>
<p>2007年诞生，最早也是最成熟的CSS预处理器，拥有ruby社区的支持和compass这一最强大的CSS框架，目前受LESS影响，已经进化到了全面兼容CSS的SCSS。<br>其实现在的Sass已经有了两套语法规则：一个依旧是用缩进作为分隔符来区分代码块的；另一套规则和CSS一样采用了大括号（｛｝）作为分隔符。<br>后一种语法规则又名SCSS，在Sass3之后的版本都支持这种语法规则。</p>
<pre><code>优点：
    用户多，更容易找到会用scss的开发，更容易找到scss的学习资源；
    可编程能力比较强，支持函数，列表，对象，判断，循环等；
    相比less有更多的功能；
    Bootstrap/Foundation等使用scss；
    丰富的sass库：Compass/Bourbon；
缺点：
    安装node-sass会经常失败或者报错，需要使用cnpm或者手工安装</code></pre>
<p>Sass中文文档：<a target="_blank" rel="noopener" href="http://sass.bootcss.com/">http://sass.bootcss.com/</a></p>
<p>2.Less</p>
<p>2009年出现，受SASS的影响较大，但又使用CSS的语法，让大部分开发者和设计师更容易上手，在ruby社区之外支持者远超过SASS，其缺点是比起SASS来，可编程功能不够，不过优点是简单和兼容CSS，反过来也影响了SASS演变到了SCSS的时代，著名的Twitter Bootstrap就是采用LESS做底层语言的。</p>
<pre><code>优点：
    可以在浏览器中运行，实现主题定制功能；
缺点：
    编程能力弱，不直接支持对象，循环，判断等；
    @variable 变量命名和css的@import/media/keyframes等含义容易混淆；
    mixin/extend的语法比较奇怪；
    mixin的参数如果遇到多参数和列表参数值的时候容易混淆；</code></pre>
<p>Less中文文档：<a target="_blank" rel="noopener" href="https://less.bootcss.com/">https://less.bootcss.com/</a></p>
<p>3.Stylus</p>
<p>2010年产生，来自Node.js社区，主要用来给Node项目进行CSS预处理支持，在此社区之内有一定支持者，在广泛的意义上人气还完全不如SASS和LESS<br>Stylus被称为是一种革命性的新语言，提供一个高效、动态、和使用表达方式来生成CSS，以供浏览器使用。Stylus同时支持缩进和CSS常规样式书写规则。</p>
<pre><code>优点：
    来自NodeJS社区，所以和NodeJS走得很近，与JavaScript联系非常紧密。还有专门JavaScript API：
    http://learnboost.github.io/stylus/docs/js.html
    支持Ruby之类等等框架3.更多更强大的支持和功能
缺点：
    人气不高，教程较少</code></pre>
<p>Stylus官方文档：<a target="_blank" rel="noopener" href="http://stylus-lang.com/">http://stylus-lang.com/</a><br>Stylus 中文文档：<a target="_blank" rel="noopener" href="https://www.zhangxinxu.com/jq/stylus/">https://www.zhangxinxu.com/jq/stylus/</a></p>
<h5 id="Sass和Less的比较"><a href="#Sass和Less的比较" class="headerlink" title="Sass和Less的比较"></a>Sass和Less的比较</h5><p>不同之处</p>
<p>1、Less环境较Sass简单</p>
<pre><code>Cass的安装需要安装Ruby环境，Less基于JavaScript，是需要引入Less.js来处理代码输出css到浏览器，也可以在开发环节使用Less，然后编译成css文件，
直接放在项目中，有less.app、SimpleLess、CodeKit.app这样的工具，也有在线编辑地址。</code></pre>
<p>2、Less使用较Sass简单</p>
<pre><code>LESS 并没有裁剪 CSS 原有的特性，而是在现有 CSS 语法的基础上，为 CSS 加入程序式语言的特性。只要你了解 CSS 基础就可以很容易上手。</code></pre>
<p>3、从功能出发，Sass较Less略强大一些</p>
<pre><code>①sass有变量和作用域。
- $variable，like php；
- #｛$variable｝like ruby；
- 变量有全局和局部之分，并且有优先级。


②sass有函数的概念；
- @function和@return以及函数参数（还有不定参）可以让你像js开发那样封装你想要的逻辑。
-@mixin类似function但缺少像function的编程逻辑，更多的是提高css代码段的复用性和模块化，这个用的人也是最多的。
-ruby提供了非常丰富的内置原生api。

③进程控制：
-条件：@if @else；
-循环遍历：@for @each @while
-继承：@extend
-引用：@import

④数据结构：
-$list类型=数组；
-$map类型=object；
其余的也有string、number、function等类型</code></pre>
<p>4、Less与Sass处理机制不一样</p>
<pre><code>前者是通过客户端处理的，后者是通过服务端处理，相比较之下前者解析会比后者慢一点</code></pre>
<p>5、关于变量在Less和Sass中的唯一区别就是Less用@，Sass用$。</p>
<p>相同之处</p>
<p>Less和Sass在语法上有些共性，比如下面这些：</p>
<pre><code>1、混入(Mixins)——class中的class；
2、参数混入——可以传递参数的class，就像函数一样；
3、嵌套规则——Class中嵌套class，从而减少重复的代码；
4、运算——CSS中用上数学；
5、颜色功能——可以编辑颜色；
6、名字空间(namespace)——分组样式，从而可以被调用；
7、作用域——局部修改样式；
8、JavaScript 赋值——在CSS中使用JavaScript表达式赋值。</code></pre>
<h4 id="为什么选择使用Sass而不是Less？"><a href="#为什么选择使用Sass而不是Less？" class="headerlink" title="为什么选择使用Sass而不是Less？"></a>为什么选择使用Sass而不是Less？</h4><pre><code>1、Sass在市面上有一些成熟的框架，比如说Compass，而且有很多框架也在使用Sass，比如说Foundation。

2、就国外讨论的热度来说，Sass绝对优于LESS。
3、就学习教程来说，Sass的教程要优于LESS。在国内LESS集中的教程是LESS中文官网，而Sass的中文教程，慢慢在国内也较为普遍。

4、Sass也是成熟的CSS预处理器之一，而且有一个稳定，强大的团队在维护。

5、同时还有Scss对sass语法进行了改良，Sass 3就变成了Scss(sassy css)。与原来的语法兼容，只是用&#123;&#125;取代了原来的缩进。

6、bootstrap（Web框架）最新推出的版本4，使用的就是Sass。</code></pre>
<h3 id="二、html"><a href="#二、html" class="headerlink" title="二、html"></a>二、html</h3><h4 id="常用那几种浏览器测试？有哪些内核-Layout-Engine"><a href="#常用那几种浏览器测试？有哪些内核-Layout-Engine" class="headerlink" title="常用那几种浏览器测试？有哪些内核(Layout Engine)?"></a>常用那几种浏览器测试？有哪些内核(Layout Engine)?</h4><p>浏览器：IE，Chrome，FireFox，Safari，Opera。<br>　　 内核：Trident，Gecko，Presto，Webkit。</p>
<h4 id="HTML5-为什么只需要写-lt-DOCTYPE-html-gt-？"><a href="#HTML5-为什么只需要写-lt-DOCTYPE-html-gt-？" class="headerlink" title="HTML5 为什么只需要写&lt;!　DOCTYPE html&gt; ？"></a>HTML5 为什么只需要写&lt;!　DOCTYPE html&gt; ？</h4><p>　　HTML5不基于 SGML，因此不需要对DTD进行引用，但是需要doctype来规范浏览器的行为（让浏览器按照它们应该的方式来运行）。而HTML4.01基于SGML,所以需要对DTD进行引用，才能告知浏览器文档所使用的文档类型。</p>
<h4 id="页面导入样式时，使用link和-import有什么区别？"><a href="#页面导入样式时，使用link和-import有什么区别？" class="headerlink" title="页面导入样式时，使用link和@import有什么区别？"></a>页面导入样式时，使用link和@import有什么区别？</h4><pre><code>（1）本质的差别：link属于XHTML标签，除了加载CSS外，还能用于定义RSS, 定义rel连接属性等作用；而@import是CSS提供的，只能用于加载CSS;
（2）加载顺序的差别：页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载;所以在 @import加载CSS的时候，一开始会没有样式。
（3）兼容性的差别：import是CSS2.1 提出的，只在IE5以上才能被识别，而link是XHTML标签，无兼容问题。
（4）使用DOM文档对象模型控制样式的差别：当使用JavaScript控制DOM区改变样式的时候，只能使用link标签，而@import是不可以的。
（5）作用不同：link是属于XHTML，除了可以加载css,还可以定义RSS等其它事务，而@import是属于css范畴，只能加载css。
（6）权重不同：link方式的权重高于@import的权重值。
（7）标签不同：import在html使用的时候需要标签，而link在html使用的时候不需要标签。</code></pre>
<h4 id="在HTML当中引用CSS的三种使用方式有哪些？它们之间的区别是什么？"><a href="#在HTML当中引用CSS的三种使用方式有哪些？它们之间的区别是什么？" class="headerlink" title="在HTML当中引用CSS的三种使用方式有哪些？它们之间的区别是什么？"></a>在HTML当中引用CSS的三种使用方式有哪些？它们之间的区别是什么？</h4><pre><code>在HTML当中引用CSS的三种使用方式：
    1） 第一种是内联样式表，样式通过style属性内嵌在css的样式当中，写在标签当中。
    2） 第二种是内部样式表，通过style标签将CSS的样式写在style属性当中，链入内部的CSS文件。
    3） 第三种是外部样式表，通过link标签或者是在style中通过@import的方式引入外部的CSS样式文件。</code></pre>
<p>它们之间的区别：<br>    1） 优先级不同，内联样式表的优先级最高，而内部样式表和外部样式表的优先级与书写顺序有关，后书写的优先级高。<br>    2） 作用域不同，内联样式表的作用域最小，只能应用于当前的元素，内部样式表的作用域其次，只能应用于当前的HTML文件，最后是外部样式表的作用域最大，能够适用于所有链接的HTML文件。<br>    3）书写顺序不同，内联样式表写在标签当中，内部样式表写在style标签中来链入内部的CSS文件，外部样式表是通过link或者是@import的方式来链入外部的CSS文件。</p>
<h4 id="html5有哪些新特性？"><a href="#html5有哪些新特性？" class="headerlink" title="html5有哪些新特性？"></a>html5有哪些新特性？</h4><p>HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。</p>
<pre><code>(1)拖拽释放(Drag and drop) API
(2)视频和音频  用于媒介回放的 video 和 audio 元素;
(3)画布(Canvas) API
(4)地理(Geolocation) API
(5)本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失;
(6)sessionStorage 的数据在浏览器关闭后自动删除;
(7)语意化更好的内容标签，比如 （article、footer、header、nav、section、aside）;
(8)表单控件，calendar、date、time、email、url、search;
(9)新的技术webworker, websocket, Geolocation;</code></pre>
<p>IE8/IE7/IE6支持通过document.createElement方法产生的标签， 可以利用这一特性让这些浏览器支持HTML5新标签， 浏览器支持新标签后，还需要添加标签默认的样式</p>
<h4 id="简述一下你对HTML语义化的理解？"><a href="#简述一下你对HTML语义化的理解？" class="headerlink" title="简述一下你对HTML语义化的理解？"></a>简述一下你对HTML语义化的理解？</h4><pre><code>用正确的标签做正确的事情。
html语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析;
即使在没有样式CSS情况下也以一种文档格式显示，并且是容易阅读的;
搜索引擎的爬虫也依赖于HTML标记来确定上下文和各个关键字的权重，利于SEO;
使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。</code></pre>
<h4 id="如何实现浏览器内多个标签页之间的通信"><a href="#如何实现浏览器内多个标签页之间的通信" class="headerlink" title="如何实现浏览器内多个标签页之间的通信?"></a>如何实现浏览器内多个标签页之间的通信?</h4><p>调用localstorge、cookies等本地存储方式</p>
<h4 id="webSocket如何兼容低浏览器？"><a href="#webSocket如何兼容低浏览器？" class="headerlink" title="webSocket如何兼容低浏览器？"></a>webSocket如何兼容低浏览器？</h4><p>Adobe Flash Socket 、 ActiveX HTMLFile (IE) 、 基于 multipart 编码发送 XHR 、 基于长轮询的 XHR</p>
<h4 id="请写出一些前端性能优化的方式"><a href="#请写出一些前端性能优化的方式" class="headerlink" title="请写出一些前端性能优化的方式"></a>请写出一些前端性能优化的方式</h4><pre><code>1.减少dom操作
2.部署前，图片压缩，代码压缩
3.优化js代码结构，减少冗余代码
4.减少http请求，合理设置 HTTP缓存
5.使用内容分发cdn加速
6.静态资源缓存
7.图片延迟加载</code></pre>
<h4 id="iframe的优缺点？"><a href="#iframe的优缺点？" class="headerlink" title="iframe的优缺点？"></a>iframe的优缺点？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1.&lt;iframe&gt;优点：</span><br><span class="line">    解决加载缓慢的第三方内容如图标和广告等的加载问题</span><br><span class="line">    Security sandbox</span><br><span class="line">    并行加载脚本</span><br><span class="line">2.&lt;iframe&gt;的缺点：</span><br><span class="line">    *iframe会阻塞主页面的Onload事件；</span><br><span class="line">    *即时内容为空，加载也需要时间</span><br><span class="line">    *没有语意</span><br><span class="line">iframe会阻塞主页面的Onload事件；</span><br><span class="line">搜索引擎的检索程序无法解读这种页面，不利于SEO;</span><br><span class="line">iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。</span><br><span class="line">使用iframe之前需要考虑这两个缺点。如果需要使用iframe，最好是通过javascript动态给iframe添加src属性值，这样可以绕开以上两个问题。</span><br></pre></td></tr></table></figure>
<h4 id="网页布局有哪几种，有什么区别"><a href="#网页布局有哪几种，有什么区别" class="headerlink" title="网页布局有哪几种，有什么区别"></a>网页布局有哪几种，有什么区别</h4><pre><code>静态、自适应、流式、响应式四种网页布局
静态布局：意思就是不管浏览器尺寸具体是多少，网页布局就按照当时写代码的布局来布置；
自适应布局：就是说你看到的页面，里面元素的位置会变化而大小不会变化；
流式布局：你看到的页面，元素的大小会变化而位置不会变化——这就导致如果屏幕太大或者太小都会导致元素无法正常显示。
自适应布局：每个屏幕分辨率下面会有一个布局样式，同时位置会变而且大小也会变。</code></pre>
<h4 id="怎么让Chrome支持小于12px-的文字？"><a href="#怎么让Chrome支持小于12px-的文字？" class="headerlink" title="怎么让Chrome支持小于12px 的文字？"></a>怎么让Chrome支持小于12px 的文字？</h4><p>这个我们在做移动端的时候，设计师图片上的文字假如是10px，我们实现在网页上之后。往往设计师回来找我们，这个字体能小一些吗？我设计的是10px？为啥是12px?其实我们都知道，<br>谷歌Chrome最小字体是12px，不管你设置成8px还是10px，在浏览器中只会显示12px，那么如何解决这个坑爹的问题呢？</p>
<p>我们的做法是：</p>
<p>针对谷歌浏览器内核，加webkit前缀，用transform:scale()这个属性进行缩放！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;pspan&#123;font-size:10px;-webkit-transform:scale(0.8);display:block;&#125;&lt;&#x2F;style&gt;&lt;p&gt;&lt;span&gt;haorooms博客测试10px&lt;&#x2F;span&gt;&lt;&#x2F;p&gt;</span><br></pre></td></tr></table></figure>
<h4 id="Doctype作用-严格模式与混杂模式如何区分？它们有何意义"><a href="#Doctype作用-严格模式与混杂模式如何区分？它们有何意义" class="headerlink" title="Doctype作用? 严格模式与混杂模式如何区分？它们有何意义?"></a>Doctype作用? 严格模式与混杂模式如何区分？它们有何意义?</h4><p>（1）、&lt;!DOCTYPE&gt; 声明位于文档中的最前面，处于 <html> 标签之前。告知浏览器以何种模式来渲染文档。<br>（2）、严格模式的排版和 JS 运作模式是  以该浏览器支持的最高标准运行。<br>（3）、在混杂模式中，页面以宽松的向后兼容的方式显示。模拟老式浏览器的行为以防止站点无法工作。<br>（4）、DOCTYPE不存在或格式不正确会导致文档以混杂模式呈现。</p>
<h4 id="Doctype文档类型？"><a href="#Doctype文档类型？" class="headerlink" title="Doctype文档类型？"></a>Doctype文档类型？</h4><pre><code>该标签可声明三种 DTD 类型，分别表示严格版本、过渡版本以及基于框架的 HTML 文档。
HTML 4.01 规定了三种文档类型：Strict、Transitional 以及 Frameset。
XHTML 1.0 规定了三种 XML 文档类型：Strict、Transitional 以及 Frameset。
Standards （标准）模式（也就是严格呈现模式）用于呈现遵循最新标准的网页，而 Quirks
（包容）模式（也就是松散呈现模式或者兼容模式）用于呈现为传统浏览器而设计的网页。</code></pre>
<h4 id="HTML与XHTML——二者有什么区别"><a href="#HTML与XHTML——二者有什么区别" class="headerlink" title="HTML与XHTML——二者有什么区别"></a>HTML与XHTML——二者有什么区别</h4><pre><code>1.所有的标记都必须要有一个相应的结束标记
2.所有标签的元素和属性的名字都必须使用小写
3.所有的XML标记都必须合理嵌套
4.所有的属性必须用引号&quot;&quot;括起来
5.把所有&lt;和&amp;特殊符号用编码表示
6.给所有属性赋一个值
7.不要在注释内容中使“--”
8.图片必须有说明文字</code></pre>
<h4 id="常见兼容性问题？"><a href="#常见兼容性问题？" class="headerlink" title="常见兼容性问题？"></a>常见兼容性问题？</h4><ol>
<li><p>png24位的图片在iE6浏览器上出现背景，解决方案是做成PNG8.也可以引用一段脚本处理.</p>
</li>
<li><p>浏览器默认的margin和padding不同。解决方案是加一个全局的*{margin:0;padding:0;}来统一。</p>
</li>
<li><p>IE6双边距bug:块属性标签float后，又有横行的margin情况下，在ie6显示margin比设置的大。 </p>
</li>
<li><p>浮动ie产生的双倍距离（IE6双边距问题：在IE6下，如果对元素设置了浮动，同时又设置了margin-left或margin-right，margin值会加倍。）<br>#box{ float:left; width:10px; margin:0 0 0 100px;}<br>这种情况之下IE会产生20px的距离，解决方案是在float的标签样式控制中加入 ——_display:inline;将其转化为行内属性。(_这个符号只有ie6会识别)</p>
</li>
<li><p>渐进识别的方式，从总体中逐渐排除局部。<br>首先，巧妙的使用“\9”这一标记，将IE游览器从所有情况中分离出来。<br>接着，再次使用“+”将IE8和IE7、IE6分离开来，这样IE8已经独立识别。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">css</span><br><span class="line">  .bb&#123;</span><br><span class="line">      background-color:#f1ee18;&#x2F;*所有识别*&#x2F;</span><br><span class="line">      .background-color:#00deff\9; &#x2F;*IE6、7、8识别*&#x2F;</span><br><span class="line">      +background-color:#a200ff;&#x2F;*IE6、7识别*&#x2F;</span><br><span class="line">      _background-color:#1e0bd1;&#x2F;*IE6识别*&#x2F; </span><br><span class="line">  &#125; </span><br></pre></td></tr></table></figure></li>
<li><p>IE下,可以使用获取常规属性的方法来获取自定义属性,<br>也可以使用getAttribute()获取自定义属性;<br>Firefox下,只能使用getAttribute()获取自定义属性.<br>解决方法:统一通过getAttribute()获取自定义属性.</p>
</li>
<li><p>IE下,event对象有x,y属性,但是没有pageX,pageY属性;<br>Firefox下,event对象有pageX,pageY属性,但是没有x,y属性.<br>解决方法：（条件注释）缺点是在IE浏览器下可能会增加额外的HTTP请求数。</p>
</li>
<li><p>Chrome 中文界面下默认会将小于 12px 的文本强制按照 12px 显示,<br>可通过加入 CSS 属性 -webkit-text-size-adjust: none; 解决.</p>
</li>
<li><p>超链接访问过后hover样式就不出现了 被点击访问过的超链接样式不在具有hover和active了解决方法是改变CSS属性的排列顺序:<br>L-V-H-A :  a:link {} a:visited {} a:hover {} a:active {}</p>
</li>
<li><p>怪异模式问题：漏写DTD声明，Firefox仍然会按照标准模式来解析网页，但在IE中会触发怪异模式。为避免怪异模式给我们带来不必要的麻烦，最好养成书写DTD声明的好习惯。现在可以使用<a target="_blank" rel="noopener" href="http://www.w3.org/TR/html5/single-page.html">html5</a>推荐的写法：<code>&lt;doctype html&gt;</code></p>
</li>
<li><p>上下margin重合问题<br>ie和ff都存在，相邻的两个div的margin-left和margin-right不会重合，但是margin-top和margin-bottom却会发生重合。<br>解决方法，养成良好的代码编写习惯，同时采用margin-top或者同时采用margin-bottom。</p>
</li>
<li><p>ie6对png图片格式支持不好(引用一段脚本处理)</p>
</li>
</ol>
<h4 id="线程与进程的区别"><a href="#线程与进程的区别" class="headerlink" title="线程与进程的区别"></a>线程与进程的区别</h4><pre><code>一个程序至少有一个进程,一个进程至少有一个线程. 
线程的划分尺度小于进程，使得多线程程序的并发性高。 
另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。 
线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。 
从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。</code></pre>
<h4 id="如何对网站的文件和资源进行优化？"><a href="#如何对网站的文件和资源进行优化？" class="headerlink" title="如何对网站的文件和资源进行优化？"></a>如何对网站的文件和资源进行优化？</h4><p>期待的解决方案包括：<br>    1.文件合并<br>    2.文件最小化/文件压缩<br>    3.使用 CDN 托管<br>    4.缓存的使用（多个域名来提供缓存）</p>
<h4 id="请说出三种减少页面加载时间的方法。"><a href="#请说出三种减少页面加载时间的方法。" class="headerlink" title="请说出三种减少页面加载时间的方法。"></a>请说出三种减少页面加载时间的方法。</h4><pre><code>1.优化图片 
2.图像格式的选择（GIF：提供的颜色较少，可用在一些对颜色要求不高的地方） 
3.优化CSS（压缩合并css，如margin-top,margin-left...) 
4.网址后加斜杠（如www.campr.com/目录，会判断这个“目录是什么文件类型，或者是目录。） 
5.标明高度和宽度（如果浏览器没有找到这两个参数，它需要一边下载图片一边计算大小，如果图片很多，浏览器需要不断地调整页面。这不但影响速度，也影响浏览体验。 
当浏览器知道了高度和宽度参数后，即使图片暂时无法显示，页面上也会腾出图片的空位，然后继续加载后面的内容。从而加载时间快了，浏览体验也更好了。） 
6.减少http请求（合并文件，合并图片）。</code></pre>
<h4 id="什么是-FOUC（无样式内容闪烁）？你如何来避免-FOUC？"><a href="#什么是-FOUC（无样式内容闪烁）？你如何来避免-FOUC？" class="headerlink" title="什么是 FOUC（无样式内容闪烁）？你如何来避免 FOUC？"></a>什么是 FOUC（无样式内容闪烁）？你如何来避免 FOUC？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FOUC - Flash Of Unstyled Content 文档样式闪烁</span><br><span class="line"> &lt;style type&#x3D;&quot;text&#x2F;css&quot; media&#x3D;&quot;all&quot;&gt;@import &quot;..&#x2F;fouc.css&quot;;&lt;&#x2F;style&gt; </span><br><span class="line">而引用CSS文件的@import就是造成这个问题的罪魁祸首。IE会先加载整个HTML文档的DOM，然后再去导入外部的CSS文件，</span><br><span class="line">因此，在页面DOM加载完成到CSS导入完成中间会有一段时间页面上的内容是没有样式的，这段时间的长短跟网速，电脑速度都有关系。</span><br><span class="line">解决方法简单的出奇，只要在&lt;head&gt;之间加入一个&lt;link&gt;或者&lt;script&gt;元素就可以了。</span><br></pre></td></tr></table></figure>
<h4 id="在form表单中，get方式和post方式提交数据的区别是什么？如何判断在实际开发中的应用？"><a href="#在form表单中，get方式和post方式提交数据的区别是什么？如何判断在实际开发中的应用？" class="headerlink" title="在form表单中，get方式和post方式提交数据的区别是什么？如何判断在实际开发中的应用？"></a>在form表单中，get方式和post方式提交数据的区别是什么？如何判断在实际开发中的应用？</h4><pre><code>get方式和post方式提交数据的区别：
1） 大小不同，get方式传输的数据量较小，而post可以传输大量的数据。
2） 安全程度不同，get方式传输数据能够被别人轻易的看到数据内容，所以安全程度较低，而post则可以很好的隐藏。
3） 速度不同，post方式速度较慢，而get方式速度较快。
4） 在服务器上的作用不同，get是从服务器上获取数据，而post是向服务器上传送数据。</code></pre>
<p>在实际开发中的应用：<br>1）在重要数据进行传输数据的时候，用post的方式进行提交数据。<br>2）在做数据查询的时候，用get的方式进行提交数据。<br>3）在做增加、删除和修改数据的时候，用post的方式进行提交数据。</p>
<h4 id="在input表单控件中，value和placeholder的区别是什么？"><a href="#在input表单控件中，value和placeholder的区别是什么？" class="headerlink" title="在input表单控件中，value和placeholder的区别是什么？"></a>在input表单控件中，value和placeholder的区别是什么？</h4><pre><code>placeholder: 表示在输入框中显示的提示信息，用户点击之后，提示信息就会消失。
value: 叫做默认值，当用户想要在输入框中输入信息的时候，必须先手动的删除value的值 。</code></pre>
<h2 id="二、js-部分"><a href="#二、js-部分" class="headerlink" title="二、js 部分"></a>二、js 部分</h2><h3 id="js是什么语言"><a href="#js是什么语言" class="headerlink" title="js是什么语言"></a>js是什么语言</h3><p>js是一种运行在浏览器的脚本语言，这种语言主要的功能是可以制作出动态的页面的效果<br>我们可以通过js+css+html布局来形成我们现在可以访问展示的页面</p>
<p>js语言是弱语言类型， 因此我们在项目开发中当我们随意更改某个变量的数据类型后<br>有可能会导致其他引用这个变量的方法中报错等等。</p>
<h3 id="js-的基本数据类型有哪些，基本数据类型和复杂数据类型的区别"><a href="#js-的基本数据类型有哪些，基本数据类型和复杂数据类型的区别" class="headerlink" title="js 的基本数据类型有哪些，基本数据类型和复杂数据类型的区别"></a>js 的基本数据类型有哪些，基本数据类型和复杂数据类型的区别</h3><p>String、Number、Boolean、Null、undefined</p>
<p>Object为复杂数据类型</p>
<p>基本数据类型把数据名和值直接存储在栈当中</p>
<p>复杂数据类型在栈中存储数据名和一个堆的地址，在堆中存储属性和值，访问时先从栈中获取地址再到堆中取相应的值</p>
<h3 id="和-有什么区别"><a href="#和-有什么区别" class="headerlink" title="== 和 === 有什么区别"></a>== 和 === 有什么区别</h3><p>==用于一般比较 比较时可以转换数据类型 </p>
<p>===用于严格比较 比较时只要类型不匹配就返回false</p>
<h3 id="split-和-join-的区别"><a href="#split-和-join-的区别" class="headerlink" title="split () 和 join () 的区别"></a>split () 和 join () 的区别</h3><pre><code>split() 字符串转数组 如：var str = &quot;hello?word?welcome&quot;  console.log(str.split(“？”)) 返回值为 [&quot;hello&quot;, &quot;word&quot;, &quot;welcome&quot;]

join() 数组转字符串 如：var arr = new Array() arr[0] = &quot;hello&quot; arr[1] = &quot;world&quot; arr[3] = &quot;welcome&quot; arr.join(&quot;、&quot;)  返回值为 &quot;hello、world、welcome&quot;</code></pre>
<h3 id="call-、bind-、apply-区别"><a href="#call-、bind-、apply-区别" class="headerlink" title="call ()、bind ()、apply () 区别"></a>call ()、bind ()、apply () 区别</h3><pre><code>三者都是可以改变this的指向

bind() 返回对应函数便于稍后调用；call()、apply()则是立即调用

call() call(thisArg, case1, case2, case3,...) 第一个参数是对象 后面是字符串

apply() apply(thisArg, [case1, case2, case3,...]) 第一个参数是对象  后面是数组</code></pre>
<h3 id="数组有哪些操作方法"><a href="#数组有哪些操作方法" class="headerlink" title="数组有哪些操作方法"></a>数组有哪些操作方法</h3><pre><code>unshift()  把参数添加到数组开头
shift() 把数组的第一个元素删除
push() 向数组末尾添加一个或多个元素
pop() 把数组的最后一个元素删除 
concat() 连接两个或多个数组
join() 数组转成字符串
reverse() 数组倒叙
slice() 截取后返回新数组 [&#39;H&#39;,&#39;el&#39;,&#39;lo&#39;,&#39;wo&#39;,&#39;rld!&#39;].slice(1,3) 返回 [&quot;el&quot;, &quot;lo&quot;]
splice() 添加或删除数组中的元素，这种方法会改变原始数组
sort() 数组元素排序
filter() 筛选数组
Map()  循环数组的每一项</code></pre>
<h3 id="什么是闭包"><a href="#什么是闭包" class="headerlink" title="什么是闭包"></a>什么是闭包</h3><p>可以调用其它函数内部变量的函数<br>简单来说就是函数嵌套函数，内部函数引用来外部函数的变量，从而导致来垃圾回收机制没有生效，变量被保存来下来。<br>也就是所谓的内存泄漏，然后由于内存泄漏又会导致你项目逐渐变得卡顿等等问题。因此要避免内存泄漏。</p>
<p>优点：避免变量污染、加强了封装性，逻辑性比较强代码的可读性高；加载到内存中执行效率高；</p>
<p>缺点：在内存中，造成了内存浪费，如果滥用闭包是灾难性的；</p>
<h3 id="null-和-undefined-的区别"><a href="#null-和-undefined-的区别" class="headerlink" title="null 和 undefined 的区别"></a>null 和 undefined 的区别</h3><p>null表示没有对象，该处不该有值，转为数值时为0</p>
<p>undefined表示缺少值，该处应该有值，但是未定义，转为数值时为NaN</p>
<h3 id="什么是变量提升"><a href="#什么是变量提升" class="headerlink" title="什么是变量提升"></a>什么是变量提升</h3><p>变量提升是js的默认行为，变量提升会将所有变量声明移动到当前作用域的顶部，并可以在声明之前使用该变量，初始化不会被提升，提升的仅作用于变量的声明</p>
<h3 id="什么是事件委托"><a href="#什么是事件委托" class="headerlink" title="什么是事件委托"></a>什么是事件委托</h3><p>利用事件冒泡的原理，把原本需要绑定的事件委托给父元素，让父元素负责事件监听</p>
<h3 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h3><p>浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。</p>
<pre><code>通过ES6新特性Object.assign()与扩展运算符来达到浅拷贝的目的</code></pre>
<p>深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象</p>
<pre><code>通过利用JSON.parse(JSON.stringify(Object))来达到深拷贝的目的
但是JSON深拷贝的缺点是undefined和function还有symbol类型是无法进行深拷贝的
如有需要可以自己手动封装函数来达到目的</code></pre>
<h3 id="async-与-defer-区别"><a href="#async-与-defer-区别" class="headerlink" title="async 与 defer 区别"></a>async 与 defer 区别</h3><p>异步(async) 脚本将在其加载完成后立即执行，而 延迟(defer) 脚本将等待 HTML 解析完成后，并按加载顺序执行。</p>
<h3 id="cookies，sessionStorage-和-localStorage-有什么区别？"><a href="#cookies，sessionStorage-和-localStorage-有什么区别？" class="headerlink" title="cookies，sessionStorage 和 localStorage 有什么区别？"></a>cookies，sessionStorage 和 localStorage 有什么区别？</h3><pre><code>共同点：都是保存在浏览器端、且同源的
不同点：
    1.cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递。
    cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下
    sessionStorage和localStorage不会自动把数据发送给服务器，仅在本地保存。
    2.存储大小限制也不同，cookie数据不能超过4K，sessionStorage和localStorage可以达到5M或更大
    3.cookie：只在设置的cookie过期时间之前有效，即使窗口关闭或浏览器关闭
    sessionStorage：仅在当前浏览器窗口关闭之前有效；数据在当前浏览器窗口关闭后自动删除。
    localStorage：始终有效，窗口或浏览器关闭也一直保存，本地存储，因此用作存储持久数据；浏览器关闭后数据不丢失除非主动删除数据
    4.作用域不同
    cookie: 也是在所有同源窗口中都是共享的.也就是说只要浏览器不关闭，数据仍然存在
    sessionStorage：不在不同的浏览器窗口中共享，即使是同一个页面；
    localstorage：在所有同源窗口中都是共享的；也就是说只要浏览器不关闭，数据仍然存在</code></pre>
<h3 id="数组去重有哪些方法"><a href="#数组去重有哪些方法" class="headerlink" title="数组去重有哪些方法"></a>数组去重有哪些方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new Set()  如：var arr &#x3D; [1,2,3,9,6,3,1,2,6] new set(arr)</span><br></pre></td></tr></table></figure>
<h4 id="1-利用冒泡-for-循环嵌套，然后-splice-去重-如："><a href="#1-利用冒泡-for-循环嵌套，然后-splice-去重-如：" class="headerlink" title="1.利用冒泡 for 循环嵌套，然后 splice () 去重 如："></a>1.利用冒泡 for 循环嵌套，然后 splice () 去重 如：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function unique(arr)&#123;            </span><br><span class="line">        for(var i&#x3D;0; i&lt;arr.length; i++)&#123;</span><br><span class="line">            for(var j&#x3D;i+1; j&lt;arr.length; j++)&#123;</span><br><span class="line">                if(arr[i]&#x3D;&#x3D;arr[j])&#123;         &#x2F;&#x2F;第一个等同于第二个，splice方法删除第二个</span><br><span class="line">                    arr.splice(j,1);</span><br><span class="line">                    j--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">return arr;</span><br><span class="line">&#125;</span><br><span class="line">var arr &#x3D; [1,2,3,9,6,3,1,2,6]</span><br><span class="line">console.log(unique(arr))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="2-indexOf-去重-如："><a href="#2-indexOf-去重-如：" class="headerlink" title="2.indexOf () 去重 如："></a>2.indexOf () 去重 如：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function unique(arr) &#123;</span><br><span class="line">    if (!Array.isArray(arr)) &#123;</span><br><span class="line">        console.log(&#39;type error!&#39;)</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    var array &#x3D; [];</span><br><span class="line">    for (var i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">        if (array .indexOf(arr[i]) &#x3D;&#x3D;&#x3D; -1) &#123;</span><br><span class="line">            array .push(arr[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return array;</span><br><span class="line">&#125;</span><br><span class="line">var arr &#x3D; [1,2,3,9,6,3,1,2,6]</span><br><span class="line">    console.log(unique(arr))</span><br></pre></td></tr></table></figure>
<h4 id="3-sort-去重-如："><a href="#3-sort-去重-如：" class="headerlink" title="3.sort () 去重 如："></a>3.sort () 去重 如：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function unique(arr) &#123; </span><br><span class="line">    if (!Array.isArray(arr)) &#123;</span><br><span class="line">        console.log(&#39;type error!&#39;) return; </span><br><span class="line">    &#125; </span><br><span class="line">    arr &#x3D; arr.sort() </span><br><span class="line">    var arrry&#x3D; [arr[0]]; </span><br><span class="line">    for (var i &#x3D; 1; i &lt; arr.length; i++) &#123;</span><br><span class="line">        if (arr[i] !&#x3D;&#x3D; arr[i-1]) &#123;</span><br><span class="line">            arrry.push(arr[i]);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    return arrry;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var arr &#x3D; [1,2,3,9,6,3,1,2,6]</span><br><span class="line"></span><br><span class="line">console.log(unique(arr))</span><br></pre></td></tr></table></figure>
<h4 id="4-filter-去重-如"><a href="#4-filter-去重-如" class="headerlink" title="4.filter () 去重 如:"></a>4.filter () 去重 如:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function unique(arr) &#123; </span><br><span class="line">    return arr.filter(function(item, index, arr) &#123; </span><br><span class="line">        return arr.indexOf(item, 0) &#x3D;&#x3D;&#x3D; index; </span><br><span class="line">    &#125;); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var arr &#x3D; [1,2,3,9,6,3,1,2,6]</span><br><span class="line"></span><br><span class="line">console.log(unique(arr))</span><br></pre></td></tr></table></figure>
<h3 id="GET-和-POST-有什么区别"><a href="#GET-和-POST-有什么区别" class="headerlink" title="GET 和 POST 有什么区别"></a>GET 和 POST 有什么区别</h3><pre><code>1.使用Get请求时,参数在URL中显示，安全性比较低,而post请求在send（）方法中传递参数,使用Post方式,则不会显示出来。
2.使用Get请求发送数据量小,Post请求发送数据量大。
3.get请求可以被缓存,post不可以，不建议被缓存，每次调用都会对服务器资源造成影响。
4.post请求必须设置Content-Type值为application/x-form-www-urlencoded。
5.发送请求时,因为get请求的参数都在url里,所以send函数发送的参数为null,而post请求在使用send方法时,却需赋予其参数。</code></pre>
<h3 id="跨域有几种解决方案"><a href="#跨域有几种解决方案" class="headerlink" title="跨域有几种解决方案"></a>跨域有几种解决方案</h3><p>因为浏览器出于安全考虑，有同源策略。也就是说，如果协议、域名或者端口有一个不同就是跨域，Ajax 请求会失败。<br>为来防止CSRF攻击</p>
<ol>
<li><p>JSONP </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">JSONP 的原理很简单，就是利用 &lt;script&gt; 标签没有跨域限制的漏洞。</span><br><span class="line">通过 &lt;script&gt; 标签指向一个需要访问的地址并提供一个回调函数来接收数据当需要通讯时。</span><br><span class="line">&lt;script src&#x3D;&quot;http:&#x2F;&#x2F;domain&#x2F;api?param1&#x3D;a&amp;param2&#x3D;b&amp;callback&#x3D;jsonp&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    function jsonp(data) &#123;</span><br><span class="line">    console.log(data)</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">JSONP 使用简单且兼容性不错，但是只限于 get 请求。</span><br></pre></td></tr></table></figure></li>
<li><p>CORS<br> CORS 需要浏览器和后端同时支持。IE 8 和 9 需要通过 XDomainRequest 来实现。</p>
</li>
<li><p>document.domain<br> 该方式只能用于二级域名相同的情况下，比如 a.test.com 和 b.test.com 适用于该方式。<br> 只需要给页面添加 document.domain = ‘test.com’ 表示二级域名都相同就可以实现跨域</p>
</li>
<li><p>webpack配置proxyTable设置开发环境跨域</p>
</li>
<li><p>nginx代理跨域</p>
</li>
<li><p>iframe跨域</p>
</li>
<li><p>postMessage<br> 这种方式通常用于获取嵌入页面中的第三方页面数据。一个页面发送消息，另一个页面判断来源并接收消息</p>
</li>
</ol>
<h3 id="typeof-和-instanceof-有什么区别"><a href="#typeof-和-instanceof-有什么区别" class="headerlink" title="typeof 和 instanceof 有什么区别"></a>typeof 和 instanceof 有什么区别</h3><pre><code>typeof 判断一个数据是什么数据类型；一般只能返回如下几个结果：&quot;number&quot;、&quot;string&quot;、&quot;boolean&quot;、&quot;object&quot;、&quot;function&quot; 和 &quot;undefined&quot;。
instanceof 判断一个对象是否在另一个对象的原型链上</code></pre>
<h2 id="三、vue-部分"><a href="#三、vue-部分" class="headerlink" title="三、vue 部分"></a>三、vue 部分</h2><h3 id="vue-的生命周期以及页面初次加载会触发哪些钩子"><a href="#vue-的生命周期以及页面初次加载会触发哪些钩子" class="headerlink" title="vue 的生命周期以及页面初次加载会触发哪些钩子"></a>vue 的生命周期以及页面初次加载会触发哪些钩子</h3><p>beforeCreate<br>created<br>beforeMount<br>mounted<br>beforeUpdate<br>updated<br>beforeDestroy<br>destroyed<br>第一次会触发前四个钩子</p>
<h3 id="v-if-和-v-for-哪一个优先级高"><a href="#v-if-和-v-for-哪一个优先级高" class="headerlink" title="v-if 和 v-for 哪一个优先级高"></a>v-if 和 v-for 哪一个优先级高</h3><p>v-for优先级高</p>
<h3 id="v-if-和-v-show-有什么异同"><a href="#v-if-和-v-show-有什么异同" class="headerlink" title="v-if 和 v-show 有什么异同"></a>v-if 和 v-show 有什么异同</h3><p>两者都可以控制元素的显示和隐藏</p>
<pre><code>v-if 是动态的向DOM树内添加或者删除DOM元素，若初始值为false，就不会编译了。而且v-if不停的销毁和创建比较消耗性能。

v-show 是通过控制css中的display设置为none，控制隐藏，只会编译一次</code></pre>
<h3 id="vue-中-data-为什么必须是一个函数"><a href="#vue-中-data-为什么必须是一个函数" class="headerlink" title="vue 中 data 为什么必须是一个函数"></a>vue 中 data 为什么必须是一个函数</h3><pre><code>防止组件在重复使用时，数据互相干扰，使用函数将产生新作用域，所以同一个组件在不同位置被使用时，数据不会被影响到，如果是一个对象，
作用域没有隔离，子组件的data属性值会互相影响，因为所有的实例会共享引用同一个数据对象</code></pre>
<h3 id="v-for-里面-key-的作用"><a href="#v-for-里面-key-的作用" class="headerlink" title="v-for 里面 key 的作用"></a>v-for 里面 key 的作用</h3><p>key的作用是为了在diff算法执行时更快的找到对应的节点，提高diff速度，具有唯一性</p>
<h3 id="传值方式有哪些"><a href="#传值方式有哪些" class="headerlink" title="传值方式有哪些"></a>传值方式有哪些</h3><pre><code>父传子 在子元素中用 props 接收
子传父 在子元素中用 $emit 传值
同级传值 使用路由query/params传参 如 this.$router.push(&#123;path: &#39;/&#39;, query: &#123;参数名: &#39;参数值&#39;&#125;)  使用this.$route.query.参数名 接收
本地存储传值</code></pre>
<h3 id="初始化页面闪动问题"><a href="#初始化页面闪动问题" class="headerlink" title="初始化页面闪动问题"></a>初始化页面闪动问题</h3><p>在css里加上[v-cloak] {display: none;}<br>如果没有彻底解决问题，则在根元素加上 style=“display: none;” :style=”{display: ‘block’}”</p>
<h3 id="route和-router-的区别"><a href="#route和-router-的区别" class="headerlink" title="route和 router 的区别"></a>route和 router 的区别</h3><pre><code>$router是VueRouter的实例，在script标签中想要导航到不同的URL,使用$router.push方法。返回上一个历史history用$router.to(-1)
$route为当前router跳转对象。里面可以获取当前路由的name,path,query,parmas等。</code></pre>
<h3 id="vuex-有哪几种状态"><a href="#vuex-有哪几种状态" class="headerlink" title="vuex 有哪几种状态"></a>vuex 有哪几种状态</h3><p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态<br>并以相应的规则保证状态以一种可预测的方式发生变化。</p>
<pre><code>state 基本数据(数据源存放地)

Getters 过滤/计数。store 的计算属性 返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。

mutations 更改 Vuex 的 store 中的状态的唯一方法是提交 mutation 必须是同步函数

Actions 类似于 mutation 提交的是 mutation，而不是直接变更状态。 可以包含任意异步操作。

Modules 将 store 分割成模块（module）。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割</code></pre>
<h3 id="vue-router-有几种模式"><a href="#vue-router-有几种模式" class="headerlink" title="vue-router 有几种模式"></a>vue-router 有几种模式</h3><pre><code>hash模式 地址栏URL中的#符号，不会被包含在HTTP请求中，对后端完全没有影响，因此改变hash不会重新加载页面。

history模式 利用了HTML5 History Interface 中新增的pushState() 和replaceState() 方法，这两个方法应用于浏览器的历史记录站，
在当前已有的back、forward、go 的基础之上，它们提供了对历史记录进行修改的功能。
只是当它们执行修改是，虽然改变了当前的URL，但你浏览器不会立即向后端发送请求。history模式，会出现404 的情况，需要后台配置。</code></pre>
<h3 id="vue-实现数据双向绑定的原理"><a href="#vue-实现数据双向绑定的原理" class="headerlink" title="vue 实现数据双向绑定的原理"></a>vue 实现数据双向绑定的原理</h3><p>采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty（）来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应监听回调。<br>即数据和视图同步，数据发生变化，视图跟着变化，视图变化，数据也随之发生改变</p>
<h3 id="路由跳转的原理以及方式"><a href="#路由跳转的原理以及方式" class="headerlink" title="路由跳转的原理以及方式"></a>路由跳转的原理以及方式</h3><pre><code>路由就是根据不同的url地址展示不同的内容或页面
静态路由是在路由器中设置的固定的路由表。
动态路由是网络中的路由器之间相互通信，传递路由信息，利用收到的路由信息更新路由器表的过程。

this.$router.push(&#123;name:&#39;master&#39;,params:&#123;id:&#39;参数&#39;&#125;&#125;);
//name和params搭配，刷新的话，参数会消失
this.$router.push(&#123;path:&#39;/master&#39;,query:&#123;id:&#39;参数&#39;&#125;&#125;);
//path和query搭配，刷新页面的话，url中的参数不会丢失,query中的参数成了url中的一部分
this.$router.push()
跳转到不同的url，但这个方法回向history栈添加一个记录，点击后退会返回到上一个页面。
this.$router.replace()
描述：同样是跳转到指定的url，但是这个方法不会向history里面添加新的记录，点击返回，会跳转到上上一个页面。上一个记录是不存在的。
this.$router.go(n)
相对于当前页面向前或向后跳转多少个页面,类似 window.history.go(n)。n可为正数可为负数。正数返回上一个页面</code></pre>
<h2 id="四、其它"><a href="#四、其它" class="headerlink" title="四、其它"></a>四、其它</h2><h3 id="什么是-MVC-和-MVVM-和-MVP"><a href="#什么是-MVC-和-MVVM-和-MVP" class="headerlink" title="什么是 MVC 和 MVVM 和 MVP"></a>什么是 MVC 和 MVVM 和 MVP</h3><p>MVC模式：Controller负责将Model的数据用View显示出来</p>
<p>M：Model（数据模型），用于存放数据<br>V：View（视图），也就是用户界面<br>C：Controller是Model和View的协调者</p>
<p>MVVM模式：VM双向绑定，在 MVVM 框架中，View(视图) 和 Model(数据) 是不可以直接通讯的</p>
<p>M：Movel（数据模型）<br>V：View<br>VM：ViewModel 是一个同步View 和 Model的对象</p>
<p>MVP模式: View不直接与Model交互，而是通过与Presenter交互来与Model间接交互。</p>
<p>M——数据层(model)<br>V——视图层(view)<br>P——发布层(presenter)</p>
<h3 id="优雅降级和渐进增强"><a href="#优雅降级和渐进增强" class="headerlink" title="优雅降级和渐进增强"></a>优雅降级和渐进增强</h3><pre><code>渐进增强 progressive enhancement：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。

优雅降级 graceful degradation：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。

区别：优雅降级是从复杂的现状开始，并试图减少用户体验的供给，而渐进增强则是从一个非常基础的，能够起作用的版本开始，并不断扩充，以适应未来环境的需要。降级（功能衰减）意味着往回看；
而渐进增强则意味着朝前看，同时保证其根基处于安全地带。</code></pre>
<h3 id="浏览器页面有哪三层构成，分别是什么，作用是什么？"><a href="#浏览器页面有哪三层构成，分别是什么，作用是什么？" class="headerlink" title="浏览器页面有哪三层构成，分别是什么，作用是什么？"></a>浏览器页面有哪三层构成，分别是什么，作用是什么？</h3><p>构成：结构层、表示层、行为层</p>
<p>分别是：HTML、CSS、JavaScript</p>
<pre><code>作用：HTML实现页面结构，CSS完成页面的表现与风格，JavaScript实现一些客户端的功能与业务。</code></pre>
<h3 id="页面重构怎么操作？"><a href="#页面重构怎么操作？" class="headerlink" title="页面重构怎么操作？"></a>页面重构怎么操作？</h3><p>页面重构是指：在不改变外部行为的前提下，简化结构、添加可读性，而在网站前端保持一致的行为。也就是说在不改变UI的情况下，对网站进行优化，在扩展的同时保持一致的UI。</p>
<p>编写css、让页面结构更合理化，提升用户体验，实现良好的页面效果和提升性能。</p>
<h3 id="前端性能优化"><a href="#前端性能优化" class="headerlink" title="前端性能优化"></a>前端性能优化</h3><pre><code>避免使用css表达式，避免使用高级选择器，通配选择器。

缓存Ajax，使用CDN，使用外部js和css文件以便缓存，添加Expires头，服务端配置Etag，减少DNS查找等

css放在顶部，js放在底部

减少@import导入css（同步操作）

合并样式和脚本

使用css图片精灵，图片懒加载

减少http请求

初始首屏之外的图片资源按需加载，静态资源延迟加载。

压缩文件，开启GZIP，

少用全局变量，合理使用闭包

用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能

避免图片和iFrame等的空Src。空Src会重新加载当前页面，影响速度和效率</code></pre>
<h3 id="http-请求过程"><a href="#http-请求过程" class="headerlink" title="http 请求过程"></a>http 请求过程</h3><p>HTTP是超文本传输协议，它是TCP/IP协议的一个应用层协议，用于定义WEB浏览器与WEB服务器之间交换数据的过程以及通迅的格式</p>
<pre><code>域名解析
发起TCP的3次握手
建立TCP连接后发起http请求
服务器端响应http请求，浏览器得到html代码
浏览器解析html代码，并请求html代码中的资源
断开tcp连接，4次挥手
浏览器对页面进行渲染呈现给用户</code></pre>
<h3 id="HTTP-常见状态码"><a href="#HTTP-常见状态码" class="headerlink" title="HTTP 常见状态码"></a>HTTP 常见状态码</h3><pre><code>200 OK 客户端请求成功。
301 Moved Permanently 请求永久重定向。
302 Moved Temporarily 请求临时重定向。
304 Not Modified 文件未修改，可以直接使用缓存的文件。
400 Bad Request 由于客户端请求有语法错误，不能被服务器所理解。
401 Unauthorized 请求未经授权，无法访问。
403 Forbidden 服务器收到请求，但是拒绝提供服务。服务器通常会在响应正文中给出不提供服务的原因。
404 Not Found 请求的资源不存在，比如输入了错误的URL。
500 Internal Server Error 服务器发生不可预期的错误，导致无法完成客户端的请求。
503 Service Unavailable 服务器当前不能够处理客户端的请求，在一段时间之后，服务器可能会恢复正常。</code></pre>
<h3 id="一个完整的-url-包括哪几部分"><a href="#一个完整的-url-包括哪几部分" class="headerlink" title="一个完整的 url 包括哪几部分"></a>一个完整的 url 包括哪几部分</h3><pre><code>协议部分、域名部分、端口部分、虚拟目录部分、文件名部分、参数部分、锚部分</code></pre>
<h3 id="webpack配置入口出口"><a href="#webpack配置入口出口" class="headerlink" title="webpack配置入口出口"></a>webpack配置入口出口</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">module.exports&#x3D;&#123;</span><br><span class="line">    &#x2F;&#x2F;入口文件的配置项</span><br><span class="line">    entry:&#123;&#125;,</span><br><span class="line">    &#x2F;&#x2F;出口文件的配置项</span><br><span class="line">    output:&#123;&#125;,</span><br><span class="line">    &#x2F;&#x2F;模块：例如解读CSS,图片如何转换，压缩</span><br><span class="line">    module:&#123;&#125;,</span><br><span class="line">    &#x2F;&#x2F;插件，用于生产模版和各项功能</span><br><span class="line">    plugins:[],</span><br><span class="line">    &#x2F;&#x2F;配置webpack开发服务功能</span><br><span class="line">    devServer:&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="webpack3和webpack4区别"><a href="#webpack3和webpack4区别" class="headerlink" title="webpack3和webpack4区别"></a>webpack3和webpack4区别</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">1.mode</span><br><span class="line"> </span><br><span class="line">webpack增加了一个mode配置，只有两种值development | production。对不同的环境他会启用不同的配置。</span><br><span class="line"> </span><br><span class="line">2.CommonsChunkPlugin</span><br><span class="line"> </span><br><span class="line">CommonChunksPlugin已经从webpack4中移除。</span><br><span class="line">可使用optimization.splitChunks进行模块划分（提取公用代码）。</span><br><span class="line">但是需要注意一个问题，默认配置只会对异步请求的模块进行提取拆分，如果要对entry进行拆分</span><br><span class="line">需要设置optimization.splitChunks.chunks &#x3D; &#39;all&#39;。</span><br><span class="line"> </span><br><span class="line">3.webpack4使用MiniCssExtractPlugin取代ExtractTextWebpackPlugin。</span><br><span class="line"> </span><br><span class="line">4.代码分割。</span><br><span class="line"> </span><br><span class="line">使用动态import，而不是用system.import或者require.ensure</span><br><span class="line"> </span><br><span class="line">5.vue-loader。</span><br><span class="line"> </span><br><span class="line">使用vue-loader插件为.vue文件中的各部分使用相对应的loader，比如css-loader等</span><br><span class="line"> </span><br><span class="line">6.UglifyJsPlugin</span><br><span class="line"> </span><br><span class="line">现在也不需要使用这个plugin了，只需要使用optimization.minimize为true就行，production mode下面自动为true</span><br><span class="line"> </span><br><span class="line">optimization.minimizer可以配置你自己的压缩程序</span><br></pre></td></tr></table></figure>
<h3 id="es6新特性"><a href="#es6新特性" class="headerlink" title="es6新特性"></a>es6新特性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">1.ES6引入来严格模式</span><br><span class="line">    变量必须声明后在使用</span><br><span class="line">    函数的参数不能有同名属性, 否则报错</span><br><span class="line">    不能使用with语句 (说实话我基本没用过)</span><br><span class="line">    不能对只读属性赋值, 否则报错</span><br><span class="line">    不能使用前缀0表示八进制数,否则报错 (说实话我基本没用过)</span><br><span class="line">    不能删除不可删除的数据, 否则报错</span><br><span class="line">    不能删除变量delete prop, 会报错, 只能删除属性delete global[prop]</span><br><span class="line">    eval不会在它的外层作用域引入变量</span><br><span class="line">    eval和arguments不能被重新赋值</span><br><span class="line">    arguments不会自动反映函数参数的变化</span><br><span class="line">    不能使用arguments.caller (说实话我基本没用过)</span><br><span class="line">    不能使用arguments.callee (说实话我基本没用过)</span><br><span class="line">    禁止this指向全局对象</span><br><span class="line">    不能使用fn.caller和fn.arguments获取函数调用的堆栈 (说实话我基本没用过)</span><br><span class="line">    增加了保留字（比如protected、static和interface）</span><br><span class="line"> </span><br><span class="line">2.关于let和const新增的变量声明</span><br><span class="line">    1.let 声明的变量不进行变量的提升</span><br><span class="line">    2.let 声明的变量不可以重复声明；</span><br><span class="line">    3.let 声明的变量只在当前的作用域下生效</span><br><span class="line">    4.let 会让当前for循环形成一个块级作用域；每循环一次，会 形成一个小的子作用域，子作用域存储了每次循环的i的值；</span><br><span class="line">    5.const : 定义常量；常量不可以修改</span><br><span class="line"> </span><br><span class="line">3.数组对象的解构赋值</span><br><span class="line">    1.解构的值一定是可遍历的；</span><br><span class="line">    2.如果解构不成功，存储值是undefined；</span><br><span class="line">    3.对象的解构按照属性名进行解构，跟顺序无关；如果key有默认值，那么后面的解构会将默认值覆盖；</span><br><span class="line"></span><br><span class="line">    const Web &#x3D; [&#39;html&#39;, &#39;css&#39;, &#39;javascript&#39;]</span><br><span class="line">    let [tool1, tool2, tool3] &#x3D; Web</span><br><span class="line"></span><br><span class="line">    const liMing &#x3D; &#123;</span><br><span class="line">        name: &#39;liMing&#39;,</span><br><span class="line">        age: &#39;22&#39;,</span><br><span class="line">        tell: function()&#123;</span><br><span class="line">            console.log(&#96;I am liMing&#96;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    let &#123;name, age, tell&#125; &#x3D; liMing</span><br><span class="line"></span><br><span class="line">4.模板字符串</span><br><span class="line">    &#96; &#96;(反引号)内容中可以直接出现换行符，’ &#39;和&quot; &quot;中则不可以，出现会报错</span><br><span class="line">5.箭头函数</span><br><span class="line">    箭头函数内的this指向上层对象；始终指向函数声明时所在作用域下的this的值，无法被call改变</span><br><span class="line">    普通函数内的this指向调用其函数的对象</span><br><span class="line">6.字符串的扩展</span><br><span class="line">    includes()：返回布尔值，A.includes(B,index)，判断A是否包含B。</span><br><span class="line">    startsWith()：返回布尔值，表示是否以xxx开头。</span><br><span class="line">    endsWith()：返回布尔值，表示是否以xxx开头结尾。</span><br><span class="line">7.数值的扩展</span><br><span class="line">    Number.isFinite()用来检查一个数值是否为有限的（finite）。</span><br><span class="line">    Number.isNaN()用来检查一个值是否为NaN。</span><br><span class="line">8.函数的扩展</span><br><span class="line">    允许给函数参数指定默认值</span><br><span class="line">9.扩展运算符</span><br><span class="line">    const arr &#x3D; [&#39;小明&#39;,&#39;小芳&#39;,&#39;小红&#39;]</span><br><span class="line">    [...arr]</span><br><span class="line"></span><br><span class="line">10.新增symbol数据类型</span><br><span class="line">    ES6引入了一种新的原始数据类型Symbol，表示独一无二的值。它是JavaScript语言的第7种数据类型，是一个类似字符串的数据类型</span><br><span class="line">    特点：</span><br><span class="line">    Symbol的值是唯一的，用来解决命名冲突的问题</span><br><span class="line">    Symbol值不能与其他数据进行运算，也不能与自己进行运算，譬如+、-、*、&#x2F;、比较运算</span><br><span class="line">    Symbol定义的对象属性不能使用for…in遍历，但是可以使用Reflect.ownKeys来获取对象的所有键名</span><br><span class="line">    使用场景：</span><br><span class="line">    给对象添加属性和方法</span><br><span class="line"> </span><br><span class="line">11.Set 和 Map 数据结构</span><br><span class="line">    ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。Set 本身是一个构造函数，用来生成 Set 数据结构。</span><br><span class="line">    let set &#x3D; new Set();</span><br><span class="line">    set.add(1);	&#x2F;&#x2F; [1]</span><br><span class="line">    let set2 &#x3D; new Set([1,2,3,4,5])	&#x2F;&#x2F; [1,2,3,4,5]</span><br><span class="line">    </span><br><span class="line">    Map它类似于对象，也是键值对的集合，不同在于Object强制规定key值只能是字符串。而Map对象的key可以是任意对象。</span><br><span class="line">12.Proxy</span><br><span class="line">    Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问</span><br><span class="line">    都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。</span><br><span class="line">    Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。</span><br><span class="line">    Vue3.0使用了proxy</span><br><span class="line">13.Promise</span><br><span class="line">    Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。</span><br><span class="line">    特点是：</span><br><span class="line">        对象的状态不受外界影响。</span><br><span class="line">        一旦状态改变，就不会再变，任何时候都可以得到这个结果。</span><br><span class="line">14.async 函数</span><br><span class="line">    async函数对 Generator 函数的区别：</span><br><span class="line">    （1）内置执行器。</span><br><span class="line">    Generator 函数的执行必须靠执行器，而async函数自带执行器。也就是说，async函数的执行，与普通函数一模一样，只要一行。</span><br><span class="line">    （2）更好的语义。</span><br><span class="line">    async和await，比起星号和yield，语义更清楚了。async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果。</span><br><span class="line">    （3）正常情况下，await命令后面是一个 Promise 对象。如果不是，会被转成一个立即resolve的 Promise 对象。</span><br><span class="line">    （4）返回值是 Promise。</span><br><span class="line">    async函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用then方法指定下一步的操作。</span><br><span class="line">15.Class</span><br><span class="line">    class跟let、const一样：不存在变量提升、不能重复声明...</span><br><span class="line">    ES6 的class可以看作只是一个语法糖，它的绝大部分功能</span><br><span class="line">    ES5 都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。</span><br><span class="line">16.Module</span><br><span class="line">    ES6 的模块自动采用严格模式，不管你有没有在模块头部加上&quot;use strict&quot;;。</span><br><span class="line">    import和export命令以及export和export default的区别</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a>浏览器缓存</h3><pre><code>缓存可以减少网络 IO 消耗，提高访问速度。浏览器缓存是一种操作简单、效果显著的前端性能优化手段
很多时候，大家倾向于将浏览器缓存简单地理解为“HTTP 缓存”。
但事实上，浏览器缓存机制有四个方面，它们按照获取资源时请求的优先级依次排列如下：

Memory Cache
Service Worker Cache
HTTP Cache
Push Cache

缓存它又分为强制缓存和协商缓存。优先级较高的是强制缓存，在命中强制缓存失败的情况下，才会走协商缓存
    实现强制缓存，过去我们一直用 expires。
    当服务器返回响应时，在 Response Headers 中将过期时间写入 expires 字段，现在一般使用Cache-Control 两者同时出现使用Cache-Control

    协商缓存，Last-Modified 是一个时间戳，如果我们启用了协商缓存，它会在首次请求时随着 Response Headers 返回：每次请求去判断这个时间戳是否发生变化。
    从而去决定你是304读取缓存还是给你返回最新的数据</code></pre>
<h3 id="介绍define"><a href="#介绍define" class="headerlink" title="介绍define"></a>介绍define</h3><p>define是amd（异步模块加载机制）的api，第一个参数是模块名称（可选），第二个参数是数组，包含所有依赖的模块（可选），第三个参数可以是一个函数或者是一个js对象。</p>
<pre><code>(1) 三个参数：如果第三个参数是回调函数的话，异步加载完依赖的模块之后，执行回调函数，在回调函数中可以直接使用依赖的模块，
    他们按依赖声明顺序作为参数提供给回调函数。回调函数执行结束之后，通知依赖于自己的模块自己已经可用。
(2)两个参数：当第一个参数省略的话，就定义了一个匿名模块，这时候模块文件的文件名就是模块名。这将会使模块是高度可用的。
(3)一个参数： define 的前面两个参数都可以省略；第三个参数有两种情况：一种是 JavaScript 对象，另一种是一个函数。
  如果是对象，可以是包含方法的对象或者是只提供数据。后者和 JSONP非常类似，因此，AMD可以认为包含了一个完整的JSONP实现。模块演变为一个简单的数据对象，
  这样的数据对象是高度可用的，而且因为是静态对象，它也是CDN友好的，可以提高JSONP的性能。
  如果是函数，其用途之一是快速开发实现。适用于较小型的应用，该方式无需提前考虑需要引入的模块，只需使用时，require 即可。</code></pre>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">define(function()&#123;</span><br><span class="line">    var a &#x3D; require(&quot;A&quot;);</span><br><span class="line">&#125;)</span><br><span class="line">123</span><br></pre></td></tr></table></figure>
<p>define函数在执行的时候，会调用函数的 toString 方法，并扫描其中的 require 调用，提前载入这些模块，载入完成后再执行。<br>注意：Opera 不能很好的支持函数的 toString 方法，因此，在浏览器中它的适用性并不强。但是使用构建工具打包时，构建工具会扫描 require 并强制载入依赖模块。</p>
<h3 id="express是什么"><a href="#express是什么" class="headerlink" title="express是什么"></a>express是什么</h3><p>Express是一个最小的，灵活的Node.js Web应用程序开发框架，它提供了一套强大的功能来开发Web和移动应用程序。 它有助于基于Node Web应用程序的快速开发。<br>特点：</p>
<pre><code>1、可以设置 中间件来响应http请求
2、定义了路由用于执行不同的http请求动作
3、可以通过模板传递参数来动态渲染html页面</code></pre>
<h3 id="require是什么"><a href="#require是什么" class="headerlink" title="require是什么"></a>require是什么</h3><p>异步加载模块的加载器</p>
<h3 id="事件冒泡、事件委托以及事件捕获？"><a href="#事件冒泡、事件委托以及事件捕获？" class="headerlink" title="事件冒泡、事件委托以及事件捕获？"></a>事件冒泡、事件委托以及事件捕获？</h3><pre><code>事件冒泡就是子级元素的某个事件被触发，它的上级元素的该事件也被递归执行。冒泡的终点是window。
阻止事件冒泡在子级元素上面加上e.stopPropagation()阻止事件冒泡。
事件委托其实是使用了冒泡的原理，从点击的元素开始，以递归方式的向父元素传播事件，这样做的好处是对于大量要处理的元素，不必为每个元素都绑定事件，
只需要在他们的父元素上绑定一次即可，提高性能。 还有一个好处就是可以处理动态插入dom中的元素，直接绑定的方式是不行的。
事件捕获是最外层的事件先被触发，最后才是我们点击的button事件被触发，这便是事件捕获。
阻止事件捕获的方式是e.stopPropagation()。</code></pre>
<h3 id="发布订阅模式和观察者模式"><a href="#发布订阅模式和观察者模式" class="headerlink" title="发布订阅模式和观察者模式"></a>发布订阅模式和观察者模式</h3><h4 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h4><pre><code>观察者模式定义了对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知，并自动更新。
观察者模式属于行为型模式，行为型模式关注的是对象之间的通讯，观察者模式就是观察者和被观察者之间的通讯。

观察者模式有一个别名叫“发布-订阅模式”，或者说是“订阅-发布模式”，订阅者和订阅目标是联系在一起的，当订阅目标发生改变时，逐个通知订阅者。
我们可以用报纸期刊的订阅来形象的说明，当你订阅了一份报纸，每天都会有一份最新的报纸送到你手上，有多少人订阅报纸，报社就会发多少份报纸，报社和订报纸的客户就是上面文章开头所说的“一对多”的依赖关系。</code></pre>
<h4 id="发布订阅模式"><a href="#发布订阅模式" class="headerlink" title="发布订阅模式"></a>发布订阅模式</h4><pre><code>在现在的发布订阅模式中，称为发布者的消息发送者不会将消息直接发送给订阅者，这意味着发布者和订阅者不知道彼此的存在。
在发布者和订阅者之间存在第三个组件，称为消息代理或调度中心或中间件，它维持着发布者和订阅者之间的联系，过滤所有发布者传入的消息并相应地分发它们给订阅者。

举一个例子，你在微博上关注了A，同时其他很多人也关注了A，那么当A发布动态的时候，微博就会为你们推送这条动态。A就是发布者，你是订阅者，微博就是调度中心，
你和A是没有直接的消息往来的，全是通过微博来协调的（你的关注，A的发布动态）</code></pre>
<h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><pre><code>观察者模式： 观察者（Observer）直接订阅（Subscribe）主题（Subject），而当主题被激活的时候，会触发（Fire Event）观察者里的事件。

发布订阅模式： 订阅者（Subscriber）把自己想订阅的事件注册（Subscribe）到调度中心（Topic），当发布者（Publisher）发布该事件（Publish topic）到调度中心，
也就是该事件触发时，由调度中心统一调度（Fire Event）订阅者注册到调度中心的处理代码。</code></pre>
<h3 id="axios和ajax和fetch的区别"><a href="#axios和ajax和fetch的区别" class="headerlink" title="axios和ajax和fetch的区别"></a>axios和ajax和fetch的区别</h3><pre><code>其实axios是通过 promise 实现对 ajax 技术的一种封装。就像 ajax 是 通过 jQuery 来封装一样。
也就是说，jQuery 将请求技术进行了封装 变成了 ajax , 而 通过 promise 又把 ajax 进行封装就成了 axios。
ajax，本身是针对MVC的编程，不符合现在前端MVVM的浪潮。基于原生的XHR开发，XHR本身的架构不清晰，已经有了fetch的替代方案。JQuery整个项目太大，单纯使用ajax却要引入整个JQuery非常的不合理

ajax：

1、本身是针对MVC编程，不符合前端MVVM的浪潮
2、基于原生XHR开发，XHR本身的架构不清晰，已经有了fetch的替代方案，jquery整个项目太大，单纯使用ajax却要引入整个jquery非常不合理（采取个性化打包方案又不能享受cdn服务）
3、ajax不支持浏览器的back按钮
4、安全问题ajax暴露了与服务器交互的细节
5、对搜索引擎的支持比较弱
6、破坏程序的异常机制
7、不容易调试

axios：

1、从浏览器中创建XHR
2、从node.js创建http请求
3、支持Promise API
4、客户端防止CSRF（网站恶意利用）攻击
5、提供了一些并发请求的接口
6、支持拦截请求和响应、取消请求

fetch

1、只对网络请求报错，对400、500都当做成功的请求
2、默认不带cookie，需要添加配置项
3、没有办法监测请求的进度、而XHR可以</code></pre>
<h3 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h3><pre><code>只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。
假如存在全局变量tmp，但是块级作用域内let又声明了一个局部变量tmp，导致后者绑定这个块级作用域，所以在let声明变量前，对tmp赋值会报错。</code></pre>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var tmp &#x3D; 123;</span><br><span class="line"> </span><br><span class="line">if (true) &#123;</span><br><span class="line">  tmp &#x3D; &#39;abc&#39;; &#x2F;&#x2F; ReferenceError</span><br><span class="line">  let tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，存在全局变量tmp，但是块级作用域内let又声明了一个局部变量tmp，导致后者绑定这个块级作用域，所以在let声明变量前，对tmp赋值会报错。</p>
<p>ES6 明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。<br>（access ‘a’ before initialization 在初始化之前无法访问a）</p>
<p>总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。</p>
<h3 id="ToB和ToC的区别"><a href="#ToB和ToC的区别" class="headerlink" title="ToB和ToC的区别"></a>ToB和ToC的区别</h3><pre><code>1.业务形态不同：ToC的需求更多是围绕衣食住行；ToB的需求更多是围绕机构所处的某个行业或者领域来展开，场景更复杂多样。ToC是“生活”，；ToB更多的是“生产”。
2.产品需求不同：ToC对产品需求更多是功能外部化；ToB考虑的是产品实际化，专业化。
3.（购买）决策体系不同：ToC购买产品一般个人决定，ToB则需要业务部门、采购部门、财务部门、公司高层等的决策。</code></pre>
</div><div id="reward-container"><span class="hty-icon-button button-glow" id="reward-button" title="Donate" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === &quot;none&quot;) ? &quot;block&quot; : &quot;none&quot;;"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-hand-coin-line"></use></svg></span><div id="reward-comment">喜欢的话就打赏点吧</div><div id="qr" style="display:none;"><div style="display:inline-block"></div><div style="display:inline-block"></div><div style="display:inline-block"></div></div></div><ul class="post-copyright"><li class="post-copyright-author"><strong>Post author: </strong>sun</li><li class="post-copyright-link"><strong>Post link: </strong><a href="http://example.com/2021/02/21/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/" title="前端面试题总结">http://example.com/2021/02/21/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/</a></li><li class="post-copyright-license"><strong>Copyright Notice: </strong>All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0 "><svg class="icon"><use xlink:href="#icon-creative-commons-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-by-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-nc-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-sa-line"></use></svg></a> unless otherwise stated.</li></ul></section></article><div class="post-nav"><div class="post-nav-item"><a class="post-nav-prev" href="/2021/02/22/JS%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="prev" title="JS面试题"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-left-s-line"></use></svg><span class="post-nav-text">JS面试题</span></a></div><div class="post-nav-item"><a class="post-nav-next" href="/2021/02/18/ES5%E4%B8%8EES6/" rel="next" title="ES5与ES6"><span class="post-nav-text">ES5与ES6</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-right-s-line"></use></svg></a></div></div></div><div id="comment"><div class="comment-tooltip text-center"><span>点击按钮跳转 GitHub Issues 评论。</span><br><span>若没有本文 Issue，您可以使用 Comment 模版新建。</span><br><a class="hty-button hty-button--raised" id="github-issues" target="_blank" rel="noopener" href="https://github.com/YunYouJun/yunyoujun.github.io/issues?q=is:issue+前端面试题总结">GitHub Issues</a></div></div></main><footer class="sidebar-translate" id="footer"><div class="copyright"><span>&copy; 2019 – 2022 </span><span class="with-love" id="animate"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-cloud-line"></use></svg></span><span class="author"> sun</span></div><div class="powered"><span>Powered by <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> v5.3.0</span><span class="footer-separator">|</span><span>Theme - <a rel="noopener" href="https://github.com/YunYouJun/hexo-theme-yun" target="_blank"><span>Yun</span></a> v1.3.0</span></div></footer><a class="hty-icon-button" id="goUp" aria-label="back-to-top" href="#"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-up-s-line"></use></svg><svg class="progress-circle-container" viewBox="0 0 100 100"><circle class="progress-circle" id="progressCircle" cx="50" cy="50" r="48" fill="none" stroke="#0078E7" stroke-width="2" stroke-linecap="round"></circle></svg></a></div><script defer src="/js/utils.js"></script><script defer src="/js/hexo-theme-yun.js"></script></body></html>