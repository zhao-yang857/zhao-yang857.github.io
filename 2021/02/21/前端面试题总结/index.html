<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="theme-color" content="#0078E7"><meta name="author" content="sun"><meta name="copyright" content="sun"><meta name="generator" content="Hexo 5.3.0"><meta name="theme" content="hexo-theme-yun"><title>前端面试题总结 | 太阳の小屋</title><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@900&amp;display=swap" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/star-markdown-css@0.3.3/dist/yun/yun-markdown.min.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/prism-theme-vars/base.css"><script src="https://fastly.jsdelivr.net/npm/scrollreveal/dist/scrollreveal.min.js" defer></script><script>function initScrollReveal() {
  [".post-card",".markdown-body img"].forEach((target)=> {
    ScrollReveal().reveal(target);
  })
}
document.addEventListener("DOMContentLoaded", initScrollReveal);
document.addEventListener("pjax:success", initScrollReveal);
</script><link rel="icon" type="image/png" href="/feng.ico"><link rel="mask-icon" href="/feng.ico" color="#0078E7"><link rel="preload" href="/css/hexo-theme-yun.css" as="style"><link rel="prefetch" href="/js/sidebar.js" as="script"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><link rel="preconnect" href="https://fastly.jsdelivr.net/npm/" crossorigin><script id="yun-config">
    window.Yun = {}
    window.CONFIG = {"hostname":"example.com","root":"/","title":"太阳の小屋","version":"1.10.4","mode":"auto","copycode":true,"page":{"isPost":true},"i18n":{"placeholder":"搜索...","empty":"找不到您查询的内容: ${query}","hits":"找到 ${hits} 条结果","hits_time":"找到 ${hits} 条结果（用时 ${time} 毫秒）"},"anonymous_image":"https://cdn.yunyoujun.cn/img/avatar/none.jpg","say":{"api":"https://el-bot-api.vercel.app/api/words/young"},"fireworks":{"colors":null},"waline":{"config":{"enable":true,"serverURL":"https://waline.yunyoujun.cn","comment":true,"visitor":true,"emoji":["https://fastly.jsdelivr.net/gh/walinejs/emojis@latest/bilibili/","https://fastly.jsdelivr.net/gh/walinejs/emojis@latest/weibo/","https://fastly.jsdelivr.net/gh/walinejs/emojis@latest/qq/"],"locale":{"placeholder":"填写邮箱，可以收到回复通知哦～"},"requiredMeta":["nick"],"el":"#waline","lang":"zh-CN"},"cdn":"https://fastly.jsdelivr.net/npm/@waline/client@v2/dist/waline.js","dark":"html.dark"},"vendors":{"darken":"https://fastly.jsdelivr.net/npm/darken@1.5.0"}};
  </script><link rel="stylesheet" href="/css/hexo-theme-yun.css"><script src="/js/hexo-theme-yun.js" type="module"></script><link rel="alternate" href="/atom.xml" title="太阳の小屋" type="application/atom+xml"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin><script async src="https://www.googletagmanager.com/gtag/js?id=G-1LL0D86CY9"></script><script>if (CONFIG.hostname === location.hostname) {
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-1LL0D86CY9');
}</script><script data-ad-client="ca-pub-2245427233262012" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(function(){
  var bp = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  if (curProtocol === 'https') {
    bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
  }
  else {
    bp.src = 'http://push.zhanzhang.baidu.com/push.js';
  }
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(bp, s);
})();</script><!-- Google Tag Manager --><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src='https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);})(window,document,'script','dataLayer','GTM-M9KWR9L');</script><!-- End Google Tag Manager --><meta name="description" content="一、css和html 部分一、csscss 盒模型1css盒模型分为标准盒模型和怪异盒模型&#x2F;IE盒模型 基础盒模型：content(内容) + border + padding + margin 怪异盒模型&#x2F;IE盒模型：content (content + border + padding) + margin 正常情况下padding和border的设置会影响元素宽高的计算 box-sizing:">
<meta property="og:type" content="article">
<meta property="og:title" content="前端面试题总结">
<meta property="og:url" content="http://example.com/2021/02/21/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/index.html">
<meta property="og:site_name" content="太阳の小屋">
<meta property="og:description" content="一、css和html 部分一、csscss 盒模型1css盒模型分为标准盒模型和怪异盒模型&#x2F;IE盒模型 基础盒模型：content(内容) + border + padding + margin 怪异盒模型&#x2F;IE盒模型：content (content + border + padding) + margin 正常情况下padding和border的设置会影响元素宽高的计算 box-sizing:">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-02-21T05:52:19.000Z">
<meta property="article:modified_time" content="2022-06-14T08:07:41.198Z">
<meta property="article:author" content="sun">
<meta name="twitter:card" content="summary"><script>(function() {
  const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches
  const setting = localStorage.getItem('darken-mode') || 'auto'
  if (setting === 'dark' || (prefersDark && setting !== 'light'))
    document.documentElement.classList.toggle('dark', true)
})()</script></head><body><script src="https://code.iconify.design/2/2.1.1/iconify.min.js"></script><script>// Define global variable
IconifyProviders = {
  // Empty prefix: overwrite default API provider configuration
  '': {
    // Use custom API first, use Iconify public API as backup
    resources: [
        'https://api.iconify.design',
    ],
    // Wait for 1 second before switching API hosts
    rotate: 1000,
  },
};</script><script defer src="https://fastly.jsdelivr.net/npm/animejs@latest"></script><script defer src="/js/ui/fireworks.js" type="module"></script><canvas class="fireworks"></canvas><div class="container"><a class="sidebar-toggle hty-icon-button" id="menu-btn"><div class="hamburger hamburger--spin" type="button"><span class="hamburger-box"><span class="hamburger-inner"></span></span></div></a><div class="sidebar-toggle sidebar-overlay"></div><aside class="sidebar"><script src="/js/sidebar.js" type="module"></script><ul class="sidebar-nav"><li class="sidebar-nav-item sidebar-nav-toc hty-icon-button sidebar-nav-active" data-target="post-toc-wrap" title="文章目录"><span class="icon iconify" data-icon="ri:list-ordered"></span></li><li class="sidebar-nav-item sidebar-nav-overview hty-icon-button" data-target="site-overview-wrap" title="站点概览"><span class="icon iconify" data-icon="ri:passport-line"></span></li></ul><div class="sidebar-panel" id="site-overview-wrap"><div class="site-info fix-top"><a class="site-author-avatar" href="/about/" title="sun"><img width="96" loading="lazy" src="/images/head.jpeg" alt="sun"><span class="site-author-status" title="永远相信美好的事情即将发生">😊</span></a><div class="site-author-name"><a href="/about/">sun</a></div><span class="site-name">太阳の小屋</span><sub class="site-subtitle"></sub><div class="site-description"></div></div><nav class="site-state"><a class="site-state-item hty-icon-button icon-home" href="/" title="首页"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:home-4-line"></span></span></a><div class="site-state-item"><a href="/archives/" title="归档"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:archive-line"></span></span><span class="site-state-item-count">21</span></a></div><div class="site-state-item"><a href="/categories/" title="分类"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:folder-2-line"></span></span><span class="site-state-item-count">0</span></a></div><div class="site-state-item"><a href="/tags/" title="标签"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:price-tag-3-line"></span></span><span class="site-state-item-count">0</span></a></div><a class="site-state-item hty-icon-button" href="/about/#comment" title="留言板"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:clipboard-line"></span></span></a></nav><hr style="margin-bottom:0.5rem"><div class="links-of-author"><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://qun.qq.com/qqweb/qunpro/share?_wv=3&amp;_wwv=128&amp;appChannel=share&amp;inviteCode=28OEdR&amp;appChannel=share&amp;businessType=9&amp;from=246610&amp;biz=ka" title="QQ" target="_blank" style="color:#12B7F5"><span class="icon iconify" data-icon="ri:qq-line"></span></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://github.com/zhao-yang857" title="GitHub" target="_blank" style="color:#6e5494"><span class="icon iconify" data-icon="ri:github-line"></span></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://space.bilibili.com/1579790" title="哔哩哔哩" target="_blank" style="color:#FF8EB3"><span class="icon iconify" data-icon="ri:bilibili-line"></span></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://u.wechat.com/MMv5Z74wQ2OUz60lMdK233Y" title="微信" target="_blank" style="color:#1AAD19"><span class="icon iconify" data-icon="ri:wechat-2-line"></span></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="mailto:me@yunyoujun.cn" title="E-Mail" target="_blank" style="color:#8E71C1"><span class="icon iconify" data-icon="ri:mail-line"></span></a></div><hr style="margin:0.5rem 1rem"><div class="links"><a class="links-item hty-icon-button" href="/links/" title="我的小伙伴们" style="color:dodgerblue"><span class="icon iconify" data-icon="ri:genderless-line"></span></a><a class="links-item hty-icon-button" href="/girls/" title="喜欢的女孩子" style="color:hotpink"><span class="icon iconify" data-icon="ri:women-line"></span></a></div><br><a class="links-item hty-icon-button" id="toggle-mode-btn" href="javascript:;" title="Mode" style="color: #f1cb64"><span class="icon iconify" data-icon="ri:contrast-2-line"></span></a></div><div class="sidebar-panel sidebar-panel-active" id="post-toc-wrap"><div class="post-toc"><div class="post-toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81css%E5%92%8Chtml-%E9%83%A8%E5%88%86"><span class="toc-number">1.</span> <span class="toc-text">一、css和html 部分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81css"><span class="toc-number">1.1.</span> <span class="toc-text">一、css</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#css-%E7%9B%92%E6%A8%A1%E5%9E%8B1"><span class="toc-number">1.1.1.</span> <span class="toc-text">css 盒模型1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#box-sizing%E5%B8%B8%E7%94%A8%E7%9A%84%E5%B1%9E%E6%80%A7%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E5%88%86%E5%88%AB%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">1.1.2.</span> <span class="toc-text">box-sizing常用的属性有哪些？分别有什么作用？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">1.1.3.</span> <span class="toc-text">3、清除浮动的方式有哪些</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BFC%EF%BC%88Block-Formatting-Context%EF%BC%89-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="toc-number">1.1.4.</span> <span class="toc-text">BFC（Block Formatting Context） 是什么？应用场景？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E4%B8%8B%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0%E5%92%8C%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%E8%A1%8C%E5%86%85%E5%9D%97%E5%85%83%E7%B4%A0%E7%9A%84%E5%85%BC%E5%AE%B9%E6%80%A7%E4%BD%BF%E7%94%A8%EF%BC%9F%EF%BC%88IE8-%E4%BB%A5%E4%B8%8B%EF%BC%89"><span class="toc-number">1.1.5.</span> <span class="toc-text">说下行内元素和块级元素的区别？行内块元素的兼容性使用？（IE8 以下）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#css%E5%86%99%E4%B8%89%E8%A7%92%E5%BD%A2"><span class="toc-number">1.1.6.</span> <span class="toc-text">css写三角形</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#css-%E9%80%89%E6%8B%A9%E5%99%A8%E6%9C%89%E5%93%AA%E4%BA%9B-%E4%BB%A5%E5%8F%8A%E4%BC%98%E5%85%88%E7%BA%A7-%E5%8F%AF%E4%BB%A5%E7%BB%A7%E6%89%BF%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="toc-number">1.1.7.</span> <span class="toc-text">css 选择器有哪些,以及优先级,可以继承的属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AE%B9%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95"><span class="toc-number">1.1.8.</span> <span class="toc-text">内容水平垂直居中有哪些方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#display-none-%E5%92%8C-visibility-hidden-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">1.1.9.</span> <span class="toc-text">display: none 和 visibility: hidden 有什么区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9E%E6%B5%81%E4%B8%8E%E9%87%8D%E7%BB%98"><span class="toc-number">1.1.10.</span> <span class="toc-text">回流与重绘</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%9B%9E%E6%B5%81"><span class="toc-number">1.1.10.1.</span> <span class="toc-text">一、什么是回流?</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E9%87%8D%E7%BB%98"><span class="toc-number">1.1.10.2.</span> <span class="toc-text">二、什么是重绘?</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E4%B8%A4%E8%80%85%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.1.10.3.</span> <span class="toc-text">三、两者的区别?</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E5%8F%91%E7%94%9F%E5%9B%9E%E6%B5%81%EF%BC%9F"><span class="toc-number">1.1.10.4.</span> <span class="toc-text">四、什么时候会发生回流？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E5%A6%82%E4%BD%95%E5%87%8F%E5%B0%91%E5%9B%9E%E6%B5%81%E5%92%8C%E9%87%8D%E7%BB%98%EF%BC%9F"><span class="toc-number">1.1.10.5.</span> <span class="toc-text">五、如何减少回流和重绘？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%97%E5%87%BAdisplay%E7%9A%84%E5%80%BC%E3%80%82position%E7%9A%84%E5%80%BC-relative%E5%92%8Cabsolute%E5%88%86%E5%88%AB%E6%98%AF%E7%9B%B8%E5%AF%B9%E4%BA%8E%E8%B0%81%E8%BF%9B%E8%A1%8C%E5%AE%9A%E4%BD%8D%E7%9A%84"><span class="toc-number">1.1.11.</span> <span class="toc-text">列出display的值。position的值,relative和absolute分别是相对于谁进行定位的?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CSS3%E6%96%B0%E7%89%B9%E6%80%A7%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">1.1.12.</span> <span class="toc-text">CSS3新特性有哪些？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#css3%E6%96%B0%E5%A2%9E%E7%9A%84%E4%BC%AA%E7%B1%BB"><span class="toc-number">1.1.13.</span> <span class="toc-text">css3新增的伪类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#css3%E4%B8%AD%E5%8D%95%E4%BD%8Dpx-em-rem-vh-vw-vmin-vmax%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.1.14.</span> <span class="toc-text">css3中单位px,em,rem,vh,vw,vmin,vmax的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CSS%E9%9A%90%E8%97%8F%E5%85%83%E7%B4%A0%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="toc-number">1.1.15.</span> <span class="toc-text">CSS隐藏元素的几种方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A%E4%B8%8BCSS-sprites-%E4%BB%A5%E5%8F%8A%E4%BD%A0%E8%A6%81%E5%A6%82%E4%BD%95%E5%9C%A8%E9%A1%B5%E9%9D%A2%E6%88%96%E7%BD%91%E7%AB%99%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%AE%83"><span class="toc-number">1.1.16.</span> <span class="toc-text">解释下CSS  sprites,以及你要如何在页面或网站中使用它</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A8%E8%AE%BACSS-hacks-%E6%9D%A1%E4%BB%B6%E5%BC%95%E7%94%A8%E6%88%96%E8%80%85%E5%85%B6%E4%BB%96"><span class="toc-number">1.1.17.</span> <span class="toc-text">讨论CSS hacks, 条件引用或者其他</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#css%E9%A2%84%E7%BC%96%E8%AF%91"><span class="toc-number">1.1.18.</span> <span class="toc-text">css预编译</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8css%E9%A2%84%E7%BC%96%E8%AF%91"><span class="toc-number">1.1.18.1.</span> <span class="toc-text">为什么要用css预编译</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#css%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-number">1.1.18.2.</span> <span class="toc-text">css的缺点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BB%E6%B5%81CSS%E9%A2%84%E7%BC%96%E8%AF%91%E5%99%A8%E7%9A%84%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.1.18.3.</span> <span class="toc-text">主流CSS预编译器的介绍</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Sass%E5%92%8CLess%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">1.1.18.4.</span> <span class="toc-text">Sass和Less的比较</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9%E4%BD%BF%E7%94%A8Sass%E8%80%8C%E4%B8%8D%E6%98%AFLess%EF%BC%9F"><span class="toc-number">1.1.19.</span> <span class="toc-text">为什么选择使用Sass而不是Less？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81html"><span class="toc-number">1.2.</span> <span class="toc-text">二、html</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E9%82%A3%E5%87%A0%E7%A7%8D%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B5%8B%E8%AF%95%EF%BC%9F%E6%9C%89%E5%93%AA%E4%BA%9B%E5%86%85%E6%A0%B8-Layout-Engine"><span class="toc-number">1.2.1.</span> <span class="toc-text">常用那几种浏览器测试？有哪些内核(Layout Engine)?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTML5-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AA%E9%9C%80%E8%A6%81%E5%86%99-lt-DOCTYPE-html-gt-%EF%BC%9F"><span class="toc-number">1.2.2.</span> <span class="toc-text">HTML5 为什么只需要写&lt;!　DOCTYPE html&gt; ？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#html5%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9F"><span class="toc-number">1.2.3.</span> <span class="toc-text">html5有哪些新特性？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B7%E5%86%99%E5%87%BA%E4%B8%80%E4%BA%9B%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">1.2.4.</span> <span class="toc-text">请写出一些前端性能优化的方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B7%E8%AF%B4%E5%87%BA%E4%B8%89%E7%A7%8D%E5%87%8F%E5%B0%91%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E6%97%B6%E9%97%B4%E7%9A%84%E6%96%B9%E6%B3%95%E3%80%82"><span class="toc-number">1.2.5.</span> <span class="toc-text">请说出三种减少页面加载时间的方法。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.2.6.</span> <span class="toc-text">线程与进程的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E5%AF%BC%E5%85%A5%E6%A0%B7%E5%BC%8F%E6%97%B6%EF%BC%8C%E4%BD%BF%E7%94%A8link%E5%92%8C-import%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.2.7.</span> <span class="toc-text">页面导入样式时，使用link和@import有什么区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8HTML%E5%BD%93%E4%B8%AD%E5%BC%95%E7%94%A8CSS%E7%9A%84%E4%B8%89%E7%A7%8D%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E5%AE%83%E4%BB%AC%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.2.8.</span> <span class="toc-text">在HTML当中引用CSS的三种使用方式有哪些？它们之间的区别是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E8%BF%B0%E4%B8%80%E4%B8%8B%E4%BD%A0%E5%AF%B9HTML%E8%AF%AD%E4%B9%89%E5%8C%96%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F"><span class="toc-number">1.2.9.</span> <span class="toc-text">简述一下你对HTML语义化的理解？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E5%A4%9A%E4%B8%AA%E6%A0%87%E7%AD%BE%E9%A1%B5%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1"><span class="toc-number">1.2.10.</span> <span class="toc-text">如何实现浏览器内多个标签页之间的通信?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#webSocket%E5%A6%82%E4%BD%95%E5%85%BC%E5%AE%B9%E4%BD%8E%E6%B5%8F%E8%A7%88%E5%99%A8%EF%BC%9F"><span class="toc-number">1.2.11.</span> <span class="toc-text">webSocket如何兼容低浏览器？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#iframe%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="toc-number">1.2.12.</span> <span class="toc-text">iframe的优缺点？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BD%91%E9%A1%B5%E5%B8%83%E5%B1%80%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">1.2.13.</span> <span class="toc-text">网页布局有哪几种，有什么区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E8%AE%A9Chrome%E6%94%AF%E6%8C%81%E5%B0%8F%E4%BA%8E12px-%E7%9A%84%E6%96%87%E5%AD%97%EF%BC%9F"><span class="toc-number">1.2.14.</span> <span class="toc-text">怎么让Chrome支持小于12px 的文字？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Doctype%E4%BD%9C%E7%94%A8-%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F%E4%B8%8E%E6%B7%B7%E6%9D%82%E6%A8%A1%E5%BC%8F%E5%A6%82%E4%BD%95%E5%8C%BA%E5%88%86%EF%BC%9F%E5%AE%83%E4%BB%AC%E6%9C%89%E4%BD%95%E6%84%8F%E4%B9%89"><span class="toc-number">1.2.15.</span> <span class="toc-text">Doctype作用? 严格模式与混杂模式如何区分？它们有何意义?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Doctype%E6%96%87%E6%A1%A3%E7%B1%BB%E5%9E%8B%EF%BC%9F"><span class="toc-number">1.2.16.</span> <span class="toc-text">Doctype文档类型？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTML%E4%B8%8EXHTML%E2%80%94%E2%80%94%E4%BA%8C%E8%80%85%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">1.2.17.</span> <span class="toc-text">HTML与XHTML——二者有什么区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E5%85%BC%E5%AE%B9%E6%80%A7%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">1.2.18.</span> <span class="toc-text">常见兼容性问题？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AF%B9%E7%BD%91%E7%AB%99%E7%9A%84%E6%96%87%E4%BB%B6%E5%92%8C%E8%B5%84%E6%BA%90%E8%BF%9B%E8%A1%8C%E4%BC%98%E5%8C%96%EF%BC%9F"><span class="toc-number">1.2.19.</span> <span class="toc-text">如何对网站的文件和资源进行优化？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-FOUC%EF%BC%88%E6%97%A0%E6%A0%B7%E5%BC%8F%E5%86%85%E5%AE%B9%E9%97%AA%E7%83%81%EF%BC%89%EF%BC%9F%E4%BD%A0%E5%A6%82%E4%BD%95%E6%9D%A5%E9%81%BF%E5%85%8D-FOUC%EF%BC%9F"><span class="toc-number">1.2.20.</span> <span class="toc-text">什么是 FOUC（无样式内容闪烁）？你如何来避免 FOUC？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8form%E8%A1%A8%E5%8D%95%E4%B8%AD%EF%BC%8Cget%E6%96%B9%E5%BC%8F%E5%92%8Cpost%E6%96%B9%E5%BC%8F%E6%8F%90%E4%BA%A4%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%9C%A8%E5%AE%9E%E9%99%85%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%9F"><span class="toc-number">1.2.21.</span> <span class="toc-text">在form表单中，get方式和post方式提交数据的区别是什么？如何判断在实际开发中的应用？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8input%E8%A1%A8%E5%8D%95%E6%8E%A7%E4%BB%B6%E4%B8%AD%EF%BC%8Cvalue%E5%92%8Cplaceholder%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.2.22.</span> <span class="toc-text">在input表单控件中，value和placeholder的区别是什么？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81js-%E9%83%A8%E5%88%86"><span class="toc-number">2.</span> <span class="toc-text">二、js 部分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#js%E6%98%AF%E4%BB%80%E4%B9%88%E8%AF%AD%E8%A8%80"><span class="toc-number">2.1.</span> <span class="toc-text">js是什么语言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#js-%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%8C%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%A4%8D%E6%9D%82%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.2.</span> <span class="toc-text">js 的基本数据类型有哪些，基本数据类型和复杂数据类型的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E2%80%94%E2%80%94%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE"><span class="toc-number">2.3.</span> <span class="toc-text">面向对象——原型与原型链</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B"><span class="toc-number">2.3.1.</span> <span class="toc-text">原型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E9%93%BE"><span class="toc-number">2.3.2.</span> <span class="toc-text">原型链</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE"><span class="toc-number">2.3.3.</span> <span class="toc-text">作用域链</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E6%9C%89%E5%93%AA%E4%BA%9B%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95"><span class="toc-number">2.4.</span> <span class="toc-text">数组有哪些操作方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#call-%E3%80%81bind-%E3%80%81apply-%E5%8C%BA%E5%88%AB"><span class="toc-number">2.5.</span> <span class="toc-text">call ()、bind ()、apply () 区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%92%8C-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">2.6.</span> <span class="toc-text">&#x3D;&#x3D; 和 &#x3D;&#x3D;&#x3D; 有什么区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#forEach%E5%92%8Cmap%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.7.</span> <span class="toc-text">forEach和map的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#split-%E5%92%8C-join-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.8.</span> <span class="toc-text">split () 和 join () 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%97%AD%E5%8C%85"><span class="toc-number">2.9.</span> <span class="toc-text">什么是闭包</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AD%E5%8C%85%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-number">2.9.1.</span> <span class="toc-text">闭包的好处</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#js%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E7%9F%A5%E9%81%93%E5%93%AA%E4%BA%9B%EF%BC%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E7%9A%84%E5%A5%BD%E5%A4%84%E5%92%8C%E5%9D%8F%E5%A4%84"><span class="toc-number">2.10.</span> <span class="toc-text">js垃圾回收机制知道哪些，垃圾回收机制的好处和坏处</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="toc-number">2.10.1.</span> <span class="toc-text">什么是垃圾回收机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">2.10.2.</span> <span class="toc-text">内存泄漏的原因</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">2.10.3.</span> <span class="toc-text">垃圾回收的方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-number">2.11.</span> <span class="toc-text">深拷贝和浅拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E5%92%8C%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.12.</span> <span class="toc-text">箭头函数和匿名函数的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9promise%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">2.13.</span> <span class="toc-text">对promise的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8Basync%E5%92%8Cawait"><span class="toc-number">2.14.</span> <span class="toc-text">介绍一下async和await</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#promise%E5%92%8Casync%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.15.</span> <span class="toc-text">promise和async的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8F%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%BE%AE%E4%BB%BB%E5%8A%A1"><span class="toc-number">2.16.</span> <span class="toc-text">宏任务和微任务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%B2%E6%8A%96%E8%8A%82%E6%B5%81"><span class="toc-number">2.17.</span> <span class="toc-text">防抖节流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%B2%E6%8A%96%EF%BC%88debounce%EF%BC%89"><span class="toc-number">2.17.1.</span> <span class="toc-text">防抖（debounce）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8A%82%E6%B5%81"><span class="toc-number">2.17.2.</span> <span class="toc-text">节流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">2.17.3.</span> <span class="toc-text">防抖和节流的区别？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#null-%E5%92%8C-undefined-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.18.</span> <span class="toc-text">null 和 undefined 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87"><span class="toc-number">2.19.</span> <span class="toc-text">什么是变量提升</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98"><span class="toc-number">2.20.</span> <span class="toc-text">什么是事件委托</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#async-%E4%B8%8E-defer-%E5%8C%BA%E5%88%AB"><span class="toc-number">2.21.</span> <span class="toc-text">async 与 defer 区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cookies%EF%BC%8CsessionStorage-%E5%92%8C-localStorage-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">2.22.</span> <span class="toc-text">cookies，sessionStorage 和 localStorage 有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95"><span class="toc-number">2.23.</span> <span class="toc-text">数组去重有哪些方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%88%A9%E7%94%A8%E5%86%92%E6%B3%A1-for-%E5%BE%AA%E7%8E%AF%E5%B5%8C%E5%A5%97%EF%BC%8C%E7%84%B6%E5%90%8E-splice-%E5%8E%BB%E9%87%8D-%E5%A6%82%EF%BC%9A"><span class="toc-number">2.23.1.</span> <span class="toc-text">1.利用冒泡 for 循环嵌套，然后 splice () 去重 如：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-indexOf-%E5%8E%BB%E9%87%8D-%E5%A6%82%EF%BC%9A"><span class="toc-number">2.23.2.</span> <span class="toc-text">2.indexOf () 去重 如：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-sort-%E5%8E%BB%E9%87%8D-%E5%A6%82%EF%BC%9A"><span class="toc-number">2.23.3.</span> <span class="toc-text">3.sort () 去重 如：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-filter-%E5%8E%BB%E9%87%8D-%E5%A6%82"><span class="toc-number">2.23.4.</span> <span class="toc-text">4.filter () 去重 如:</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GET-%E5%92%8C-POST-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">2.24.</span> <span class="toc-text">GET 和 POST 有什么区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%BA%E5%88%B6%E7%BC%93%E5%AD%98%E5%92%8C%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98"><span class="toc-number">2.25.</span> <span class="toc-text">强制缓存和协商缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%A8%E5%9F%9F%E6%9C%89%E5%87%A0%E7%A7%8D%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">2.26.</span> <span class="toc-text">跨域有几种解决方案</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-jsonp"><span class="toc-number">2.26.1.</span> <span class="toc-text">1. jsonp</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-document-domain-iframe-%EF%BC%88%E9%80%82%E7%94%A8%E4%BA%8E%E4%B8%BB%E5%9F%9F%E5%90%8D%E7%9B%B8%E5%90%8C-%E5%AD%90%E5%9F%9F%E5%90%8D%E4%B8%8D%E5%90%8C-%E4%B8%A4%E4%B8%AA%E9%A1%B5%E9%9D%A2%E9%83%BD%E9%80%9A%E8%BF%87js%E5%BC%BA%E5%88%B6%E8%AE%BE%E7%BD%AEdocument-domain%E4%B8%BA%E5%9F%BA%E7%A1%80%E4%B8%BB%E5%9F%9F%EF%BC%8C%E5%B0%B1%E5%AE%9E%E7%8E%B0%E4%BA%86%E5%90%8C%E5%9F%9F%EF%BC%89"><span class="toc-number">2.26.2.</span> <span class="toc-text">2. document.domain + iframe （适用于主域名相同 子域名不同  两个页面都通过js强制设置document.domain为基础主域，就实现了同域）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-location-hash-iframe"><span class="toc-number">2.26.3.</span> <span class="toc-text">3. location.hash + iframe</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-window-name-iframe"><span class="toc-number">2.26.4.</span> <span class="toc-text">4. window.name + iframe</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-postMessage-data-origin-%E6%96%B9%E6%B3%95%E6%8E%A5%E5%8F%97%E4%B8%A4%E4%B8%AA%E5%8F%82%E6%95%B0"><span class="toc-number">2.26.5.</span> <span class="toc-text">5. postMessage (data,origin)方法接受两个参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E8%B7%A8%E5%9F%9F%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB%EF%BC%88CORS%EF%BC%89"><span class="toc-number">2.26.6.</span> <span class="toc-text">6. 跨域资源共享（CORS）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#typeof-%E5%92%8C-instanceof-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">2.27.</span> <span class="toc-text">typeof 和 instanceof 有什么区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81vue-%E9%83%A8%E5%88%86"><span class="toc-number">3.</span> <span class="toc-text">三、vue 部分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#vue-%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">3.1.</span> <span class="toc-text">vue 实现数据双向绑定的原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-MVC-%E5%92%8C-MVVM-%E5%92%8C-MVP"><span class="toc-number">3.2.</span> <span class="toc-text">什么是 MVC 和 MVVM 和 MVP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vue-%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%BB%A5%E5%8F%8A%E9%A1%B5%E9%9D%A2%E5%88%9D%E6%AC%A1%E5%8A%A0%E8%BD%BD%E4%BC%9A%E8%A7%A6%E5%8F%91%E5%93%AA%E4%BA%9B%E9%92%A9%E5%AD%90"><span class="toc-number">3.3.</span> <span class="toc-text">vue 的生命周期以及页面初次加载会触发哪些钩子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#v-if-%E5%92%8C-v-for-%E5%93%AA%E4%B8%80%E4%B8%AA%E4%BC%98%E5%85%88%E7%BA%A7%E9%AB%98"><span class="toc-number">3.4.</span> <span class="toc-text">v-if 和 v-for 哪一个优先级高</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#v-if-%E5%92%8C-v-show-%E6%9C%89%E4%BB%80%E4%B9%88%E5%BC%82%E5%90%8C"><span class="toc-number">3.5.</span> <span class="toc-text">v-if 和 v-show 有什么异同</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vue-%E4%B8%AD-data-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BF%85%E9%A1%BB%E6%98%AF%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0"><span class="toc-number">3.6.</span> <span class="toc-text">vue 中 data 为什么必须是一个函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#v-for-%E9%87%8C%E9%9D%A2-key-%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">3.7.</span> <span class="toc-text">v-for 里面 key 的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vue%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">3.8.</span> <span class="toc-text">vue组件通信有哪些</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%B5%E9%9D%A2%E9%97%AA%E5%8A%A8%E9%97%AE%E9%A2%98"><span class="toc-number">3.9.</span> <span class="toc-text">初始化页面闪动问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#route%E5%92%8C-router-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.10.</span> <span class="toc-text">route和 router 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vuex-%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E7%8A%B6%E6%80%81"><span class="toc-number">3.11.</span> <span class="toc-text">vuex 有哪几种状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vue-router-%E6%9C%89%E5%87%A0%E7%A7%8D%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.12.</span> <span class="toc-text">vue-router 有几种模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E8%B7%B3%E8%BD%AC%E7%9A%84%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8A%E6%96%B9%E5%BC%8F"><span class="toc-number">3.13.</span> <span class="toc-text">路由跳转的原理以及方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vue3%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-number">3.14.</span> <span class="toc-text">vue3的优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vue3%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8proxy%E4%BB%A3%E6%9B%BFObject-defineProperty"><span class="toc-number">3.15.</span> <span class="toc-text">vue3为什么用proxy代替Object.defineProperty</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%85%B6%E5%AE%83"><span class="toc-number">4.</span> <span class="toc-text">四、其它</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E9%9B%85%E9%99%8D%E7%BA%A7%E5%92%8C%E6%B8%90%E8%BF%9B%E5%A2%9E%E5%BC%BA"><span class="toc-number">4.1.</span> <span class="toc-text">优雅降级和渐进增强</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E9%A1%B5%E9%9D%A2%E6%9C%89%E5%93%AA%E4%B8%89%E5%B1%82%E6%9E%84%E6%88%90%EF%BC%8C%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">4.2.</span> <span class="toc-text">浏览器页面有哪三层构成，分别是什么，作用是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E9%87%8D%E6%9E%84%E6%80%8E%E4%B9%88%E6%93%8D%E4%BD%9C%EF%BC%9F"><span class="toc-number">4.3.</span> <span class="toc-text">页面重构怎么操作？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-number">4.4.</span> <span class="toc-text">前端性能优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#http%E5%92%8Chttps%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.5.</span> <span class="toc-text">http和https的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#http-%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B"><span class="toc-number">4.6.</span> <span class="toc-text">http 请求过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-%E5%B8%B8%E8%A7%81%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-number">4.7.</span> <span class="toc-text">HTTP 常见状态码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E5%AE%8C%E6%95%B4%E7%9A%84-url-%E5%8C%85%E6%8B%AC%E5%93%AA%E5%87%A0%E9%83%A8%E5%88%86"><span class="toc-number">4.8.</span> <span class="toc-text">一个完整的 url 包括哪几部分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#url%E5%92%8Curi%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.9.</span> <span class="toc-text">url和uri的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#webpack%E9%85%8D%E7%BD%AE%E5%85%A5%E5%8F%A3%E5%87%BA%E5%8F%A3"><span class="toc-number">4.10.</span> <span class="toc-text">webpack配置入口出口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#webpack3%E5%92%8Cwebpack4%E5%8C%BA%E5%88%AB"><span class="toc-number">4.11.</span> <span class="toc-text">webpack3和webpack4区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#es6%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-number">4.12.</span> <span class="toc-text">es6新特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98"><span class="toc-number">4.13.</span> <span class="toc-text">浏览器缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8Ddefine"><span class="toc-number">4.14.</span> <span class="toc-text">介绍define</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#express%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">4.15.</span> <span class="toc-text">express是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#require%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">4.16.</span> <span class="toc-text">require是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1%E3%80%81%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98%E4%BB%A5%E5%8F%8A%E4%BA%8B%E4%BB%B6%E6%8D%95%E8%8E%B7%EF%BC%9F"><span class="toc-number">4.17.</span> <span class="toc-text">事件冒泡、事件委托以及事件捕获？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F%E5%92%8C%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.18.</span> <span class="toc-text">发布订阅模式和观察者模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.18.1.</span> <span class="toc-text">观察者模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.18.2.</span> <span class="toc-text">发布订阅模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB"><span class="toc-number">4.18.3.</span> <span class="toc-text">区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#axios%E5%92%8Cajax%E5%92%8Cfetch%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.19.</span> <span class="toc-text">axios和ajax和fetch的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9A%82%E6%97%B6%E6%80%A7%E6%AD%BB%E5%8C%BA"><span class="toc-number">4.20.</span> <span class="toc-text">暂时性死区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ToB%E5%92%8CToC%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.21.</span> <span class="toc-text">ToB和ToC的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#eharts%E5%8E%9F%E7%90%86"><span class="toc-number">4.22.</span> <span class="toc-text">eharts原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#canvas%E5%92%8Csvg%E5%8C%BA%E5%88%AB"><span class="toc-number">4.23.</span> <span class="toc-text">canvas和svg区别</span></a></li></ol></li></ol></div></div></div></aside><main class="sidebar-translate" id="content"><div id="post"><article class="hty-card post-block" itemscope itemtype="https://schema.org/Article" style="--smc-primary:#0078E7;"><link itemprop="mainEntityOfPage" href="http://example.com/2021/02/21/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/"><span hidden itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="name" content="sun"><meta itemprop="description"></span><span hidden itemprop="publisher" itemscope itemtype="https://schema.org/Organization"><meta itemprop="name" content="太阳の小屋"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">前端面试题总结<a class="post-edit-link" href="https://github.com/YunYouJun/yunyoujun.github.io/tree/hexo/source/_posts/前端面试题总结.md" target="_blank" title="编辑" rel="noopener"><span class="icon iconify" data-icon="ri:edit-line"></span></a></h1><div class="post-meta"><div class="post-time"><span class="post-meta-item-icon"><span class="icon iconify" data-icon="ri:calendar-line"></span></span> <time title="创建时间：2021-02-21 13:52:19" itemprop="dateCreated datePublished" datetime="2021-02-21T13:52:19+08:00">2021-02-21</time><span class="post-meta-divider">-</span><span class="post-meta-item-icon"><span class="icon iconify" data-icon="ri:calendar-2-line"></span></span> <time title="修改时间：2022-06-14 16:07:41" itemprop="dateModified" datetime="2022-06-14T16:07:41+08:00">2022-06-14</time></div><span class="leancloud_visitors" id="/2021/02/21/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/" data-flag-title="前端面试题总结"><span class="post-meta-divider">-</span><span class="post-meta-item-icon" title="阅读次数"><span class="icon iconify" data-icon="ri:eye-line"></span> <span class="leancloud-visitors-count"></span></span></span><span class="post-meta-divider">-</span><a href="#comment"><span class="post-meta-item-icon" title="评论数"><span class="icon iconify" data-icon="ri:chat-3-line"></span> <span class="waline-comment-count" id="/2021/02/21/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/"></span></span></a><div class="post-classify"></div></div></header><section class="post-body" itemprop="articleBody"><div class="post-content markdown-body"><h2 id="一、css和html-部分"><a href="#一、css和html-部分" class="headerlink" title="一、css和html 部分"></a>一、css和html 部分</h2><h3 id="一、css"><a href="#一、css" class="headerlink" title="一、css"></a>一、css</h3><h4 id="css-盒模型1"><a href="#css-盒模型1" class="headerlink" title="css 盒模型1"></a>css 盒模型1</h4><pre><code>css盒模型分为标准盒模型和怪异盒模型/IE盒模型
基础盒模型：content(内容) + border + padding + margin
怪异盒模型/IE盒模型：content (content + border + padding) + margin
正常情况下padding和border的设置会影响元素宽高的计算
box-sizing: content-box (称为标准盒模型)     width = 元素内容的宽度 实际宽度是元素内容宽度
box-sizing: border-box (称为怪异盒模型/IE盒模型)    width = 元素内容的宽度 + padding + border，实际宽度是width减去(border + padding)的值</code></pre>
<h4 id="box-sizing常用的属性有哪些？分别有什么作用？"><a href="#box-sizing常用的属性有哪些？分别有什么作用？" class="headerlink" title="box-sizing常用的属性有哪些？分别有什么作用？"></a>box-sizing常用的属性有哪些？分别有什么作用？</h4><pre><code>box-sizing: content-box|border-box|inherit;
content-box:宽度和高度分别应用到元素的内容框。
border-box:宽度和高度分别减去border（边框）和padding（内边距）才能得到实际内容的宽度和高度。
inherit：从父元素继承box-sizing属性</code></pre>
<h4 id="3、清除浮动的方式有哪些"><a href="#3、清除浮动的方式有哪些" class="headerlink" title="3、清除浮动的方式有哪些"></a>3、清除浮动的方式有哪些</h4><pre><code>（1）父元素设置height。
（2）使用after伪元素清除浮动
    如：.clearfix:after&#123;/*伪元素是行内元素 正常浏览器清除浮动方法*/
                content: &quot;&quot;;
                display: block;
                height: 0;
                clear:both;
                visibility: hidden;
            &#125;
            .clearfix&#123;
                *zoom: 1;/*ie6清除浮动的方式 *号只有IE6-IE7执行，其他浏览器不执行*/
            &#125;
（3）使用before和after双伪元素清除浮动
        如： .clearfix:before,.clearfix:after &#123; 
            content: &#39;&#39;; 
            display: table; 
           &#125;  
           .clearfix:after &#123; 
               clear: both 
            &#125;  
            .clearfix &#123; 
                *zoom: 1; /*此处是为ie6、7处理的方式 */
            &#125;
（4）结尾处加空div标签设置clear:both。如：.clear &#123;clear:both &#125;
（4）父元素添加overflow:hidden。触发BFC</code></pre>
<h4 id="BFC（Block-Formatting-Context）-是什么？应用场景？"><a href="#BFC（Block-Formatting-Context）-是什么？应用场景？" class="headerlink" title="BFC（Block Formatting Context） 是什么？应用场景？"></a>BFC（Block Formatting Context） 是什么？应用场景？</h4><pre><code>BFC 就是 块级格式上下文 的格式，创建了BFC的元素就是一个独立的盒子，不过只有BLock-level box可以参与创建BFC，
它规定了内部的Bloc-level Box 如何布局，并且与这个独立盒子里的布局不受外部影响，当然它也不会影响到外面的元素。 
应用场景： 
    解决margin叠加的问题 
    用于布局（overflow: hidden）,BFC不会与浮动盒子叠加。 
    用于清除浮动，计算BFC高度</code></pre>
<h4 id="说下行内元素和块级元素的区别？行内块元素的兼容性使用？（IE8-以下）"><a href="#说下行内元素和块级元素的区别？行内块元素的兼容性使用？（IE8-以下）" class="headerlink" title="说下行内元素和块级元素的区别？行内块元素的兼容性使用？（IE8 以下）"></a>说下行内元素和块级元素的区别？行内块元素的兼容性使用？（IE8 以下）</h4><pre><code>行内元素：会在水平方向排列，直至一行排不下才会换行，其宽度随元素的内容而变化,不能包含块级元素，设置width无效，height无效(可以设置line-height)，margin上下无效，padding上下无效。
（行内元素 : span,a,label,input,img,strong,em;）

块级元素：各占据一行，垂直方向排列。其宽度自动填满其父元素宽度。（块级元素：div,p,h1,form,ul,li;）
兼容性：display:inline-block;*display:inline;*zoom:1;</code></pre>
<h4 id="css写三角形"><a href="#css写三角形" class="headerlink" title="css写三角形"></a>css写三角形</h4><pre><code>以三角形为例:
div&#123;
    width: 0;
    height: 0;
    border-left: 50px solid transparent;
    border-right: 50px solid transparent;
    border-bottom: 100px solid red;
&#125;
div &#123;
    width:0px;
    height:0px;
    border-width:20px;
    border-style:solid;
    border-color:transparent transparent green transparent;
&#125;
左右两边边长为50透明
上边边长100
显示出来的就是一个红色面积的三角</code></pre>
<h4 id="css-选择器有哪些-以及优先级-可以继承的属性"><a href="#css-选择器有哪些-以及优先级-可以继承的属性" class="headerlink" title="css 选择器有哪些,以及优先级,可以继承的属性"></a>css 选择器有哪些,以及优先级,可以继承的属性</h4><pre><code>id选择器（#id）
类选择器（.class）
标签选择器（div、p、li）
子代选择器（ul&gt;li）
后代选择器（ul li）
通配符选择器（*）
&lt;属性选择器（input[type=&quot;text&quot;]、p[class]）
伪类选择器（li:first-child、li:nth-child(n)）
&lt;相邻兄弟选择器（div+p）
&lt;通用兄弟选择器（div~p）
&lt;群组选择器（div,span,li,p）

相同权重下：内联样式（标签内部） &gt; 嵌入样式（当前文件style） &gt; 外部样式（外部文件）
可以继承的属性：

可继承的样式： font-size font-family color, UL LI DL DD DT;
不可继承的样式：border padding margin width height ;

优先级：!important &gt; id &gt; class &gt; tag
important 比 内联优先级高,但内联比 id 要高</code></pre>
<h4 id="内容水平垂直居中有哪些方法"><a href="#内容水平垂直居中有哪些方法" class="headerlink" title="内容水平垂直居中有哪些方法"></a>内容水平垂直居中有哪些方法</h4><pre><code>文本居中：text-align:center; height:100px; line-height:100px;

已知宽高：如width:20px;height:20px 

父级position:relative 内容position:absolute; left: 50%; top: 50%; margin-left:-10px; margin-top: -10px;

不知宽高：

父级position:relative 内容position:absolute; left: 50%; top: 50%; transform: translate(-50%, -50%)

父级display:flex; align-items: center; justify-content: center; (css3属性)

父级display:table; 子级 display: table-cell; vertical-align: middle;</code></pre>
<h4 id="display-none-和-visibility-hidden-有什么区别"><a href="#display-none-和-visibility-hidden-有什么区别" class="headerlink" title="display: none 和 visibility: hidden 有什么区别"></a>display: none 和 visibility: hidden 有什么区别</h4><pre><code>display: none 隐藏 不占空间 （回流 + 重绘）
visibility: hidden 隐藏 保留原有空间 （重绘）</code></pre>
<h4 id="回流与重绘"><a href="#回流与重绘" class="headerlink" title="回流与重绘"></a>回流与重绘</h4><h5 id="一、什么是回流"><a href="#一、什么是回流" class="headerlink" title="一、什么是回流?"></a>一、什么是回流?</h5><pre><code>当我们对 DOM 的修改引发了 DOM 几何尺寸的变化（比如修改元素的宽、高或隐藏元素等）时，浏览器需要重新计算元素的几何属性（其他元素的几何属性和位置也会因此受到影响），
然后再将计算的结果绘制出来。这个过程就是回流（也叫重排）。每个页面都至少发生一次回流，也就是页面第一次加载的时候。</code></pre>
<h5 id="二、什么是重绘"><a href="#二、什么是重绘" class="headerlink" title="二、什么是重绘?"></a>二、什么是重绘?</h5><pre><code>当我们对 DOM 的修改导致了样式的变化、却并未影响其几何属性（比如修改了颜色或背景色）时，
浏览器不需重新计算元素的几何属性、直接为该元素绘制新的样式（跳过了上图所示的回流环节）。这个过程叫做重绘。</code></pre>
<h5 id="三、两者的区别"><a href="#三、两者的区别" class="headerlink" title="三、两者的区别?"></a>三、两者的区别?</h5><pre><code>他们的区别很大：
回流必将引起重绘，而重绘不一定会引起回流。比如：只有颜色改变的时候就只会发生重绘而不会引起回流
当页面布局和几何属性改变时就需要回流
比如：添加或者删除可见的DOM元素，元素位置改变，元素尺寸改变——边距、填充、边框、宽度和高度，内容改变</code></pre>
<h5 id="四、什么时候会发生回流？"><a href="#四、什么时候会发生回流？" class="headerlink" title="四、什么时候会发生回流？"></a>四、什么时候会发生回流？</h5><pre><code>1、添加或者删除可见的DOM元素的时候
2、元素的位置发生改变
3、元素尺寸改变
4、内容改变
5、页面第一次渲染的时候</code></pre>
<h5 id="五、如何减少回流和重绘？"><a href="#五、如何减少回流和重绘？" class="headerlink" title="五、如何减少回流和重绘？"></a>五、如何减少回流和重绘？</h5><pre><code>1、使用 transform 替代 top
2、使用 visibility 替换 display: none。因为前者只会引起重绘，后者会引发回流（改变了布局）
3、不要把节点的属性值放在一个循环里当成循环里的变量
4、不要使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局
5、动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使用requestAnimationFrame
6、CSS 选择符从右往左匹配查找，避免节点层级过多</code></pre>
<h4 id="列出display的值。position的值-relative和absolute分别是相对于谁进行定位的"><a href="#列出display的值。position的值-relative和absolute分别是相对于谁进行定位的" class="headerlink" title="列出display的值。position的值,relative和absolute分别是相对于谁进行定位的?"></a>列出display的值。position的值,relative和absolute分别是相对于谁进行定位的?</h4><pre><code>block 象块类型元素一样显示。
inline 缺省值。象行内元素类型一样显示。
inline-block 象行内元素一样显示，但其内容象块类型元素一样显示。
list-item 象块类型元素一样显示，并添加样式列表标记。

absolute 
    生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。 
fixed （老IE不支持）
    生成绝对定位的元素，相对于浏览器窗口进行定位。 
relative 
    生成相对定位的元素，相对于其在普通流中的位置进行定位。 
 static  默认值。没有定位，元素出现在正常的流中
（忽略 top, bottom, left, right z-index 声明）。
 inherit 规定从父元素继承 position 属性的值。</code></pre>
<h4 id="CSS3新特性有哪些？"><a href="#CSS3新特性有哪些？" class="headerlink" title="CSS3新特性有哪些？"></a>CSS3新特性有哪些？</h4><pre><code>1.颜色：新增RGBA，HSLA模式
2.文字阴影（text-shadow、）
3.边框： 圆角（border-radius）边框阴影： box-shadow
4.盒子模型：box-sizing
5.背景：background-size 设置背景图片的尺寸background-origin 设置背景图片的原点background-clip 设置背景图片的裁切区域，以”，”分隔可以设置多背景，用于自适应布局
6.渐变：linear-gradient、radial-gradient
7.过渡：transition，可实现动画
8.自定义动画
9.在CSS3中唯一引入的伪元素是 ：selection.
10.媒体查询，多栏布局
11.border-image
12.2D转换：transform：translate(x，y) rotate(x，y) skew(x，y) scale(x，y)
13.3D转换</code></pre>
<h4 id="css3新增的伪类"><a href="#css3新增的伪类" class="headerlink" title="css3新增的伪类"></a>css3新增的伪类</h4><pre><code>:nth-child(n)选中父元素下的第n个子元素。
p:first-of-type 选择父元素的首个 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。
p:last-of-type 选择父元素的最后 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。
p:only-of-type 选择父元素唯一的 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。
p:only-child 选择父元素的唯一子元素的每个 &lt;p&gt; 元素。 p:nth-child(2) 选择属于其父元素的第二个子元素的每个 &lt;p&gt; 元素。
:enabled、:disabled:控制表单的禁用状态。
:checked，单选框或复选框被选中。html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？</code></pre>
<h4 id="css3中单位px-em-rem-vh-vw-vmin-vmax的区别"><a href="#css3中单位px-em-rem-vh-vw-vmin-vmax的区别" class="headerlink" title="css3中单位px,em,rem,vh,vw,vmin,vmax的区别"></a>css3中单位px,em,rem,vh,vw,vmin,vmax的区别</h4><pre><code>px：绝对单位，页面按精确像素展示

em：相对单位，基准点为父节点字体的大小，如果自身定义了font-size按自身来计算（浏览器默认字体是16px），整个页面内1em不是一个固定的值。

rem：相对单位，可理解为”root em”, 相对根节点html的字体大小来计算，CSS3新加属性，chrome/firefox/IE9+支持。

vw：viewpoint width，视窗宽度，1vw等于视窗宽度的1%。
vh：viewpoint height，视窗高度，1vh等于视窗高度的1%。
vmin：vw和vh中较小的那个。
vmax：vw和vh中较大的那个。

vw, vh, vmin, vmax：IE9+局部支持，chrome/firefox/safari/opera支持，ios safari 8+支持，android browser4.4+支持，chrome for android39支持

viewport的概念

移动设备上的viewport就是设备的屏幕上能用来显示我们的网页的那一块区域.

就是浏览器上(也可能是一个app中的webview)用来显示网页的那部分区域，但viewport又不局限于浏览器可视区域的大小，它可能比浏览器的可视区域要大，也可能比浏览器的可视区域要小。</code></pre>
<h4 id="CSS隐藏元素的几种方法"><a href="#CSS隐藏元素的几种方法" class="headerlink" title="CSS隐藏元素的几种方法"></a>CSS隐藏元素的几种方法</h4><pre><code>1、display:none;
被隐藏的元素不占位置，看不见摸不着，它会导致浏览器的重排和重绘。
2、visibility:hidden;
和display:none的区别是它占位置，看不见但是摸得着，它会导致浏览器重绘而不重排。
3、opacity:0;
这种方法也是只能隐藏看不见元素，和visibility:hidden一样，元素依然存在页面中。
4、position；
利用定位将元素的top和left值设为足够大的负数，使它移出屏幕在屏幕上看不见。
5、overflow:hidden；
这个是超出盒子的部分隐藏，有局限性。</code></pre>
<h4 id="解释下CSS-sprites-以及你要如何在页面或网站中使用它"><a href="#解释下CSS-sprites-以及你要如何在页面或网站中使用它" class="headerlink" title="解释下CSS  sprites,以及你要如何在页面或网站中使用它"></a>解释下CSS  sprites,以及你要如何在页面或网站中使用它</h4><pre><code>CSS Sprites其实就是把网页中一些背景图片整合到一张图片文件中，再利用CSS的“background-image”，“background- repeat”，“background-position”的组合进行背景定位，
background-position可以用数字能精确的定位出背景图片的位置。这样可以减少很多图片请求的开销，因为请求耗时比较长；请求虽然可以并发，
但是也有限制，一般浏览器都是6个。对于未来而言，就不需要这样做了，因为有了(`http2`)。</code></pre>
<h4 id="讨论CSS-hacks-条件引用或者其他"><a href="#讨论CSS-hacks-条件引用或者其他" class="headerlink" title="讨论CSS hacks, 条件引用或者其他"></a>讨论CSS hacks, 条件引用或者其他</h4><ul>
<li><p>hacks</p>
  <pre class="language-none"><code class="language-none">_width针对于ie6。*width,+width针对于ie6,7。
color: red\9;&#x2F;*IE8以及以下版本浏览器*&#x2F;（但是测试可以兼容到ie10。
*+html与*html是IE特有的标签, firefox暂不支持.而*+html又为IE7特有标签（但是测试*html兼容ie6-10。*+兼容ie7-10）。
!important 在IE中会被忽视，ie6,7,8不识别，ie9+（包括ie9）是识别的。</code></pre></li>
<li><p>条件引用</p>
  <pre class="language-none"><code class="language-none">&lt;!--[if !IE]&gt;&lt;!--&gt; 除IE外都可识别 &lt;!--&lt;![endif]--&gt;
&lt;!--[if IE]&gt; 所有的IE可识别 &lt;![endif]--&gt;
&lt;!--[if IE 6]&gt; 仅IE6可识别 &lt;![endif]--&gt;
&lt;!--[if lt IE 6]&gt; IE6以及IE6以下版本可识别 &lt;![endif]--&gt;
&lt;!--[if gte IE 6]&gt; IE6以及IE6以上版本可识别 &lt;![endif]--&gt;
&lt;!--[if IE 7]&gt; 仅IE7可识别 &lt;![endif]--&gt;
&lt;!--[if lt IE 7]&gt; IE7以及IE7以下版本可识别 &lt;![endif]--&gt;
&lt;!--[if gte IE 7]&gt; IE7以及IE7以上版本可识别 &lt;![endif]--&gt;
&lt;!--[if IE 8]&gt; 仅IE8可识别 &lt;![endif]--&gt;
&lt;!--[if IE 9]&gt; 仅IE9可识别 &lt;![endif]--&gt;</code></pre>

</li>
</ul>
<h4 id="css预编译"><a href="#css预编译" class="headerlink" title="css预编译"></a>css预编译</h4><pre><code>就是预先编译处理CSS。它扩展了 CSS 语言，增加了变量、Mixin、函数等编程的特性，使 CSS 更易维护和扩展。
CSS预编译的工作原理是提供便捷的语法和特性供开发者编写源代码，随后经过专门的编译工具将源码转化为CSS语法。
它从这几个方面提升了CSS开发的效率：增强编程能力；增强可复用性；增强可维护性；更便于解决浏览器兼容性。</code></pre>
<h5 id="为什么要用css预编译"><a href="#为什么要用css预编译" class="headerlink" title="为什么要用css预编译"></a>为什么要用css预编译</h5><pre><code>优点：
    可以提供 CSS 缺失的样式层复用机制、减少冗余代码，提高样式代码的可维护性。大大提高了开发效率。
缺点：
    调试更麻烦；
    容易造成后代选择器的滥用</code></pre>
<h5 id="css的缺点"><a href="#css的缺点" class="headerlink" title="css的缺点"></a>css的缺点</h5><pre><code>语法不够强大，比如无法嵌套书写，导致模块化开发中需要书写很多重复的选择器；
没有变量和合理的样式复用机制，使得逻辑上相关的属性值必须以字面量的形式重复输出，导致难以维护。</code></pre>
<h5 id="主流CSS预编译器的介绍"><a href="#主流CSS预编译器的介绍" class="headerlink" title="主流CSS预编译器的介绍"></a>主流CSS预编译器的介绍</h5><p>1.Sass</p>
<p>2007年诞生，最早也是最成熟的CSS预处理器，拥有ruby社区的支持和compass这一最强大的CSS框架，目前受LESS影响，已经进化到了全面兼容CSS的SCSS。<br>其实现在的Sass已经有了两套语法规则：一个依旧是用缩进作为分隔符来区分代码块的；另一套规则和CSS一样采用了大括号（｛｝）作为分隔符。<br>后一种语法规则又名SCSS，在Sass3之后的版本都支持这种语法规则。</p>
<pre><code>优点：
    用户多，更容易找到会用scss的开发，更容易找到scss的学习资源；
    可编程能力比较强，支持函数，列表，对象，判断，循环等；
    相比less有更多的功能；
    Bootstrap/Foundation等使用scss；
    丰富的sass库：Compass/Bourbon；
缺点：
    安装node-sass会经常失败或者报错，需要使用cnpm或者手工安装</code></pre>
<p>Sass中文文档：<a target="_blank" rel="noopener" href="http://sass.bootcss.com/">http://sass.bootcss.com/</a></p>
<p>2.Less</p>
<p>2009年出现，受SASS的影响较大，但又使用CSS的语法，让大部分开发者和设计师更容易上手，在ruby社区之外支持者远超过SASS，其缺点是比起SASS来，可编程功能不够，不过优点是简单和兼容CSS，反过来也影响了SASS演变到了SCSS的时代，著名的Twitter Bootstrap就是采用LESS做底层语言的。</p>
<pre><code>优点：
    可以在浏览器中运行，实现主题定制功能；
缺点：
    编程能力弱，不直接支持对象，循环，判断等；
    @variable 变量命名和css的@import/media/keyframes等含义容易混淆；
    mixin/extend的语法比较奇怪；s
    mixin的参数如果遇到多参数和列表参数值的时候容易混淆；</code></pre>
<p>Less中文文档：<a target="_blank" rel="noopener" href="https://less.bootcss.com/">https://less.bootcss.com/</a></p>
<p>3.Stylus</p>
<p>2010年产生，来自Node.js社区，主要用来给Node项目进行CSS预处理支持，在此社区之内有一定支持者，在广泛的意义上人气还完全不如SASS和LESS<br>Stylus被称为是一种革命性的新语言，提供一个高效、动态、和使用表达方式来生成CSS，以供浏览器使用。Stylus同时支持缩进和CSS常规样式书写规则。</p>
<pre><code>优点：
    来自NodeJS社区，所以和NodeJS走得很近，与JavaScript联系非常紧密。还有专门JavaScript API：
    http://learnboost.github.io/stylus/docs/js.html
    支持Ruby之类等等框架3.更多更强大的支持和功能
缺点：
    人气不高，教程较少</code></pre>
<p>Stylus官方文档：<a target="_blank" rel="noopener" href="http://stylus-lang.com/">http://stylus-lang.com/</a><br>Stylus 中文文档：<a target="_blank" rel="noopener" href="https://www.zhangxinxu.com/jq/stylus/">https://www.zhangxinxu.com/jq/stylus/</a></p>
<h5 id="Sass和Less的比较"><a href="#Sass和Less的比较" class="headerlink" title="Sass和Less的比较"></a>Sass和Less的比较</h5><p>不同之处</p>
<p>1、Less环境较Sass简单</p>
<pre><code>Cass的安装需要安装Ruby环境，Less基于JavaScript，是需要引入Less.js来处理代码输出css到浏览器，也可以在开发环节使用Less，然后编译成css文件，
直接放在项目中，有less.app、SimpleLess、CodeKit.app这样的工具，也有在线编辑地址。</code></pre>
<p>2、Less使用较Sass简单</p>
<pre><code>LESS 并没有裁剪 CSS 原有的特性，而是在现有 CSS 语法的基础上，为 CSS 加入程序式语言的特性。只要你了解 CSS 基础就可以很容易上手。</code></pre>
<p>3、从功能出发，Sass较Less略强大一些</p>
<pre><code>①sass有变量和作用域。
- $variable，like php；
- #｛$variable｝like ruby；
- 变量有全局和局部之分，并且有优先级。


②sass有函数的概念；
- @function和@return以及函数参数（还有不定参）可以让你像js开发那样封装你想要的逻辑。
-@mixin类似function但缺少像function的编程逻辑，更多的是提高css代码段的复用性和模块化，这个用的人也是最多的。
-ruby提供了非常丰富的内置原生api。

③进程控制：
-条件：@if @else；
-循环遍历：@for @each @while
-继承：@extend
-引用：@import

④数据结构：
-$list类型=数组；
-$map类型=object；
其余的也有string、number、function等类型</code></pre>
<p>4、Less与Sass处理机制不一样</p>
<pre><code>前者是通过客户端处理的，后者是通过服务端处理，相比较之下前者解析会比后者慢一点</code></pre>
<p>5、关于变量在Less和Sass中的唯一区别就是Less用@，Sass用$。</p>
<p>相同之处</p>
<p>Less和Sass在语法上有些共性，比如下面这些：</p>
<pre><code>1、混入(Mixins)——class中的class；
2、参数混入——可以传递参数的class，就像函数一样；
3、嵌套规则——Class中嵌套class，从而减少重复的代码；
4、运算——CSS中用上数学；
5、颜色功能——可以编辑颜色；
6、名字空间(namespace)——分组样式，从而可以被调用；
7、作用域——局部修改样式；
8、JavaScript 赋值——在CSS中使用JavaScript表达式赋值。</code></pre>
<h4 id="为什么选择使用Sass而不是Less？"><a href="#为什么选择使用Sass而不是Less？" class="headerlink" title="为什么选择使用Sass而不是Less？"></a>为什么选择使用Sass而不是Less？</h4><pre><code>1、Sass在市面上有一些成熟的框架，比如说Compass，而且有很多框架也在使用Sass，比如说Foundation。

2、就国外讨论的热度来说，Sass绝对优于LESS。
3、就学习教程来说，Sass的教程要优于LESS。在国内LESS集中的教程是LESS中文官网，而Sass的中文教程，慢慢在国内也较为普遍。

4、Sass也是成熟的CSS预处理器之一，而且有一个稳定，强大的团队在维护。

5、同时还有Scss对sass语法进行了改良，Sass 3就变成了Scss(sassy css)。与原来的语法兼容，只是用&#123;&#125;取代了原来的缩进。

6、bootstrap（Web框架）最新推出的版本4，使用的就是Sass。</code></pre>
<h3 id="二、html"><a href="#二、html" class="headerlink" title="二、html"></a>二、html</h3><h4 id="常用那几种浏览器测试？有哪些内核-Layout-Engine"><a href="#常用那几种浏览器测试？有哪些内核-Layout-Engine" class="headerlink" title="常用那几种浏览器测试？有哪些内核(Layout Engine)?"></a>常用那几种浏览器测试？有哪些内核(Layout Engine)?</h4><pre><code>浏览器：IE，Chrome，FireFox，Safari，Opera。
　　 内核：Trident，Gecko，Presto，Webkit。</code></pre>
<h4 id="HTML5-为什么只需要写-lt-DOCTYPE-html-gt-？"><a href="#HTML5-为什么只需要写-lt-DOCTYPE-html-gt-？" class="headerlink" title="HTML5 为什么只需要写&lt;!　DOCTYPE html&gt; ？"></a>HTML5 为什么只需要写&lt;!　DOCTYPE html&gt; ？</h4><pre><code>HTML5不基于 SGML，因此不需要对DTD进行引用，但是需要doctype来规范浏览器的行为（让浏览器按照它们应该的方式来运行）。
而HTML4.01基于SGML,所以需要对DTD进行引用，才能告知浏览器文档所使用的文档类型。</code></pre>
<h4 id="html5有哪些新特性？"><a href="#html5有哪些新特性？" class="headerlink" title="html5有哪些新特性？"></a>html5有哪些新特性？</h4><p>HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。</p>
<pre><code>(1)拖拽释放(Drag and drop) API
(2)视频和音频  用于媒介回放的 video 和 audio 元素;
(3)画布(Canvas) API
(4)地理(Geolocation) API
(5)本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失;
(6)sessionStorage 的数据在浏览器关闭后自动删除;
(7)语意化更好的内容标签，比如 （article、footer、header、nav、section、aside）;
(8)表单控件，calendar、date、time、email、url、search;
(9)新的技术webworker, websocket, Geolocation;</code></pre>
<p>IE8/IE7/IE6支持通过document.createElement方法产生的标签， 可以利用这一特性让这些浏览器支持HTML5新标签， 浏览器支持新标签后，还需要添加标签默认的样式</p>
<h4 id="请写出一些前端性能优化的方式"><a href="#请写出一些前端性能优化的方式" class="headerlink" title="请写出一些前端性能优化的方式"></a>请写出一些前端性能优化的方式</h4><pre><code>1.减少http请求
 合并压缩css样式表和js脚本
 去掉不必要的请求，开发写代码或者系统升级之后残留的无效请求连接
 充分利用缓存：来减少向服务器发送的请求数，节省网络资源，所有静态资源都要放在服务器端并设置缓存，并且要尽量使用长缓存
2.同时在代码中进行图片的延迟加载，也叫做赖加载
3.尽量使用字体图标代替图片
4.优化js代码结构，减少冗余代码
5.开启Gzip代码压缩
6.用transform:translate 代替 position  left、right...以此来尽量减少回流和重绘。
7.尽量使用id选择器：id选择器选择元素是最快的，具有唯一性，灵活性和优先性的优点
8.减少dom节点
9.使用内容分发cdn加速</code></pre>
<h4 id="请说出三种减少页面加载时间的方法。"><a href="#请说出三种减少页面加载时间的方法。" class="headerlink" title="请说出三种减少页面加载时间的方法。"></a>请说出三种减少页面加载时间的方法。</h4><pre><code>1.优化图片 
2.图像格式的选择（GIF：提供的颜色较少，可用在一些对颜色要求不高的地方） 
3.优化CSS（压缩合并css，如margin-top,margin-left...) 
4.网址后加斜杠（如www.campr.com/目录，会判断这个“目录是什么文件类型，或者是目录。） 
5.标明高度和宽度（如果浏览器没有找到这两个参数，它需要一边下载图片一边计算大小，如果图片很多，浏览器需要不断地调整页面。这不但影响速度，也影响浏览体验。 
当浏览器知道了高度和宽度参数后，即使图片暂时无法显示，页面上也会腾出图片的空位，然后继续加载后面的内容。从而加载时间快了，浏览体验也更好了。） 
6.减少http请求（合并文件，合并图片）。</code></pre>
<h4 id="线程与进程的区别"><a href="#线程与进程的区别" class="headerlink" title="线程与进程的区别"></a>线程与进程的区别</h4><pre><code>一个程序至少有一个进程,一个进程至少有一个线程. 
线程的划分尺度小于进程，使得多线程程序的并发性高。 
另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。 
线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。 
从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。</code></pre>
<h4 id="页面导入样式时，使用link和-import有什么区别？"><a href="#页面导入样式时，使用link和-import有什么区别？" class="headerlink" title="页面导入样式时，使用link和@import有什么区别？"></a>页面导入样式时，使用link和@import有什么区别？</h4><pre><code>（1）本质的差别：link属于XHTML标签，除了加载CSS外，还能用于定义RSS, 定义rel连接属性等作用；而@import是CSS提供的，只能用于加载CSS;
（2）加载顺序的差别：页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载;所以在 @import加载CSS的时候，一开始会没有样式。
（3）兼容性的差别：import是CSS2.1 提出的，只在IE5以上才能被识别，而link是XHTML标签，无兼容问题。
（4）使用DOM文档对象模型控制样式的差别：当使用JavaScript控制DOM区改变样式的时候，只能使用link标签，而@import是不可以的。
（5）作用不同：link是属于XHTML，除了可以加载css,还可以定义RSS等其它事务，而@import是属于css范畴，只能加载css。
（6）权重不同：link方式的权重高于@import的权重值。
（7）标签不同：import在html使用的时候需要标签，而link在html使用的时候不需要标签。</code></pre>
<h4 id="在HTML当中引用CSS的三种使用方式有哪些？它们之间的区别是什么？"><a href="#在HTML当中引用CSS的三种使用方式有哪些？它们之间的区别是什么？" class="headerlink" title="在HTML当中引用CSS的三种使用方式有哪些？它们之间的区别是什么？"></a>在HTML当中引用CSS的三种使用方式有哪些？它们之间的区别是什么？</h4><pre><code>在HTML当中引用CSS的三种使用方式：
    1） 第一种是内联样式表，样式通过style属性内嵌在css的样式当中，写在标签当中。
    2） 第二种是内部样式表，通过style标签将CSS的样式写在style属性当中，链入内部的CSS文件。
    3） 第三种是外部样式表，通过link标签或者是在style中通过@import的方式引入外部的CSS样式文件。

它们之间的区别：
    1） 优先级不同，内联样式表的优先级最高，而内部样式表和外部样式表的优先级与书写顺序有关，后书写的优先级高。
    2） 作用域不同，内联样式表的作用域最小，只能应用于当前的元素，内部样式表的作用域其次，只能应用于当前的HTML文件，最后是外部样式表的作用域最大，能够适用于所有链接的HTML文件。
    3）书写顺序不同，内联样式表写在标签当中，内部样式表写在style标签中来链入内部的CSS文件，外部样式表是通过link或者是@import的方式来链入外部的CSS文件。</code></pre>
<h4 id="简述一下你对HTML语义化的理解？"><a href="#简述一下你对HTML语义化的理解？" class="headerlink" title="简述一下你对HTML语义化的理解？"></a>简述一下你对HTML语义化的理解？</h4><pre><code>用正确的标签做正确的事情。
html语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析;
即使在没有样式CSS情况下也以一种文档格式显示，并且是容易阅读的;
搜索引擎的爬虫也依赖于HTML标记来确定上下文和各个关键字的权重，利于SEO;
使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。</code></pre>
<h4 id="如何实现浏览器内多个标签页之间的通信"><a href="#如何实现浏览器内多个标签页之间的通信" class="headerlink" title="如何实现浏览器内多个标签页之间的通信?"></a>如何实现浏览器内多个标签页之间的通信?</h4><pre><code>调用localstorge、cookies等本地存储方式</code></pre>
<h4 id="webSocket如何兼容低浏览器？"><a href="#webSocket如何兼容低浏览器？" class="headerlink" title="webSocket如何兼容低浏览器？"></a>webSocket如何兼容低浏览器？</h4><pre><code>Adobe Flash Socket 、 ActiveX HTMLFile (IE) 、 基于 multipart 编码发送 XHR 、 基于长轮询的 XHR</code></pre>
<h4 id="iframe的优缺点？"><a href="#iframe的优缺点？" class="headerlink" title="iframe的优缺点？"></a>iframe的优缺点？</h4><pre><code>1.&lt;iframe&gt;优点：
    解决加载缓慢的第三方内容如图标和广告等的加载问题
    Security sandbox
    并行加载脚本
2.&lt;iframe&gt;的缺点：
    *iframe会阻塞主页面的Onload事件；
    *即时内容为空，加载也需要时间
    *没有语意
iframe会阻塞主页面的Onload事件；
搜索引擎的检索程序无法解读这种页面，不利于SEO;
iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。
使用iframe之前需要考虑这两个缺点。如果需要使用iframe，最好是通过javascript动态给iframe添加src属性值，这样可以绕开以上两个问题。</code></pre>
<h4 id="网页布局有哪几种，有什么区别"><a href="#网页布局有哪几种，有什么区别" class="headerlink" title="网页布局有哪几种，有什么区别"></a>网页布局有哪几种，有什么区别</h4><pre><code>静态、自适应、流式、响应式四种网页布局
静态布局：意思就是不管浏览器尺寸具体是多少，网页布局就按照当时写代码的布局来布置；
自适应布局：就是说你看到的页面，里面元素的位置会变化而大小不会变化；
流式布局：你看到的页面，元素的大小会变化而位置不会变化——这就导致如果屏幕太大或者太小都会导致元素无法正常显示。
自适应布局：每个屏幕分辨率下面会有一个布局样式，同时位置会变而且大小也会变。</code></pre>
<h4 id="怎么让Chrome支持小于12px-的文字？"><a href="#怎么让Chrome支持小于12px-的文字？" class="headerlink" title="怎么让Chrome支持小于12px 的文字？"></a>怎么让Chrome支持小于12px 的文字？</h4><pre><code>针对谷歌浏览器内核，加webkit前缀，用transform:scale()这个属性进行缩放！
<pre class="language-none"><code class="language-none">&lt;style&gt;
    span&#123;
        font-size:10px;
        -webkit-transform:scale(0.8);
        display:block;
    &#125;
&lt;&#x2F;style&gt;</code></pre></code></pre>
<h4 id="Doctype作用-严格模式与混杂模式如何区分？它们有何意义"><a href="#Doctype作用-严格模式与混杂模式如何区分？它们有何意义" class="headerlink" title="Doctype作用? 严格模式与混杂模式如何区分？它们有何意义?"></a>Doctype作用? 严格模式与混杂模式如何区分？它们有何意义?</h4><pre><code>（1）、&lt;!DOCTYPE&gt; 声明位于文档中的最前面，处于 &lt;html&gt; 标签之前。告知浏览器以何种模式来渲染文档。 
（2）、严格模式的排版和 JS 运作模式是  以该浏览器支持的最高标准运行。
（3）、在混杂模式中，页面以宽松的向后兼容的方式显示。模拟老式浏览器的行为以防止站点无法工作。
（4）、DOCTYPE不存在或格式不正确会导致文档以混杂模式呈现。</code></pre>
<h4 id="Doctype文档类型？"><a href="#Doctype文档类型？" class="headerlink" title="Doctype文档类型？"></a>Doctype文档类型？</h4><pre><code>该标签可声明三种 DTD 类型，分别表示严格版本、过渡版本以及基于框架的 HTML 文档。
HTML 4.01 规定了三种文档类型：Strict、Transitional 以及 Frameset。
XHTML 1.0 规定了三种 XML 文档类型：Strict、Transitional 以及 Frameset。
Standards （标准）模式（也就是严格呈现模式）用于呈现遵循最新标准的网页，而 Quirks
（包容）模式（也就是松散呈现模式或者兼容模式）用于呈现为传统浏览器而设计的网页。</code></pre>
<h4 id="HTML与XHTML——二者有什么区别"><a href="#HTML与XHTML——二者有什么区别" class="headerlink" title="HTML与XHTML——二者有什么区别"></a>HTML与XHTML——二者有什么区别</h4><pre><code>1.所有的标记都必须要有一个相应的结束标记
2.所有标签的元素和属性的名字都必须使用小写
3.所有的XML标记都必须合理嵌套
4.所有的属性必须用引号&quot;&quot;括起来
5.把所有&lt;和&amp;特殊符号用编码表示
6.给所有属性赋一个值
7.不要在注释内容中使“--”
8.图片必须有说明文字</code></pre>
<h4 id="常见兼容性问题？"><a href="#常见兼容性问题？" class="headerlink" title="常见兼容性问题？"></a>常见兼容性问题？</h4><pre><code>1、png24位的图片在iE6浏览器上出现背景，解决方案是做成PNG8.也可以引用一段脚本处理.
2、浏览器默认的margin和padding不同。解决方案是加一个全局的*&#123;margin:0;padding:0;&#125;来统一。
3、IE6双边距bug:块属性标签float后，又有横行的margin情况下，在ie6显示margin比设置的大。 
4、浮动ie产生的双倍距离（IE6双边距问题：在IE6下，如果对元素设置了浮动，同时又设置了margin-left或margin-right，margin值会加倍。）
#box&#123; float:left; width:10px; margin:0 0 0 100px;&#125; 
这种情况之下IE会产生20px的距离，解决方案是在float的标签样式控制中加入 ——_display:inline;将其转化为行内属性。(_这个符号只有ie6会识别)
5、渐进识别的方式，从总体中逐渐排除局部。 
首先，巧妙的使用“\9”这一标记，将IE游览器从所有情况中分离出来。 
接着，再次使用“+”将IE8和IE7、IE6分离开来，这样IE8已经独立识别。</code></pre>
<pre class="language-none"><code class="language-none">.bb&#123;
    background-color:#f1ee18;&#x2F;*所有识别*&#x2F;
    .background-color:#00deff\9; &#x2F;*IE6、7、8识别*&#x2F;
    +background-color:#a200ff;&#x2F;*IE6、7识别*&#x2F;
    _background-color:#1e0bd1;&#x2F;*IE6识别*&#x2F; 
&#125; </code></pre>
<pre><code>6、IE下,可以使用获取常规属性的方法来获取自定义属性,
    也可以使用getAttribute()获取自定义属性;
    Firefox下,只能使用getAttribute()获取自定义属性. 
    解决方法:统一通过getAttribute()获取自定义属性.

7、IE下,event对象有x,y属性,但是没有pageX,pageY属性; 
    Firefox下,event对象有pageX,pageY属性,但是没有x,y属性.
    解决方法：（条件注释）缺点是在IE浏览器下可能会增加额外的HTTP请求数。
8、Chrome 中文界面下默认会将小于 12px 的文本强制按照 12px 显示, 可通过加入 CSS 属性 -webkit-text-size-adjust: none; 解决.

9、超链接访问过后hover样式就不出现了 被点击访问过的超链接样式不在具有hover和active了解决方法是改变CSS属性的排列顺序:
    L-V-H-A :  a:link &#123;&#125; a:visited &#123;&#125; a:hover &#123;&#125; a:active &#123;&#125;
10、怪异模式问题：漏写DTD声明，Firefox仍然会按照标准模式来解析网页，但在IE中会触发怪异模式。为避免怪异模式给我们带来不必要的麻烦，最好养成书写DTD声明的好习惯。
    现在可以使用[html5](http://www.w3.org/TR/html5/single-page.html)推荐的写法：`&lt;doctype html&gt;`
11、上下margin重合问题
    ie和ff都存在，相邻的两个div的margin-left和margin-right不会重合，但是margin-top和margin-bottom却会发生重合。
    解决方法，养成良好的代码编写习惯，同时采用margin-top或者同时采用margin-bottom。
12、ie6对png图片格式支持不好(引用一段脚本处理)</code></pre>
<h4 id="如何对网站的文件和资源进行优化？"><a href="#如何对网站的文件和资源进行优化？" class="headerlink" title="如何对网站的文件和资源进行优化？"></a>如何对网站的文件和资源进行优化？</h4><pre><code>1.文件合并
2.文件最小化/文件压缩
3.使用 CDN 托管
4.缓存的使用（多个域名来提供缓存）</code></pre>
<h4 id="什么是-FOUC（无样式内容闪烁）？你如何来避免-FOUC？"><a href="#什么是-FOUC（无样式内容闪烁）？你如何来避免-FOUC？" class="headerlink" title="什么是 FOUC（无样式内容闪烁）？你如何来避免 FOUC？"></a>什么是 FOUC（无样式内容闪烁）？你如何来避免 FOUC？</h4><pre class="language-none"><code class="language-none">FOUC - Flash Of Unstyled Content 文档样式闪烁
 &lt;style type&#x3D;&quot;text&#x2F;css&quot; media&#x3D;&quot;all&quot;&gt;@import &quot;..&#x2F;fouc.css&quot;;&lt;&#x2F;style&gt; 
而引用CSS文件的@import就是造成这个问题的罪魁祸首。IE会先加载整个HTML文档的DOM，然后再去导入外部的CSS文件，
因此，在页面DOM加载完成到CSS导入完成中间会有一段时间页面上的内容是没有样式的，这段时间的长短跟网速，电脑速度都有关系。
解决方法简单的出奇，只要在&lt;head&gt;之间加入一个&lt;link&gt;或者&lt;script&gt;元素就可以了。</code></pre>
<h4 id="在form表单中，get方式和post方式提交数据的区别是什么？如何判断在实际开发中的应用？"><a href="#在form表单中，get方式和post方式提交数据的区别是什么？如何判断在实际开发中的应用？" class="headerlink" title="在form表单中，get方式和post方式提交数据的区别是什么？如何判断在实际开发中的应用？"></a>在form表单中，get方式和post方式提交数据的区别是什么？如何判断在实际开发中的应用？</h4><pre><code>get方式和post方式提交数据的区别：
1） 大小不同，get方式传输的数据量较小，而post可以传输大量的数据。
2） 安全程度不同，get方式传输数据能够被别人轻易的看到数据内容，所以安全程度较低，而post则可以很好的隐藏。
3） 速度不同，post方式速度较慢，而get方式速度较快。
4） 在服务器上的作用不同，get是从服务器上获取数据，而post是向服务器上传送数据。

在实际开发中的应用：
1）在重要数据进行传输数据的时候，用post的方式进行提交数据。
2）在做数据查询的时候，用get的方式进行提交数据。
3）在做增加、删除和修改数据的时候，用post的方式进行提交数据。</code></pre>
<h4 id="在input表单控件中，value和placeholder的区别是什么？"><a href="#在input表单控件中，value和placeholder的区别是什么？" class="headerlink" title="在input表单控件中，value和placeholder的区别是什么？"></a>在input表单控件中，value和placeholder的区别是什么？</h4><pre><code>placeholder: 表示在输入框中显示的提示信息，用户点击之后，提示信息就会消失。
value: 叫做默认值，当用户想要在输入框中输入信息的时候，必须先手动的删除value的值 。</code></pre>
<h2 id="二、js-部分"><a href="#二、js-部分" class="headerlink" title="二、js 部分"></a>二、js 部分</h2><h3 id="js是什么语言"><a href="#js是什么语言" class="headerlink" title="js是什么语言"></a>js是什么语言</h3><pre><code>js是一种运行在浏览器的脚本语言，这种语言主要的功能是可以制作出动态的页面的效果
我们可以通过js+css+html布局来形成我们现在可以访问展示的页面

js语言是弱语言类型， 因此我们在项目开发中当我们随意更改某个变量的数据类型后
有可能会导致其他引用这个变量的方法中报错等等。</code></pre>
<h3 id="js-的基本数据类型有哪些，基本数据类型和复杂数据类型的区别"><a href="#js-的基本数据类型有哪些，基本数据类型和复杂数据类型的区别" class="headerlink" title="js 的基本数据类型有哪些，基本数据类型和复杂数据类型的区别"></a>js 的基本数据类型有哪些，基本数据类型和复杂数据类型的区别</h3><pre><code>基本：String、Number、Boolean、Null、undefined、Symbol

引用(复合)：Object（Array，Date，RegExp，Function）

区别：
基本数据类型把数据名和值直接存储在栈当中
复杂数据类型在栈中存储数据名和一个堆的地址，在堆中存储属性和值，访问时先从栈中获取地址再到堆中取相应的值

这个前提条件下写一个getType，返回相应的类型
<pre class="language-none"><code class="language-none">function gettype(nm)&#123;
    return Object.prototype.toString.call(nm);
&#125;</code></pre></code></pre>
<h3 id="面向对象——原型与原型链"><a href="#面向对象——原型与原型链" class="headerlink" title="面向对象——原型与原型链"></a>面向对象——原型与原型链</h3><h4 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h4><pre><code>构造函数有一个属性叫prototype。主要用来在创建对象时初始化对象。
每个函数都有prototype(原型)属性，这个属性是一个指针，指向一个对象，
这个对象的用途是包含特定类型的所有实例共享的属性和方法，即这个原型对象是用来给实例共享属性和方法的。
而每个实例内部都有一个指向原型对象的指针。

每一个对象创建的时候都会形成两个&#39;对象&#39;：
    1.对象本身————类
    2.原型对象————类.prototype</code></pre>
<h4 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h4><pre><code>提到原型链就不得不提原型的继承，继承的完美实现方案是借助寄生组合继承，主要实现原理
PersonB.prototype = Object.create(PersonA.prototype)实现来继承PersonA的原型
当我们通过new关键字实例化的对象身上就有了PersonB自身的属性和方法，也有了PersonA的原型方法
当实例化对象调用某个方法时会先在自身和原型上查找，然后是在_proto_上一层层查找，这种方式就是原型链。</code></pre>
<h4 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h4><pre><code>你先在自己的变量范围内找，没找到的话他就会沿着作用域一层一层往上找，直到找到这个变量，这个查找的过程叫做作用域链</code></pre>
<h3 id="数组有哪些操作方法"><a href="#数组有哪些操作方法" class="headerlink" title="数组有哪些操作方法"></a>数组有哪些操作方法</h3><pre><code>unshift()  把参数添加到数组开头
shift() 把数组的第一个元素删除
push() 向数组末尾添加一个或多个元素
pop() 把数组的最后一个元素删除 
concat() 连接两个或多个数组
join() 数组转成字符串
reverse() 数组倒叙
slice() 截取后返回新数组 [&#39;H&#39;,&#39;el&#39;,&#39;lo&#39;,&#39;wo&#39;,&#39;rld!&#39;].slice(1,3) 返回 [&quot;el&quot;, &quot;lo&quot;]
splice() 添加或删除数组中的元素，这种方法会改变原始数组
sort() 数组元素排序
filter() 筛选数组
Map()  循环数组的每一项</code></pre>
<h3 id="call-、bind-、apply-区别"><a href="#call-、bind-、apply-区别" class="headerlink" title="call ()、bind ()、apply () 区别"></a>call ()、bind ()、apply () 区别</h3><pre><code>三者都是可以改变this的指向

call调用 将方法中的this指向call中第一个参数，第一个参数是对象 后面是字符串。当第一个参数为null、undefined时，默认指向window; call中第一个参数之后是要传递给方法的参数列表。

apply与call相似，不同之处在于传递给方法的参数形式不一致。apply传递给方法的参数是数组的形式。第一个参数是对象  后面是数组

call和apply在改变方法的this指向时，会同时执行方法；

而bind不会执行方法，而是返回改变this指向后的新方法。bind() 返回对应函数便于稍后调用；call()、apply()则是立即调用</code></pre>
<h3 id="和-有什么区别"><a href="#和-有什么区别" class="headerlink" title="== 和 === 有什么区别"></a>== 和 === 有什么区别</h3><pre><code>==用于一般比较 比较时可以转换数据类型 
===用于严格比较 比较时只要类型不匹配就返回false</code></pre>
<h3 id="forEach和map的区别"><a href="#forEach和map的区别" class="headerlink" title="forEach和map的区别"></a>forEach和map的区别</h3><pre><code>共同点：
他们都是循环数组的，匿名函数中的this都是指window
不同点：
forEach没法中断或者跳出循环，他也没有返回值，返回结果是undefined，他直接修改的就是原数组，
map有返回值，他可以创建一个新数组，会给循环数组中的每个元素，返回一个新的数组，他修改的是这个新数组
map速度比forEach快
map因为返回数组所以可以链式操作，forEach不能</code></pre>
<h3 id="split-和-join-的区别"><a href="#split-和-join-的区别" class="headerlink" title="split () 和 join () 的区别"></a>split () 和 join () 的区别</h3><pre><code>split() 字符串转数组 如：var str = &quot;hello?word?welcome&quot;  console.log(str.split(“？”)) 返回值为 [&quot;hello&quot;, &quot;word&quot;, &quot;welcome&quot;]

join() 数组转字符串 如：var arr = new Array() arr[0] = &quot;hello&quot; arr[1] = &quot;world&quot; arr[3] = &quot;welcome&quot; arr.join(&quot;、&quot;)  返回值为 &quot;hello、world、welcome&quot;</code></pre>
<h3 id="什么是闭包"><a href="#什么是闭包" class="headerlink" title="什么是闭包"></a>什么是闭包</h3><pre><code>它是声明在一个函数中的函数，他可以访问另外一个函数作用域中的局部变量，让这些变量的值始终保存在内存中
总结：闭包找到的是同一地址中 父级函数中对应变量最终的值

优点：1，内部函数可以引用外层的参数和变量，参数和变量不会被垃圾回收机制回收,2，避免了全局变量的污染，3，安全性提高
缺点：由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大。所以我们在不用了之后，将不使用的局部变量删除掉，使其被回收。在IE中可能导致内存泄露，
即无法回收 驻留在内存中的元素，这时候需要手动释放。    

应用场景：当时我们有个项目，就是我记得当初有个局部变量，我想给他永久保存下来，这个时候就可以把他放到闭包当中，还有就是模块化的时候，他不会和全局产生冲突</code></pre>
<h4 id="闭包的好处"><a href="#闭包的好处" class="headerlink" title="闭包的好处"></a>闭包的好处</h4><pre><code>(1)希望一个变量长期驻扎在内存当中(不被垃圾回收机制回收)
(2)避免全局变量的污染
(3)私有成员的存在
(4)安全性提高</code></pre>
<h3 id="js垃圾回收机制知道哪些，垃圾回收机制的好处和坏处"><a href="#js垃圾回收机制知道哪些，垃圾回收机制的好处和坏处" class="headerlink" title="js垃圾回收机制知道哪些，垃圾回收机制的好处和坏处"></a>js垃圾回收机制知道哪些，垃圾回收机制的好处和坏处</h3><h4 id="什么是垃圾回收机制"><a href="#什么是垃圾回收机制" class="headerlink" title="什么是垃圾回收机制"></a>什么是垃圾回收机制</h4><pre><code>JS的垃圾回收机制是为了以防内存泄漏，内存泄漏的含义就是当已经不需要某块内存时这块内存还存在着，垃圾回收机制就是间歇的不定期的寻找到不再使用的变量，并释放掉它们所指向的内存。</code></pre>
<h4 id="内存泄漏的原因"><a href="#内存泄漏的原因" class="headerlink" title="内存泄漏的原因"></a>内存泄漏的原因</h4><pre><code>内存泄漏指由于疏忽或错误造成程序未能释放已经不再使用的内存。内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，导致在释放该段内存之前就失去了对该段内存的控制，
从而造成了内存的浪费。这里就讲一些常见会带来内存泄露的原因。</code></pre>
<h4 id="垃圾回收的方式"><a href="#垃圾回收的方式" class="headerlink" title="垃圾回收的方式"></a>垃圾回收的方式</h4><pre><code>1 标记清除（mark and sweep）
s中最常用的垃圾回收方式就是标记清除。当变量进入环境时，例如，在一个函数中声明一个变量，就将这个变量标记为&quot;进入环境&quot;，从逻辑上讲，永远不能释放进入环境变量所占用的内存，
因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其标记为&quot;离开环境&quot;。
<pre class="language-none"><code class="language-none">function test()&#123;
    var a &#x3D; 10;    &#x2F;&#x2F;被标记&quot;进入环境&quot;
    var b &#x3D; &quot;hello&quot;;    &#x2F;&#x2F;被标记&quot;进入环境&quot;
&#125;
test();    &#x2F;&#x2F;执行完毕后之后，a和b又被标记&quot;离开环境&quot;，被回收</code></pre>
垃圾回收机制在运行的时候会给存储再内存中的所有变量都加上标记（可以是任何标记方式），然后，它会去掉处在环境中的变量及被环境中的变量引用的变量标记（闭包）。
而在此之后剩下的带有标记的变量被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后垃圾回收机制到下一个周期运行时，将释放这些变量的内存，回收它们所占用的空间。

2 引用计数（reference counting）

<pre class="language-none"><code class="language-none">let arr &#x3D; [1,2,3,4];
console.log(&quot;hello world&quot;);
arr &#x3D; null;</code></pre>
上面的代码中，数组[1,2,3,4]是一个值，会占用内存。变量arr是仅有的对这个值的引用，因此引用次数为1。尽管后面的代码没有用到arr，它是会持续占用内存。

如果增加一行代码，解除arr对[1,2,3,4]引用，这块内存就可以被垃圾回收机制释放了。

好处：大幅简化程序的内存管理代码，减轻程序猿负担，并且减少因为长时间运转而带来的内存泄露问题。

坏处：自动回收意味着程序猿无法掌控内存。ECMAScript中没有暴露垃圾回收的借口，我们无法强迫其进行垃圾回收，更加无法干预内存管理。</code></pre>
<h3 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h3><pre><code>深拷贝的话，比如对象数组，他会把所有的值分配到堆内存里面，像浅拷贝的话，他只会拷贝一层，或者两层，他不会吧所有的引用地址都拷贝到堆内存里面，
当他使用浅拷贝时，比如说你引用的是这个地址，然后假设你改变的是这个地址里的一个值，假设他是在第二层，他就会把这个值也一同修改，像js里的api object.create，object.assign其实都是浅拷贝，
深拷贝他是有js自带的一个方式，叫JSON.parse（JSON.stringify），
但是这种方式也有缺点，比如说拷贝函数的时候或者拷贝不是JSON数据格式的时候，他就会出现很多问题，像完整深拷贝的话，他就需要用递归的方式去实现。

先把将要拷贝的数据 obj 以参数的形式传进去，然后声明一个变量来储存我们拷贝的内容，判断数据是否是引用数据类型，如果不是可以直接赋值，如果是的话，就自己调用自己，再循环一遍。
由于null不可以循环但类型又是object，所以这个需要对null进行判断（用instanceof判断），再声明一个变量来储存拷贝出来的值,根据这个参数的具体数据类型声明不同的类型来储存，
循环obj 中的每一项，如果里面还有复杂数据类型，则直接利用递归再次调用这个函数，最后将 这个变量 return 出来就行了。</code></pre>
<p>递归实现深拷贝<br>    <pre class="language-none"><code class="language-none">var obj &#x3D; &#123;   &#x2F;&#x2F;原数据，包含字符串、对象、函数、数组等不同的类型
    name:&quot;test&quot;,
    main:&#123;
        a:1,
        b:2
    &#125;,
    fn:function()&#123;
        
    &#125;，
        friends:[1,2,3,[22,33]]
&#125;

function copy(obj)&#123;
        let newobj &#x3D; null;   &#x2F;&#x2F;声明一个变量用来储存拷贝之后的内容
        
    &#x2F;&#x2F;判断数据类型是否是复杂类型，如果是则调用自己，再次循环，如果不是，直接赋值即可，
    &#x2F;&#x2F;由于null不可以循环但类型又是object，所以这个需要对null进行判断
        if(typeof(obj) &#x3D;&#x3D; &#39;object&#39; &amp;&amp; obj !&#x3D;&#x3D; null)&#123; 
        
    &#x2F;&#x2F;声明一个变量用以储存拷贝出来的值,根据参数的具体数据类型声明不同的类型来储存
            newobj &#x3D; obj instanceof Array? [] : &#123;&#125;;   
            
    &#x2F;&#x2F;循环obj 中的每一项，如果里面还有复杂数据类型，则直接利用递归再次调用copy函数
            for(var i in obj)&#123;  
                newobj[i] &#x3D; copy(obj[i])
            &#125;
        &#125;else&#123;
            newobj &#x3D; obj
        &#125;    
    return newobj;    &#x2F;&#x2F;函数必须有返回值，否则结构为undefined
&#125;

    var obj2 &#x3D; copy(obj)
    obj2.name &#x3D; &#39;修改成功&#39;
    obj2.main.a &#x3D; 100
console.log(obj,obj2)</code></pre></p>
<h3 id="箭头函数和匿名函数的区别"><a href="#箭头函数和匿名函数的区别" class="headerlink" title="箭头函数和匿名函数的区别"></a>箭头函数和匿名函数的区别</h3><pre><code>箭头函数呢其实他就是一个匿名函数的语法糖，他们主要的区别呢，就是普通函数的this指向是指向全局window的，而箭头函数他是指向他的父级上下文，
箭头函数没有原型属性，箭头函数他不能通过call() 、 apply() 、bind()方法直接修改它的this指向。(call、aaply、bind会默认忽略第一个参数，但是可以正常传参)，</code></pre>
<h3 id="对promise的理解"><a href="#对promise的理解" class="headerlink" title="对promise的理解"></a>对promise的理解</h3><pre><code>Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件监听— —更合理和更强大。Promise 有三种状态：pending（进行中）、fulfilled（已成功） 和rejected（已失败）。
一旦状态改变，就不会再变，但是无法获取到pending状态，在promise中接受两个内置参数分别是resolve（成功）和reject（失败），
Promise实例生成以后，可以用then方法 分别指定resolved状态和rejected状态的回调函数。then方法可以传递两个回调函数第 一个是成功，第二个是失败，
失败回调也可以使用promise的catch方法回调，promise 还有一个强大的功能那就是all方法可以组合多个promise实例，包装成一个新的 Promise 实例。
缺点：
    无法取消Promise，一旦新建它就会立即执行，无法中途取消
    如果不设置回调函数，Promise内部抛出的错误，不会反应到外部
    当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）</code></pre>
<h3 id="介绍一下async和await"><a href="#介绍一下async和await" class="headerlink" title="介绍一下async和await"></a>介绍一下async和await</h3><pre><code>async 会将其后的函数（函数表达式或 Lambda）的返回值封装成一个 Promise 对 象，而 await 会等待这个 Promise 完成，并将其 resolve 的结果返回出来</code></pre>
<h3 id="promise和async的区别"><a href="#promise和async的区别" class="headerlink" title="promise和async的区别"></a>promise和async的区别</h3><pre><code>promise是ES6，async/await是ES7
async/await相对于promise来讲，写法更加优雅
promise 出现解决了传统 callback 函数回调地域的问题，支持链式调用可以停.then,promise 分别有 3 种状态一旦函数执行 promise 有了结果就无法改变，
遇到复杂的业务逻辑 promise 显然不是那么方便需要不停 then 这样语法显然也不美观。
async,await 是基于 promise 实现的，它是基于 Generator 函数的语法糖，它拥有内置执行器，它返回的是一个 promise 对象，可以使异步代码看起来像同步代码一样，更方便阅读和理解代码，
解决了 promise 里面不停.then 的问题</code></pre>
<h3 id="宏任务和微任务"><a href="#宏任务和微任务" class="headerlink" title="宏任务和微任务"></a>宏任务和微任务</h3><pre><code>所以可以看做是这样的：浏览器线程先执行同步任务，途中遇到异步任务就将其加入到等待任务队列中去，然后继续向下执行，等同步任务全部执行完毕后，
再去等待任务队列中去将所有可执行的微任务逐个执行，执行完后在拿取第一个先到达执行条件的宏任务来执行，执行完后再去等待任务队列中清理执行完所有已到达执行条件的微任务，
然后再拿取下一个宏任务来执行，如果宏任务执行产生微任务或者微任务执行产生宏任务就一样加入到等待任务队列中，然后还是按照主线程每次到等待队列中先执行完所以的微任务再逐个执行宏任务的顺序来走

先执行微任务--然后宏任务--宏任务里的微任务--然后在执行宏任务

宏任务：定时器setTimeout
微任务：Promise的.then，async和await下面的代码</code></pre>
<h3 id="防抖节流"><a href="#防抖节流" class="headerlink" title="防抖节流"></a>防抖节流</h3><h4 id="防抖（debounce）"><a href="#防抖（debounce）" class="headerlink" title="防抖（debounce）"></a>防抖（debounce）</h4><pre><code>就是你触发事件后，在n秒内函数只执行一次，如果在n秒内你又触发了这个事件，他就会重新计算函数的执行时间（
将多次高频操作优化为只在最后一次执行，通常应用场景是：用户输入，只需在输入完成后做一次校验即可。）

应用场景：
1.用户点击结算按钮时，可能点了很多下
2.页面resize事件，常见于需要做页面适配的时候。需要根据最终呈现的页面进行dom渲染（这种情形一般使用防抖，只需要判断最后一次的变化情况）。</code></pre>
<p>实现：利用setTimeOut来实现计时器的功能</p>
<pre class="language-none"><code class="language-none">        &#x2F;&#x2F; 防抖
        const debounce &#x3D; (fn, delay) &#x3D;&gt; &#123;
            &#x2F;**
             * @param [Function] fn 需要使用防抖的函数
             * @param [Number] delay 毫秒，防抖期限值
            *&#x2F;
            let timer &#x3D; null
            return () &#x3D;&gt; &#123;
                if (timer) &#123;
                    &#x2F;&#x2F; 进入此分支说明：当前正在一个计时周期中，并且再次触发了事件,取消当前计时，重新开始计时
                    clearTimeout(timer)
                &#125;
                &#x2F;&#x2F; 进入此分支说明：当前没有计时，则开始新的计时
                timer &#x3D; setTimeout(fn, delay)
            &#125;
        &#125;
​
        const showTop &#x3D; () &#x3D;&gt; &#123;
            let scrollTop &#x3D; document.body.scrollTop || document.documentElement.scrollTop
            console.log(&#39;当前位置：&#39; + scrollTop)
        &#125;
        window.onscroll &#x3D; debounce(showTop, 1000)</code></pre>
<h4 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h4><pre><code>连续触发一个事件，但是他在一个时间段内只执行一次，等过了这个时间段再重新激活（苏醒）。节流他会稀释函数的执行的一个频率
（每隔一段时间后执行一次，也就是降低频率，将高频操作优化成低频操作，通常使用场景：滚动条事件或resize时间，通常每隔100~500ms执行一次即可）

应用场景：
1.搜索框input事件，我们之前有个项目，他是要求点击搜索的时候，过一段时间让他展示相关的内容，或者输入间隔大于某个值的话（例如500s），就当做用户已经输入完了。
2.scroll事件，每隔一秒计算一次位置信息</code></pre>
<h4 id="防抖和节流的区别？"><a href="#防抖和节流的区别？" class="headerlink" title="防抖和节流的区别？"></a>防抖和节流的区别？</h4><pre><code>防抖：短时间内多次触发，最终在停止触发后的某个指定时间执行一次函数————只执行一次
节流：短时间内多次触发，即使触发仍在继续也可以根据指定时间触发一次函数————至少执行一次

实现：状态位 / 时间戳 / setTimeout标记</code></pre>
<pre class="language-none"><code class="language-none">        &#x2F;&#x2F; 方案一：状态位
        const throttle &#x3D; (fn, delay) &#x3D;&gt; &#123;
            &#x2F;**
             * @param [Function] fn 需要使用防抖的函数
             * @param [Number] delay 毫秒，防抖期限值
            *&#x2F;
            let valid &#x3D; true
            return () &#x3D;&gt; &#123;
                if (!valid) &#123;
                    return false
                &#125;
                &#x2F;&#x2F; 执行函数+把状态位设置为无效
                valid &#x3D; false
                setTimeout(() &#x3D;&gt; &#123;
                    fn()
                    valid &#x3D; true
                &#125;, delay)
            &#125;
        &#125;
​
        const showTop &#x3D; () &#x3D;&gt; &#123;
            let scrollTop &#x3D; document.body.scrollTop || document.documentElement.scrollTop
            console.log(&#39;当前位置：&#39; + scrollTop)
        &#125;
        window.onscroll &#x3D; throttle(showTop, 1000)</code></pre>
<pre class="language-none"><code class="language-none">        &#x2F;&#x2F; 方案二：时间戳
        const throttle &#x3D; (fn, delay) &#x3D;&gt; &#123;
            &#x2F;**
             * @param [Function] fn 需要使用防抖的函数
             * @param [Number] delay 毫秒，防抖期限值
            *&#x2F;
            let start
            return () &#x3D;&gt; &#123;
                let now &#x3D; Date.now()
                if (!start) &#123;
                    start &#x3D; now
                &#125;
​
                if (now - start &gt;&#x3D; delay) &#123;
                    fn()
                    start &#x3D; null
                &#125;
            &#125;
        &#125;
​
        const showTop &#x3D; () &#x3D;&gt; &#123;
            let scrollTop &#x3D; document.body.scrollTop || document.documentElement.scrollTop
            console.log(&#39;当前位置：&#39; + scrollTop)
        &#125;
        window.onscroll &#x3D; throttle(showTop, 1000)</code></pre>
<pre class="language-none"><code class="language-none">        &#x2F;&#x2F; 方案三：setTimeout标记
        const throttle &#x3D; (fn, delay) &#x3D;&gt; &#123;
            &#x2F;**
             * @param [Function] fn 需要使用防抖的函数
             * @param [Number] delay 毫秒，防抖期限值
            *&#x2F;
            let timer &#x3D; null
            return () &#x3D;&gt; &#123;
                if (!timer) &#123;
                    timer &#x3D; setTimeout(() &#x3D;&gt; &#123;
                        fn()
                        timer &#x3D; null
                    &#125;, delay)
                &#125;
            &#125;
        &#125;
​
        const showTop &#x3D; () &#x3D;&gt; &#123;
            let scrollTop &#x3D; document.body.scrollTop || document.documentElement.scrollTop
            console.log(&#39;当前位置：&#39; + scrollTop)
        &#125;
        window.onscroll &#x3D; throttle(showTop, 1000)</code></pre>
<h3 id="null-和-undefined-的区别"><a href="#null-和-undefined-的区别" class="headerlink" title="null 和 undefined 的区别"></a>null 和 undefined 的区别</h3><pre><code>undefined是当你声明一个变量没有赋值的时候，，我们引用这个变量，他就是一个undefined ，那么null呢 他是typeof（null）他是一个object类型，
就是null呢他相当是一个空对象，只有你主动给他赋值的时候他才会变成一个null值，像没有赋值或者没有响应，他就是一个undefined</code></pre>
<h3 id="什么是变量提升"><a href="#什么是变量提升" class="headerlink" title="什么是变量提升"></a>什么是变量提升</h3><pre><code>变量提升是js的默认行为，变量提升会将所有变量声明移动到当前作用域的顶部，并可以在声明之前使用该变量，初始化不会被提升，提升的仅作用于变量的声明</code></pre>
<h3 id="什么是事件委托"><a href="#什么是事件委托" class="headerlink" title="什么是事件委托"></a>什么是事件委托</h3><pre><code>利用事件冒泡的原理，把原本需要绑定的事件委托给父元素，让父元素负责事件监听</code></pre>
<h3 id="async-与-defer-区别"><a href="#async-与-defer-区别" class="headerlink" title="async 与 defer 区别"></a>async 与 defer 区别</h3><pre><code>异步(async) 脚本将在其加载完成后立即执行，而 延迟(defer) 脚本将等待 HTML 解析完成后，并按加载顺序执行。</code></pre>
<h3 id="cookies，sessionStorage-和-localStorage-有什么区别？"><a href="#cookies，sessionStorage-和-localStorage-有什么区别？" class="headerlink" title="cookies，sessionStorage 和 localStorage 有什么区别？"></a>cookies，sessionStorage 和 localStorage 有什么区别？</h3><pre><code>共同点：都是保存在浏览器端、且同源的
不同点：
    1.cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递。
    cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下
    sessionStorage和localStorage不会自动把数据发送给服务器，仅在本地保存。
    2.存储大小限制也不同，cookie数据不能超过4K，sessionStorage和localStorage可以达到5M或更大
    3.cookie：只在设置的cookie过期时间之前有效，即使窗口关闭或浏览器关闭
    sessionStorage：仅在当前浏览器窗口关闭之前有效；数据在当前浏览器窗口关闭后自动删除。
    localStorage：始终有效，窗口或浏览器关闭也一直保存，本地存储，因此用作存储持久数据；浏览器关闭后数据不丢失除非主动删除数据
    4.作用域不同
    cookie: 也是在所有同源窗口中都是共享的.也就是说只要浏览器不关闭，数据仍然存在
    sessionStorage：不在不同的浏览器窗口中共享，即使是同一个页面；
    localstorage：在所有同源窗口中都是共享的；也就是说只要浏览器不关闭，数据仍然存在</code></pre>
<h3 id="数组去重有哪些方法"><a href="#数组去重有哪些方法" class="headerlink" title="数组去重有哪些方法"></a>数组去重有哪些方法</h3><pre class="language-none"><code class="language-none">new Set()  如：var arr &#x3D; [1,2,3,9,6,3,1,2,6] new set(arr)</code></pre>
<h4 id="1-利用冒泡-for-循环嵌套，然后-splice-去重-如："><a href="#1-利用冒泡-for-循环嵌套，然后-splice-去重-如：" class="headerlink" title="1.利用冒泡 for 循环嵌套，然后 splice () 去重 如："></a>1.利用冒泡 for 循环嵌套，然后 splice () 去重 如：</h4><pre class="language-none"><code class="language-none">function unique(arr)&#123;            
        for(var i&#x3D;0; i&lt;arr.length; i++)&#123;
            for(var j&#x3D;i+1; j&lt;arr.length; j++)&#123;
                if(arr[i]&#x3D;&#x3D;arr[j])&#123;         &#x2F;&#x2F;第一个等同于第二个，splice方法删除第二个
                    arr.splice(j,1);
                    j--;
                &#125;
            &#125;
        &#125;
return arr;
&#125;
var arr &#x3D; [1,2,3,9,6,3,1,2,6]
console.log(unique(arr))
</code></pre>
<h4 id="2-indexOf-去重-如："><a href="#2-indexOf-去重-如：" class="headerlink" title="2.indexOf () 去重 如："></a>2.indexOf () 去重 如：</h4><pre class="language-none"><code class="language-none">function unique(arr) &#123;
    if (!Array.isArray(arr)) &#123;
        console.log(&#39;type error!&#39;)
        return
    &#125;
    var array &#x3D; [];
    for (var i &#x3D; 0; i &lt; arr.length; i++) &#123;
        if (array .indexOf(arr[i]) &#x3D;&#x3D;&#x3D; -1) &#123;
            array .push(arr[i])
        &#125;
    &#125;
    return array;
&#125;
var arr &#x3D; [1,2,3,9,6,3,1,2,6]
    console.log(unique(arr))</code></pre>
<h4 id="3-sort-去重-如："><a href="#3-sort-去重-如：" class="headerlink" title="3.sort () 去重 如："></a>3.sort () 去重 如：</h4><pre class="language-none"><code class="language-none">function unique(arr) &#123; 
    if (!Array.isArray(arr)) &#123;
        console.log(&#39;type error!&#39;) return; 
    &#125; 
    arr &#x3D; arr.sort() 
    var arrry&#x3D; [arr[0]]; 
    for (var i &#x3D; 1; i &lt; arr.length; i++) &#123;
        if (arr[i] !&#x3D;&#x3D; arr[i-1]) &#123;
            arrry.push(arr[i]);
        &#125; 
    &#125; 
    return arrry;
&#125;

var arr &#x3D; [1,2,3,9,6,3,1,2,6]

console.log(unique(arr))</code></pre>
<h4 id="4-filter-去重-如"><a href="#4-filter-去重-如" class="headerlink" title="4.filter () 去重 如:"></a>4.filter () 去重 如:</h4><pre class="language-none"><code class="language-none">function unique(arr) &#123; 
    return arr.filter(function(item, index, arr) &#123; 
        return arr.indexOf(item, 0) &#x3D;&#x3D;&#x3D; index; 
    &#125;); 
&#125;

var arr &#x3D; [1,2,3,9,6,3,1,2,6]

console.log(unique(arr))</code></pre>
<h3 id="GET-和-POST-有什么区别"><a href="#GET-和-POST-有什么区别" class="headerlink" title="GET 和 POST 有什么区别"></a>GET 和 POST 有什么区别</h3><pre><code>1.使用Get请求时,参数在URL中显示，安全性比较低,而post请求在send（）方法中传递参数,使用Post方式,则不会显示出来。
2.使用Get请求发送数据量小,Post请求发送数据量大。
3.get请求可以被缓存,post不可以，不建议被缓存，每次调用都会对服务器资源造成影响。
4.post请求必须设置Content-Type值为application/x-form-www-urlencoded。
5.发送请求时,因为get请求的参数都在url里,所以send函数发送的参数为null,而post请求在使用send方法时,却需赋予其参数。</code></pre>
<h3 id="强制缓存和协商缓存"><a href="#强制缓存和协商缓存" class="headerlink" title="强制缓存和协商缓存"></a>强制缓存和协商缓存</h3><pre><code>强制缓存就是直接从浏览器缓存查找该结果，然后根据这个结果来决定是否使用该缓存他的控制字段是Expires、Cache-Control优先级高，
（public:所有内容都被缓存，private:只有客户端缓存，no-cache:所有内容都不被缓存，max-age=时间:缓存在多少秒后失效）
如果失效的话，就用到了协商缓存，他就是在强制缓存失效后，浏览器携带缓存标识向服务器发送请求，由服务器根据这个标识来决定是否使用缓存的过程，
分两种情况：生效后返回304，服务器告诉浏览器资源未更新，灾区浏览器中访问资源，失效后，返回200和请求的结果  强制缓存优先于协商缓存</code></pre>
<h3 id="跨域有几种解决方案"><a href="#跨域有几种解决方案" class="headerlink" title="跨域有几种解决方案"></a>跨域有几种解决方案</h3><h4 id="1-jsonp"><a href="#1-jsonp" class="headerlink" title="1. jsonp"></a>1. jsonp</h4><pre><code>通过动态创建 script 标签，然后利用 src 属性进行跨域，这也就是 JSONP 跨域的基本原理。</code></pre>
<pre class="language-none"><code class="language-none">&#x2F;&#x2F; 1. 定义一个 回调函数 handleResponse 用来接收返回的数据
function handleResponse(data) &#123;
    console.log(data);
&#125;;

&#x2F;&#x2F; 2. 动态创建一个 script 标签，并且告诉后端回调函数名叫 handleResponse
var body &#x3D; document.getElementsByTagName(&#39;body&#39;)[0];
var script &#x3D; document.gerElement(&#39;script&#39;);
script.src &#x3D; &#39;http:&#x2F;&#x2F;www.laixiangran.cn&#x2F;json?callback&#x3D;handleResponse&#39;;
body.appendChild(script);

&#x2F;&#x2F; 3. 通过 script.src 请求 &#96;http:&#x2F;&#x2F;www.laixiangran.cn&#x2F;json?callback&#x3D;handleResponse&#96;，
&#x2F;&#x2F; 4. 后端能够识别这样的 URL 格式并处理该请求，然后返回 handleResponse(&#123;&quot;name&quot;: &quot;laixiangran&quot;&#125;) 给浏览器
&#x2F;&#x2F; 5. 浏览器在接收到 handleResponse(&#123;&quot;name&quot;: &quot;laixiangran&quot;&#125;) 之后立即执行 ，也就是执行 handleResponse 方法，获得后端返回的数据，这样就完成一次跨域请求了。</code></pre>
<pre><code>优点：使用简便，没有兼容性问题，目前最流行的一种跨域方法
缺点：
只支持 GET 请求。
由于是从其它域中加载代码执行，因此如果其他域不安全，很可能会在响应中夹带一些恶意代码。
要确定 JSONP 请求是否失败并不容易。虽然 HTML5 给 script 标签新增了一个 onerror 事件处理程序，但是存在兼容性问题。</code></pre>
<h4 id="2-document-domain-iframe-（适用于主域名相同-子域名不同-两个页面都通过js强制设置document-domain为基础主域，就实现了同域）"><a href="#2-document-domain-iframe-（适用于主域名相同-子域名不同-两个页面都通过js强制设置document-domain为基础主域，就实现了同域）" class="headerlink" title="2. document.domain + iframe （适用于主域名相同 子域名不同  两个页面都通过js强制设置document.domain为基础主域，就实现了同域）"></a>2. document.domain + iframe （适用于主域名相同 子域名不同  两个页面都通过js强制设置document.domain为基础主域，就实现了同域）</h4><pre><code>对于主域名相同，而子域名不同的情况，可以使用 document.domain 来跨域。这种方式非常适用于 iframe 跨域的情况。
比如，有一个页面，它的地址是 http://www.laixiangran.cn/a.html，在这个页面里面有一个 iframe，它的 src 是 http://laixiangran.cn/b.html。很显然，
这个页面与它里面的 iframe 框架是不同域的，所以我们是无法通过在页面中书写 js 代码来获取 iframe 中的东西的。
这个时候，document.domain 就可以派上用场了，我们只要把 http://www.laixiangran.cn/a.html 和 http://laixiangran.cn/b.html 这两个页面的 document.domain 都设成
相同的域名就可以了。但要注意的是，document.domain 的设置是有限制的，我们只能把 document.domain 设置成自身或更高一级的父域，且主域必须相同。
例如：a.b.laixiangran.cn 中某个文档的 document.domain 可以设成 a.b.laixiangran.cn、b.laixiangran.cn 、laixiangran.cn 中的任意一个，
但是不可以设成 c.a.b.laixiangran.cn ，因为这是当前域的子域，也不可以设成 baidu.com，因为主域已经不相同了。</code></pre>
<p>例如，在页面 <a target="_blank" rel="noopener" href="http://www.laixiangran.cn/a.html">http://www.laixiangran.cn/a.html</a> 中设置document.domain：</p>
<pre class="language-none"><code class="language-none">&lt;iframe src&#x3D;&quot;http:&#x2F;&#x2F;laixiangran.cn&#x2F;b.html&quot; id&#x3D;&quot;myIframe&quot; onload&#x3D;&quot;test()&quot;&gt;
&lt;script&gt;
    document.domain &#x3D; &#39;laixiangran.cn&#39;; &#x2F;&#x2F; 设置成主域
    function test() &#123;
        console.log(document.getElementById(&#39;myIframe&#39;).contentWindow);
    &#125;
&lt;&#x2F;script&gt;
在页面 http:&#x2F;&#x2F;laixiangran.cn&#x2F;b.html 中也设置 document.domain，而且这也是必须的，虽然这个文档的 domain 就是 laixiangran.cn，
但是还是必须显式地设置 document.domain 的值：
&lt;script&gt;
    document.domain &#x3D; &#39;laixiangran.cn&#39;; &#x2F;&#x2F; document.domain 设置成与主页面相同
&lt;&#x2F;script&gt;</code></pre>
<pre><code>这样，http://www.laixiangran.cn/a.html 就可以通过 js 访问到 http://laixiangran.cn/b.html 中的各种属性和对象了。</code></pre>
<h4 id="3-location-hash-iframe"><a href="#3-location-hash-iframe" class="headerlink" title="3. location.hash + iframe"></a>3. location.hash + iframe</h4><pre><code>是子框架修改父框架 src 的 hash 值，通过这个属性进行传递数据，且更改 hash 值，页面不会刷新。但是传递的数据的字节数是有限的</code></pre>
<h4 id="4-window-name-iframe"><a href="#4-window-name-iframe" class="headerlink" title="4. window.name + iframe"></a>4. window.name + iframe</h4><pre><code>window 对象有个 name 属性，该属性有个特征：即在一个窗口（window）的生命周期内，窗口载入的所有的页面（不管是相同域的页面还是不同域的页面）都是共享一个 window.name 的，
每个页面对 window.name 都有读写的权限，window.name 是持久存在一个窗口载入过的所有页面中的，并不会因新页面的载入而进行重置。</code></pre>
<h4 id="5-postMessage-data-origin-方法接受两个参数"><a href="#5-postMessage-data-origin-方法接受两个参数" class="headerlink" title="5. postMessage (data,origin)方法接受两个参数"></a>5. postMessage (data,origin)方法接受两个参数</h4><pre><code>是 HTML5 新引进的特性

data：需要传递的数据(发送的消息)，html5规范支持任意基本类型或可复制的对象，但部分浏览器只支持字符串，所以传参时最好用JSON.stringify()序列化。
origin：协议+主机+端口号，也可以设置为&quot;*&quot;，表示可以传递给任意窗口，来限定接收消息的那个 window 对象所在的域,如果要指定和当前窗口同源的话设置为&quot;/&quot;。</code></pre>
<h4 id="6-跨域资源共享（CORS）"><a href="#6-跨域资源共享（CORS）" class="headerlink" title="6. 跨域资源共享（CORS）"></a>6. 跨域资源共享（CORS）</h4><pre><code>CORS 背后的基本思想，就是使用自定义的 HTTP 头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功，还是应该失败。</code></pre>
<p>浏览器将CORS请求分成两类：简单请求和非简单请求<br>只要同时满足以下两大条件，就属于简单请求。</p>
<pre><code>1、请求方法是以下三种方法之一：

HEAD
GET
POST

2、HTTP的头信息不超出以下几种字段：

Accept
Accept-Language
Content-Language
Last-Event-ID
Content-Type：只限于三个值 application/x-www-form-urlencoded、multipart/form-data、text/plain</code></pre>
<p>凡是不同时满足上面两个条件，就属于非简单请求。<br>浏览器对这两种请求的处理，是不一样的。</p>
<p>简单请求</p>
<pre><code>1.在请求中需要附加一个额外的 Origin 头部，其中包含请求页面的源信息（协议、域名和端口），以便服务器根据这个头部信息来决定是否给予响应。
例如：Origin: http://www.laixiangran.cn
2.如果服务器认为这个请求可以接受，就在 Access-Control-Allow-Origin 头部中回发相同的源信息（如果是公共资源，可以回发 * ）。
例如：Access-Control-Allow-Origin：http://www.laixiangran.cn
3.没有这个头部或者有这个头部但源信息不匹配，浏览器就会驳回请求。正常情况下，浏览器会处理请求。注意，请求和响应都不包含 cookie 信息。
4.如果需要包含 cookie 信息，ajax 请求需要设置 xhr 的属性 withCredentials 为 true，服务器需要设置响应头部 Access-Control-Allow-Credentials: true。</code></pre>
<p>非简单请求</p>
<pre><code>浏览器在发送真正的请求之前，会先发送一个 Preflight 请求给服务器，这种请求使用 OPTIONS 方法，发送下列头部：</code></pre>
<p>Origin：与简单的请求相同。<br>Access-Control-Request-Method: 请求自身使用的方法。<br>Access-Control-Request-Headers: （可选）自定义的头部信息，多个头部以逗号分隔。</p>
<pre class="language-none"><code class="language-none">Origin: http:&#x2F;&#x2F;www.laixiangran.cn
Access-Control-Request-Method: POST
Access-Control-Request-Headers: NCZ</code></pre>
<p>发送这个请求后，服务器可以决定是否允许这种类型的请求。服务器通过在响应中发送如下头部与浏览器进行沟通：</p>
<pre><code>Access-Control-Allow-Origin：与简单的请求相同。
Access-Control-Allow-Methods: 允许的方法，多个方法以逗号分隔。
Access-Control-Allow-Headers: 允许的头部，多个方法以逗号分隔。
Access-Control-Max-Age: 应该将这个 Preflight 请求缓存多长时间（以秒表示）</code></pre>
<p>例如：</p>
<pre class="language-none"><code class="language-none">Access-Control-Allow-Origin: http:&#x2F;&#x2F;www.laixiangran.cn
Access-Control-Allow-Methods: GET, POST
Access-Control-Allow-Headers: NCZ
Access-Control-Max-Age: 1728000</code></pre>
<p>一旦服务器通过 Preflight 请求允许该请求之后，以后每次浏览器正常的 CORS 请求，就都跟简单请求一样了。</p>
<p>优点：<br>    CORS 通信与同源的 AJAX 通信没有差别，代码完全一样，容易维护。<br>    支持所有类型的 HTTP 请求。<br>缺点：<br>    存在兼容性问题，特别是 IE10 以下的浏览器。<br>    第一次发送非简单请求时会多一次请求。</p>
<h3 id="typeof-和-instanceof-有什么区别"><a href="#typeof-和-instanceof-有什么区别" class="headerlink" title="typeof 和 instanceof 有什么区别"></a>typeof 和 instanceof 有什么区别</h3><pre><code>typeof 判断一个数据是什么数据类型；一般只能返回如下几个结果：&quot;number&quot;、&quot;string&quot;、&quot;boolean&quot;、&quot;object&quot;、&quot;function&quot; 和 &quot;undefined&quot;。
instanceof 判断一个对象是否在另一个对象的原型链上</code></pre>
<h2 id="三、vue-部分"><a href="#三、vue-部分" class="headerlink" title="三、vue 部分"></a>三、vue 部分</h2><h3 id="vue-实现数据双向绑定的原理"><a href="#vue-实现数据双向绑定的原理" class="headerlink" title="vue 实现数据双向绑定的原理"></a>vue 实现数据双向绑定的原理</h3><pre><code>采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty（）来劫持各个属性的setter，getter，在数据变动时通知给订阅者，
订阅者收到属性变化通知并执行相应的函数，从而更新视图。
即数据和视图同步，数据发生变化，视图跟着变化，视图变化，数据也随之发生改变</code></pre>
<h3 id="什么是-MVC-和-MVVM-和-MVP"><a href="#什么是-MVC-和-MVVM-和-MVP" class="headerlink" title="什么是 MVC 和 MVVM 和 MVP"></a>什么是 MVC 和 MVVM 和 MVP</h3><pre><code>MVC模式：Controller负责将Model的数据用View显示出来

M：Model（数据模型），用于存放数据
V：View（视图），也就是用户界面
C：Controller是Model和View的协调者

MVVM模式：VM双向绑定，在 MVVM 框架中，View(视图) 和 Model(数据) 是不可以直接通讯的

M：Movel（数据模型）
V：View
VM：ViewModel 是一个同步View 和 Model的对象

MVP模式: View不直接与Model交互，而是通过与Presenter交互来与Model间接交互。

M——数据层(model)
V——视图层(view)
P——发布层(presenter)</code></pre>
<h3 id="vue-的生命周期以及页面初次加载会触发哪些钩子"><a href="#vue-的生命周期以及页面初次加载会触发哪些钩子" class="headerlink" title="vue 的生命周期以及页面初次加载会触发哪些钩子"></a>vue 的生命周期以及页面初次加载会触发哪些钩子</h3><pre><code>beforeCreate 组件实例被创建之初，组件的属性生效之前，在当前阶段data、methods、computed以及watch上的数据和方法都不能被访问
created 组件实例已经完全出创建，属性也绑定，但是真实 DOM 没有生成，$el 还不可以用，可以做一些初始数据的获取，
在当前阶段无法与Dom进行交互，如果非要想，可以通过vm.$nextTick来访问Dom。

beforeMount 在挂载开始之前被调用，相关的render函数首次被调用
mounted 实例挂载后执行，这时候真实dom已经挂载完成，可以访问到dom节点，并使用$refs进行操作

beforeUpdate 组件数据更新之前调用，发生在虚拟 DOM 重新渲染之前
update 组件数据更新之后，dom已经完成了更新，要注意的是避免在此期间更改数据，因为这可能会导致无限循环的更新。

&lt;!-- activated keep-alive 专属，组件被激活时调用 --&gt;
&lt;!-- deactivated keep-alive 专属，组件被销毁时调用 --&gt;
beforeDestory 组件销毁前调用，在当前阶段实例完全可以被使用，我们可以在这时进行善后收尾工作，比如清除计时器。
destroyed 组件销毁后调用，这个时候只剩下了dom空壳。组件已被拆解，数据绑定被卸除，监听被移出，子实例也统统被销毁。
第一次会触发前四个钩子</code></pre>
<h3 id="v-if-和-v-for-哪一个优先级高"><a href="#v-if-和-v-for-哪一个优先级高" class="headerlink" title="v-if 和 v-for 哪一个优先级高"></a>v-if 和 v-for 哪一个优先级高</h3><pre><code>v-for优先级高
因为当 Vue 处理指令时，v-for 比 v-if 具有更高的优先级，这意味着 v-if 将分别重复运行于每个 v-for 循环中。通过v-if 移动到容器元素，不会再重复遍历列表中的每个值。
取而代之的是，我们只检查它一次，且不会在 v-if 为否的时候运算 v-for。</code></pre>
<h3 id="v-if-和-v-show-有什么异同"><a href="#v-if-和-v-show-有什么异同" class="headerlink" title="v-if 和 v-show 有什么异同"></a>v-if 和 v-show 有什么异同</h3><pre><code>共同点：
两者都可以控制元素的显示和隐藏

不同点：
v-show 是通过控制css中的display设置为none，控制隐藏，只会编译一次。
v-if 是动态的向DOM树内添加或者删除DOM元素，若初始值为false，就不会编译了。而且v-if不停的销毁和创建比较消耗性能，它会导致页面的回流，影响性能体验。

适用场景：
如果要频繁切换某节点，使⽤v-show(切换开销⽐较⼩，初始开销较⼤)。如果不需要频繁切换某节点使⽤v-if（初始渲染开销较⼩，切换开销⽐较⼤）。</code></pre>
<h3 id="vue-中-data-为什么必须是一个函数"><a href="#vue-中-data-为什么必须是一个函数" class="headerlink" title="vue 中 data 为什么必须是一个函数"></a>vue 中 data 为什么必须是一个函数</h3><pre><code>防止组件在重复使用时，数据互相影响，使用函数将产生新作用域，所以同一个组件在不同位置被使用时，数据不会被影响到，
如果是一个对象，作用域没有隔离，子组件的data属性值会互相影响，因为所有的实例会共享引用同一个数据对象</code></pre>
<h3 id="v-for-里面-key-的作用"><a href="#v-for-里面-key-的作用" class="headerlink" title="v-for 里面 key 的作用"></a>v-for 里面 key 的作用</h3><pre><code>key的作用是为了高效的更新虚拟DOM，提高diff速度，具有唯一性
当有相同标签名的元素切换时，需要通过 key 特性设置唯一的值来标记以让 Vue 区分它们，否则 Vue 为了效率只会替换相同标签内部的内容。
key 的特殊属性主要用在 Vue的虚拟DOM算法，在新旧节点对比时辨识VNodes。如果不使用key，Vue会使用一种最大限度减少动态元素并且尽可能的尝试修复/再利用相同类型元素的算法。
使用key，它会基于key的变化重新排列元素顺序，并且会移除key不存在的元素。

key的作用就是更新组件时判断两个节点是否相同。相同就复用，不相同就删除旧的创建新的。如果不添加key组件默认都是就地复用，不会删除添加节点，只是改变列表项中的文本值
而添加了key之后，当对比内容不一致时，就会认为是两个节点，会先删除掉旧节点，然后添加新节点</code></pre>
<h3 id="vue组件通信有哪些"><a href="#vue组件通信有哪些" class="headerlink" title="vue组件通信有哪些"></a>vue组件通信有哪些</h3><pre><code>父传子 在子元素中用 props 接收
子传父 在子元素中用 $emit 传值
获取父子组件实例 $parent、$children
Event Bus 实现跨组件通信 Vue.prototype.$bus = new Vue
Vuex
$attrs、$listeners
Provide、inject
使用路由query/params传参 如 this.$router.push(&#123;path: &#39;/&#39;, query: &#123;参数名: &#39;参数值&#39;&#125;)  使用this.$route.query.参数名 接收
本地存储传值</code></pre>
<h3 id="初始化页面闪动问题"><a href="#初始化页面闪动问题" class="headerlink" title="初始化页面闪动问题"></a>初始化页面闪动问题</h3><pre><code>在css里加上[v-cloak] &#123;display: none;&#125;
如果没有彻底解决问题，则在根元素加上 style=“display: none;” :style=&quot;&#123;display: ‘block’&#125;&quot;</code></pre>
<h3 id="route和-router-的区别"><a href="#route和-router-的区别" class="headerlink" title="route和 router 的区别"></a>route和 router 的区别</h3><pre><code>$router是VueRouter的实例，在script标签中想要导航到不同的URL,使用$router.push方法。返回上一个历史history用$router.to(-1)
$route为当前router跳转对象。里面可以获取当前路由的name,path,query,parmas等。</code></pre>
<h3 id="vuex-有哪几种状态"><a href="#vuex-有哪几种状态" class="headerlink" title="vuex 有哪几种状态"></a>vuex 有哪几种状态</h3><p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态<br>并以相应的规则保证状态以一种可预测的方式发生变化。</p>
<pre><code>state 基本数据(数据源存放地)

Getters 过滤/计数。store 的计算属性 返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。

mutations 更改 Vuex 的 store 中的状态的唯一方法是提交 mutation 必须是同步函数

Actions 类似于 mutation 提交的是 mutation，而不是直接变更状态。 可以包含任意异步操作。

Modules 将 store 分割成模块（module）。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割</code></pre>
<h3 id="vue-router-有几种模式"><a href="#vue-router-有几种模式" class="headerlink" title="vue-router 有几种模式"></a>vue-router 有几种模式</h3><pre><code>hash模式：当 # 后面的哈希值发生变化时，可以通 过 hashchange 事件来监听到 URL 的变化，从而进行跳转页面
history模式：要使用 history.pushState（stateObject参数的副本, title: 所添加记录的标题, URL: 所添加记录的URL） 和 history.replaceState 改变 URL。一个是新增历史记录，一个是替换当前的
刷新404的问题：因为你在刷新的时候，他会改变当前的url，然后会向服务器发送请求，服务器找不到相应的资源，他就会报404，在webpack中配置一个historyApiFallback就可以解决，只要接口不存在，就会当做路由的方式去解决</code></pre>
<h3 id="路由跳转的原理以及方式"><a href="#路由跳转的原理以及方式" class="headerlink" title="路由跳转的原理以及方式"></a>路由跳转的原理以及方式</h3><pre><code>路由就是根据不同的url地址展示不同的内容或页面
静态路由是在路由器中设置的固定的路由表。
动态路由是网络中的路由器之间相互通信，传递路由信息，利用收到的路由信息更新路由器表的过程。

this.$router.push(&#123;name:&#39;master&#39;,params:&#123;id:&#39;参数&#39;&#125;&#125;);
//name和params搭配，刷新的话，参数会消失
this.$router.push(&#123;path:&#39;/master&#39;,query:&#123;id:&#39;参数&#39;&#125;&#125;);
//path和query搭配，刷新页面的话，url中的参数不会丢失,query中的参数成了url中的一部分
this.$router.push()
跳转到不同的url，但这个方法回向history栈添加一个记录，点击后退会返回到上一个页面。
this.$router.replace()
描述：同样是跳转到指定的url，但是这个方法不会向history里面添加新的记录，点击返回，会跳转到上上一个页面。上一个记录是不存在的。
this.$router.go(n)
相对于当前页面向前或向后跳转多少个页面,类似 window.history.go(n)。n可为正数可为负数。正数返回上一个页面</code></pre>
<h3 id="vue3的优点"><a href="#vue3的优点" class="headerlink" title="vue3的优点"></a>vue3的优点</h3><pre><code>vue3的速度更快，体积更小，更接近原生 便于维护
速度更快：重写虚拟dom的实现
体积更小：通过webpack的tree-shaking功能，可以将无用模块“剪辑”，仅打包需要的
更接近原生：可以自定义渲染API
便于维护：componentsAPI 可以和现有的Options API一起使用，活的逻辑组合与复用

新增的特性：
组件现在支持有多个根节点
通过createRenderer，我们能够构建自定义渲染器，我们能够将 vue 的开发模型扩展到其他平台
composition Api，也就是组合式api，通过这种形式，我们能够更加容易维护我们的代码，将相同功能的变量进行一个集中式的管理</code></pre>
<h3 id="vue3为什么用proxy代替Object-defineProperty"><a href="#vue3为什么用proxy代替Object-defineProperty" class="headerlink" title="vue3为什么用proxy代替Object.defineProperty"></a>vue3为什么用proxy代替Object.defineProperty</h3><pre><code>Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象
检测不到对象属性的添加和删除
数组API方法无法监听到
需要对每个属性进行遍历监听，如果嵌套对象，需要深层监听，造成性能问题

Proxy的监听是针对一个对象的，那么对这个对象的所有操作会进入监听操作，这就完全可以代理所有属性了

Object.defineProperty只能遍历对象属性进行劫持
Proxy直接可以劫持整个对象，并返回一个新对象，我们可以只操作新的对象达到响应式目的</code></pre>
<h2 id="四、其它"><a href="#四、其它" class="headerlink" title="四、其它"></a>四、其它</h2><h3 id="优雅降级和渐进增强"><a href="#优雅降级和渐进增强" class="headerlink" title="优雅降级和渐进增强"></a>优雅降级和渐进增强</h3><pre><code>渐进增强 progressive enhancement：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。

优雅降级 graceful degradation：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。

区别：优雅降级是从复杂的现状开始，并试图减少用户体验的供给，而渐进增强则是从一个非常基础的，能够起作用的版本开始，并不断扩充，以适应未来环境的需要。降级（功能衰减）意味着往回看；
而渐进增强则意味着朝前看，同时保证其根基处于安全地带。</code></pre>
<h3 id="浏览器页面有哪三层构成，分别是什么，作用是什么？"><a href="#浏览器页面有哪三层构成，分别是什么，作用是什么？" class="headerlink" title="浏览器页面有哪三层构成，分别是什么，作用是什么？"></a>浏览器页面有哪三层构成，分别是什么，作用是什么？</h3><pre><code>构成：结构层、表示层、行为层

分别是：HTML、CSS、JavaScript

作用：HTML实现页面结构，CSS完成页面的表现与风格，JavaScript实现一些客户端的功能与业务。</code></pre>
<h3 id="页面重构怎么操作？"><a href="#页面重构怎么操作？" class="headerlink" title="页面重构怎么操作？"></a>页面重构怎么操作？</h3><pre><code>页面重构是指：在不改变外部行为的前提下，简化结构、添加可读性，而在网站前端保持一致的行为。也就是说在不改变UI的情况下，对网站进行优化，在扩展的同时保持一致的UI。
编写css、让页面结构更合理化，提升用户体验，实现良好的页面效果和提升性能。</code></pre>
<h3 id="前端性能优化"><a href="#前端性能优化" class="headerlink" title="前端性能优化"></a>前端性能优化</h3><pre><code>避免使用css表达式，避免使用高级选择器，通配选择器。

缓存Ajax，使用CDN，使用外部js和css文件以便缓存，添加Expires头，服务端配置Etag，减少DNS查找等

css放在顶部，js放在底部

减少@import导入css（同步操作）

合并样式和脚本

使用css图片精灵，图片懒加载

减少http请求

初始首屏之外的图片资源按需加载，静态资源延迟加载。

压缩文件，开启GZIP，

少用全局变量，合理使用闭包

用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能

避免图片和iFrame等的空Src。空Src会重新加载当前页面，影响速度和效率</code></pre>
<h3 id="http和https的区别"><a href="#http和https的区别" class="headerlink" title="http和https的区别"></a>http和https的区别</h3><pre><code>1、HTTP 是超文本传输协议，信息是明文传输，HTTPS 则是具有安全性的 SSL 加密传输协议。
2、HTTP 和 HTTPS 使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。
3、HTTP 的连接很简单，是无状态的。HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。
(无状态的意思是其数据包的发送、传输和接收都是相互独立的。无连接的意思是指通信双方都不长久的维持对方的任何信息。)</code></pre>
<h3 id="http-请求过程"><a href="#http-请求过程" class="headerlink" title="http 请求过程"></a>http 请求过程</h3><p>HTTP是超文本传输协议，它是TCP/IP协议的一个应用层协议，用于定义WEB浏览器与WEB服务器之间交换数据的过程以及通迅的格式</p>
<pre><code>域名解析
发起TCP的3次握手
建立TCP连接后发起http请求
服务器端响应http请求，浏览器得到html代码
浏览器解析html代码，并请求html代码中的资源
断开tcp连接，4次挥手
浏览器对页面进行渲染呈现给用户</code></pre>
<h3 id="HTTP-常见状态码"><a href="#HTTP-常见状态码" class="headerlink" title="HTTP 常见状态码"></a>HTTP 常见状态码</h3><pre><code>200 OK 客户端请求成功。
301 Moved Permanently 请求永久重定向。
302 Moved Temporarily 请求临时重定向。
304 Not Modified 文件未修改，可以直接使用缓存的文件。
400 Bad Request 由于客户端请求有语法错误，不能被服务器所理解。
401 Unauthorized 请求未经授权，无法访问。
403 Forbidden 服务器收到请求，但是拒绝提供服务。服务器通常会在响应正文中给出不提供服务的原因。
404 Not Found 请求的资源不存在，比如输入了错误的URL。
500 Internal Server Error 服务器发生不可预期的错误，导致无法完成客户端的请求。
503 Service Unavailable 服务器当前不能够处理客户端的请求，在一段时间之后，服务器可能会恢复正常。</code></pre>
<h3 id="一个完整的-url-包括哪几部分"><a href="#一个完整的-url-包括哪几部分" class="headerlink" title="一个完整的 url 包括哪几部分"></a>一个完整的 url 包括哪几部分</h3><pre><code>协议部分、域名部分、端口部分、路径部分、文件部分、 参数部分、锚点部分</code></pre>
<h3 id="url和uri的区别"><a href="#url和uri的区别" class="headerlink" title="url和uri的区别"></a>url和uri的区别</h3><pre><code>URI由三部分组成：
1：协议名
2：存放资源的主机名（计算机的IP号）
3：标识资源自身的路径

URI 属于父类，而 URL 属于 URI 的子类。URL 是 URI 的一个子集。
二者的区别在于，URI 表示请求服务器的路径，定义这么一个资源。而 URL 同时说明要如何访问这个资源</code></pre>
<h3 id="webpack配置入口出口"><a href="#webpack配置入口出口" class="headerlink" title="webpack配置入口出口"></a>webpack配置入口出口</h3><pre class="language-none"><code class="language-none">module.exports&#x3D;&#123;
    &#x2F;&#x2F;入口文件的配置项
    entry:&#123;&#125;,
    &#x2F;&#x2F;出口文件的配置项
    output:&#123;&#125;,
    &#x2F;&#x2F;模块：例如解读CSS,图片如何转换，压缩
    module:&#123;&#125;,
    &#x2F;&#x2F;插件，用于生产模版和各项功能
    plugins:[],
    &#x2F;&#x2F;配置webpack开发服务功能
    devServer:&#123;&#125;
&#125;</code></pre>
<h3 id="webpack3和webpack4区别"><a href="#webpack3和webpack4区别" class="headerlink" title="webpack3和webpack4区别"></a>webpack3和webpack4区别</h3><pre class="language-none"><code class="language-none">1.mode
 
webpack增加了一个mode配置，只有两种值development | production。对不同的环境他会启用不同的配置。
 
2.CommonsChunkPlugin
 
CommonChunksPlugin已经从webpack4中移除。
可使用optimization.splitChunks进行模块划分（提取公用代码）。
但是需要注意一个问题，默认配置只会对异步请求的模块进行提取拆分，如果要对entry进行拆分
需要设置optimization.splitChunks.chunks &#x3D; &#39;all&#39;。
 
3.webpack4使用MiniCssExtractPlugin取代ExtractTextWebpackPlugin。
 
4.代码分割。
 
使用动态import，而不是用system.import或者require.ensure
 
5.vue-loader。
 
使用vue-loader插件为.vue文件中的各部分使用相对应的loader，比如css-loader等
 
6.UglifyJsPlugin
 
现在也不需要使用这个plugin了，只需要使用optimization.minimize为true就行，production mode下面自动为true
 
optimization.minimizer可以配置你自己的压缩程序</code></pre>
<h3 id="es6新特性"><a href="#es6新特性" class="headerlink" title="es6新特性"></a>es6新特性</h3><pre class="language-none"><code class="language-none">1.ES6引入来严格模式
    变量必须声明后在使用
    函数的参数不能有同名属性, 否则报错
    不能使用with语句 (说实话我基本没用过)
    不能对只读属性赋值, 否则报错
    不能使用前缀0表示八进制数,否则报错 (说实话我基本没用过)
    不能删除不可删除的数据, 否则报错
    不能删除变量delete prop, 会报错, 只能删除属性delete global[prop]
    eval不会在它的外层作用域引入变量
    eval和arguments不能被重新赋值
    arguments不会自动反映函数参数的变化
    不能使用arguments.caller (说实话我基本没用过)
    不能使用arguments.callee (说实话我基本没用过)
    禁止this指向全局对象
    不能使用fn.caller和fn.arguments获取函数调用的堆栈 (说实话我基本没用过)
    增加了保留字（比如protected、static和interface）
 
2.关于let和const新增的变量声明
    1.let 声明的变量不进行变量的提升
    2.let 声明的变量不可以重复声明；
    3.let 声明的变量只在当前的作用域下生效
    4.let 会让当前for循环形成一个块级作用域；每循环一次，会 形成一个小的子作用域，子作用域存储了每次循环的i的值；
    5.const : 定义常量；常量不可以修改
 
3.数组对象的解构赋值
    1.解构的值一定是可遍历的；
    2.如果解构不成功，存储值是undefined；
    3.对象的解构按照属性名进行解构，跟顺序无关；如果key有默认值，那么后面的解构会将默认值覆盖；

    const Web &#x3D; [&#39;html&#39;, &#39;css&#39;, &#39;javascript&#39;]
    let [tool1, tool2, tool3] &#x3D; Web

    const liMing &#x3D; &#123;
        name: &#39;liMing&#39;,
        age: &#39;22&#39;,
        tell: function()&#123;
            console.log(&#96;I am liMing&#96;)
        &#125;
    &#125;
    let &#123;name, age, tell&#125; &#x3D; liMing

4.模板字符串
    &#96; &#96;(反引号)内容中可以直接出现换行符，’ &#39;和&quot; &quot;中则不可以，出现会报错
5.箭头函数
    箭头函数内的this指向上层对象；始终指向函数声明时所在作用域下的this的值，无法被call改变
    普通函数内的this指向调用其函数的对象
6.字符串的扩展
    includes()：返回布尔值，A.includes(B,index)，判断A是否包含B。
    startsWith()：返回布尔值，表示是否以xxx开头。
    endsWith()：返回布尔值，表示是否以xxx开头结尾。
7.数值的扩展
    Number.isFinite()用来检查一个数值是否为有限的（finite）。
    Number.isNaN()用来检查一个值是否为NaN。
8.函数的扩展
    允许给函数参数指定默认值
9.扩展运算符
    const arr &#x3D; [&#39;小明&#39;,&#39;小芳&#39;,&#39;小红&#39;]
    [...arr]

10.新增symbol数据类型
    ES6引入了一种新的原始数据类型Symbol，表示独一无二的值。它是JavaScript语言的第7种数据类型，是一个类似字符串的数据类型
    特点：
    Symbol的值是唯一的，用来解决命名冲突的问题
    Symbol值不能与其他数据进行运算，也不能与自己进行运算，譬如+、-、*、&#x2F;、比较运算
    Symbol定义的对象属性不能使用for…in遍历，但是可以使用Reflect.ownKeys来获取对象的所有键名
    使用场景：
    给对象添加属性和方法
 
11.Set 和 Map 数据结构
    ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。Set 本身是一个构造函数，用来生成 Set 数据结构。
    let set &#x3D; new Set();
    set.add(1);	&#x2F;&#x2F; [1]
    let set2 &#x3D; new Set([1,2,3,4,5])	&#x2F;&#x2F; [1,2,3,4,5]
    
    Map它类似于对象，也是键值对的集合，不同在于Object强制规定key值只能是字符串。而Map对象的key可以是任意对象。
12.Proxy
    Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问
    都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。
    Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。
    Vue3.0使用了proxy
13.Promise
    Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。
    特点是：
        对象的状态不受外界影响。
        一旦状态改变，就不会再变，任何时候都可以得到这个结果。
14.async 函数
    async函数对 Generator 函数的区别：
    （1）内置执行器。
    Generator 函数的执行必须靠执行器，而async函数自带执行器。也就是说，async函数的执行，与普通函数一模一样，只要一行。
    （2）更好的语义。
    async和await，比起星号和yield，语义更清楚了。async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果。
    （3）正常情况下，await命令后面是一个 Promise 对象。如果不是，会被转成一个立即resolve的 Promise 对象。
    （4）返回值是 Promise。
    async函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用then方法指定下一步的操作。
15.Class
    class跟let、const一样：不存在变量提升、不能重复声明...
    ES6 的class可以看作只是一个语法糖，它的绝大部分功能
    ES5 都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。
16.Module
    ES6 的模块自动采用严格模式，不管你有没有在模块头部加上&quot;use strict&quot;;。
    import和export命令以及export和export default的区别
</code></pre>
<h3 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a>浏览器缓存</h3><pre><code>缓存可以减少网络 IO 消耗，提高访问速度。浏览器缓存是一种操作简单、效果显著的前端性能优化手段
很多时候，大家倾向于将浏览器缓存简单地理解为“HTTP 缓存”。
但事实上，浏览器缓存机制有四个方面，它们按照获取资源时请求的优先级依次排列如下：

Memory Cache
Service Worker Cache
HTTP Cache
Push Cache

缓存它又分为强制缓存和协商缓存。优先级较高的是强制缓存，在命中强制缓存失败的情况下，才会走协商缓存
    实现强制缓存，过去我们一直用 expires。
    当服务器返回响应时，在 Response Headers 中将过期时间写入 expires 字段，现在一般使用Cache-Control 两者同时出现使用Cache-Control

    协商缓存，Last-Modified 是一个时间戳，如果我们启用了协商缓存，它会在首次请求时随着 Response Headers 返回：每次请求去判断这个时间戳是否发生变化。
    从而去决定你是304读取缓存还是给你返回最新的数据</code></pre>
<h3 id="介绍define"><a href="#介绍define" class="headerlink" title="介绍define"></a>介绍define</h3><p>define是amd（异步模块加载机制）的api，第一个参数是模块名称（可选），第二个参数是数组，包含所有依赖的模块（可选），第三个参数可以是一个函数或者是一个js对象。</p>
<pre><code>(1) 三个参数：如果第三个参数是回调函数的话，异步加载完依赖的模块之后，执行回调函数，在回调函数中可以直接使用依赖的模块，
    他们按依赖声明顺序作为参数提供给回调函数。回调函数执行结束之后，通知依赖于自己的模块自己已经可用。
(2)两个参数：当第一个参数省略的话，就定义了一个匿名模块，这时候模块文件的文件名就是模块名。这将会使模块是高度可用的。
(3)一个参数： define 的前面两个参数都可以省略；第三个参数有两种情况：一种是 JavaScript 对象，另一种是一个函数。
  如果是对象，可以是包含方法的对象或者是只提供数据。后者和 JSONP非常类似，因此，AMD可以认为包含了一个完整的JSONP实现。模块演变为一个简单的数据对象，
  这样的数据对象是高度可用的，而且因为是静态对象，它也是CDN友好的，可以提高JSONP的性能。
  如果是函数，其用途之一是快速开发实现。适用于较小型的应用，该方式无需提前考虑需要引入的模块，只需使用时，require 即可。</code></pre>
<pre class="language-none"><code class="language-none">define(function()&#123;
    var a &#x3D; require(&quot;A&quot;);
&#125;)
123</code></pre>
<p>define函数在执行的时候，会调用函数的 toString 方法，并扫描其中的 require 调用，提前载入这些模块，载入完成后再执行。<br>注意：Opera 不能很好的支持函数的 toString 方法，因此，在浏览器中它的适用性并不强。但是使用构建工具打包时，构建工具会扫描 require 并强制载入依赖模块。</p>
<h3 id="express是什么"><a href="#express是什么" class="headerlink" title="express是什么"></a>express是什么</h3><p>Express是一个最小的，灵活的Node.js Web应用程序开发框架，它提供了一套强大的功能来开发Web和移动应用程序。 它有助于基于Node Web应用程序的快速开发。<br>特点：</p>
<pre><code>1、可以设置 中间件来响应http请求
2、定义了路由用于执行不同的http请求动作
3、可以通过模板传递参数来动态渲染html页面</code></pre>
<h3 id="require是什么"><a href="#require是什么" class="headerlink" title="require是什么"></a>require是什么</h3><p>异步加载模块的加载器</p>
<h3 id="事件冒泡、事件委托以及事件捕获？"><a href="#事件冒泡、事件委托以及事件捕获？" class="headerlink" title="事件冒泡、事件委托以及事件捕获？"></a>事件冒泡、事件委托以及事件捕获？</h3><pre><code>事件冒泡就是子级元素的某个事件被触发，它的上级元素的该事件也被递归执行。冒泡的终点是window。
阻止事件冒泡在子级元素上面加上e.stopPropagation()阻止事件冒泡。
事件委托其实是使用了冒泡的原理，从点击的元素开始，以递归方式的向父元素传播事件，这样做的好处是对于大量要处理的元素，不必为每个元素都绑定事件，
只需要在他们的父元素上绑定一次即可，提高性能。 还有一个好处就是可以处理动态插入dom中的元素，直接绑定的方式是不行的。
事件捕获是最外层的事件先被触发，最后才是我们点击的button事件被触发，这便是事件捕获。
阻止事件捕获的方式是e.stopPropagation()。</code></pre>
<h3 id="发布订阅模式和观察者模式"><a href="#发布订阅模式和观察者模式" class="headerlink" title="发布订阅模式和观察者模式"></a>发布订阅模式和观察者模式</h3><h4 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h4><pre><code>观察者模式定义了对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知，并自动更新。
观察者模式属于行为型模式，行为型模式关注的是对象之间的通讯，观察者模式就是观察者和被观察者之间的通讯。

观察者模式有一个别名叫“发布-订阅模式”，或者说是“订阅-发布模式”，订阅者和订阅目标是联系在一起的，当订阅目标发生改变时，逐个通知订阅者。
我们可以用报纸期刊的订阅来形象的说明，当你订阅了一份报纸，每天都会有一份最新的报纸送到你手上，有多少人订阅报纸，报社就会发多少份报纸，报社和订报纸的客户就是上面文章开头所说的“一对多”的依赖关系。</code></pre>
<h4 id="发布订阅模式"><a href="#发布订阅模式" class="headerlink" title="发布订阅模式"></a>发布订阅模式</h4><pre><code>在现在的发布订阅模式中，称为发布者的消息发送者不会将消息直接发送给订阅者，这意味着发布者和订阅者不知道彼此的存在。
在发布者和订阅者之间存在第三个组件，称为消息代理或调度中心或中间件，它维持着发布者和订阅者之间的联系，过滤所有发布者传入的消息并相应地分发它们给订阅者。

举一个例子，你在微博上关注了A，同时其他很多人也关注了A，那么当A发布动态的时候，微博就会为你们推送这条动态。A就是发布者，你是订阅者，微博就是调度中心，
你和A是没有直接的消息往来的，全是通过微博来协调的（你的关注，A的发布动态）</code></pre>
<h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><pre><code>观察者模式： 观察者（Observer）直接订阅（Subscribe）主题（Subject），而当主题被激活的时候，会触发（Fire Event）观察者里的事件。

发布订阅模式： 订阅者（Subscriber）把自己想订阅的事件注册（Subscribe）到调度中心（Topic），当发布者（Publisher）发布该事件（Publish topic）到调度中心，
也就是该事件触发时，由调度中心统一调度（Fire Event）订阅者注册到调度中心的处理代码。</code></pre>
<h3 id="axios和ajax和fetch的区别"><a href="#axios和ajax和fetch的区别" class="headerlink" title="axios和ajax和fetch的区别"></a>axios和ajax和fetch的区别</h3><pre><code>其实axios是通过 promise 实现对 ajax 技术的一种封装。就像 ajax 是 通过 jQuery 来封装一样。
也就是说，jQuery 将请求技术进行了封装 变成了 ajax , 而 通过 promise 又把 ajax 进行封装就成了 axios。
ajax，本身是针对MVC的编程，不符合现在前端MVVM的浪潮。基于原生的XHR开发，XHR本身的架构不清晰，已经有了fetch的替代方案。JQuery整个项目太大，单纯使用ajax却要引入整个JQuery非常的不合理

ajax：

1、本身是针对MVC编程，不符合前端MVVM的浪潮
2、基于原生XHR开发，XHR本身的架构不清晰，已经有了fetch的替代方案，jquery整个项目太大，单纯使用ajax却要引入整个jquery非常不合理（采取个性化打包方案又不能享受cdn服务）
3、ajax不支持浏览器的back按钮
4、安全问题ajax暴露了与服务器交互的细节
5、对搜索引擎的支持比较弱
6、破坏程序的异常机制
7、不容易调试

axios：

1、从浏览器中创建XHR
2、从node.js创建http请求
3、支持Promise API
4、客户端防止CSRF（网站恶意利用）攻击
5、提供了一些并发请求的接口
6、支持拦截请求和响应、取消请求

fetch

1、只对网络请求报错，对400、500都当做成功的请求
2、默认不带cookie，需要添加配置项
3、没有办法监测请求的进度、而XHR可以</code></pre>
<h3 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h3><pre><code>只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。
假如存在全局变量tmp，但是块级作用域内let又声明了一个局部变量tmp，导致后者绑定这个块级作用域，所以在let声明变量前，对tmp赋值会报错。
<pre class="language-none"><code class="language-none">var tmp &#x3D; 123;

if (true) &#123;
tmp &#x3D; &#39;abc&#39;; &#x2F;&#x2F; ReferenceError
let tmp;
&#125;</code></pre>
上面代码中，存在全局变量tmp，但是块级作用域内let又声明了一个局部变量tmp，导致后者绑定这个块级作用域，所以在let声明变量前，对tmp赋值会报错。

ES6 明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。
（access &#39;a&#39; before initialization 在初始化之前无法访问a）

总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。</code></pre>
<h3 id="ToB和ToC的区别"><a href="#ToB和ToC的区别" class="headerlink" title="ToB和ToC的区别"></a>ToB和ToC的区别</h3><pre><code>1.业务形态不同：ToC的需求更多是围绕衣食住行；ToB的需求更多是围绕机构所处的某个行业或者领域来展开，场景更复杂多样。ToC是“生活”，；ToB更多的是“生产”。
2.产品需求不同：ToC对产品需求更多是功能外部化；ToB考虑的是产品实际化，专业化。
3.（购买）决策体系不同：ToC购买产品一般个人决定，ToB则需要业务部门、采购部门、财务部门、公司高层等的决策。</code></pre>
<h3 id="eharts原理"><a href="#eharts原理" class="headerlink" title="eharts原理"></a>eharts原理</h3><pre><code>echarts底层原理为canvas
ECharts 总体结构是基于 MVC 架构的，各部分的主要作用是：

Storage(M)：模型层，实现图形数据的CURD（增删改查）管理；
Painter(V)：  视图层，实现canvas 元素的生命周期管理，即：视图渲染、更新控制、绘图；
Handler(C)：控制层，事件交互处理，实现完整的dom事件模拟封装。</code></pre>
<h3 id="canvas和svg区别"><a href="#canvas和svg区别" class="headerlink" title="canvas和svg区别"></a>canvas和svg区别</h3><pre><code>都是绘制图形的
svg 是一种矢量图，而 canvas 依赖于分辨率。所以 svg 放大不会失真，但是 canvas 绘制的图形会失真。
canvas 适合图像密集型的游戏，频繁地重绘图像，svg 绘制的复杂度高时减慢渲染的速度。
SVG节点过多时渲染慢,Canvas性能更好一些，但写起来更复杂</code></pre>
</div></section><div id="reward-container"><span class="hty-icon-button button-glow" id="reward-button" title="打赏" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === &quot;none&quot;) ? &quot;block&quot; : &quot;none&quot;;"><span class="icon iconify" data-icon="ri:hand-coin-line"></span></span><div id="reward-comment">我很可爱，请给我钱</div><div id="qr" style="display:none;"><div style="display:inline-block"><a target="_blank" rel="noopener" href="https://cdn.yunyoujun.cn/img/donate/alipay-qrcode.jpg"><img loading="lazy" src="https://cdn.yunyoujun.cn/img/donate/alipay-qrcode.jpg" alt="支付宝" title="支付宝"></a><div><span style="color:#00A3EE"><span class="icon iconify" data-icon="ri:alipay-line"></span></span></div></div><div style="display:inline-block"><a target="_blank" rel="noopener" href="https://cdn.yunyoujun.cn/img/donate/qqpay-qrcode.png"><img loading="lazy" src="https://cdn.yunyoujun.cn/img/donate/qqpay-qrcode.png" alt="QQ 支付" title="QQ 支付"></a><div><span style="color:#12B7F5"><span class="icon iconify" data-icon="ri:qq-line"></span></span></div></div><div style="display:inline-block"><a target="_blank" rel="noopener" href="https://cdn.yunyoujun.cn/img/donate/wechatpay-qrcode.jpg"><img loading="lazy" src="https://cdn.yunyoujun.cn/img/donate/wechatpay-qrcode.jpg" alt="微信支付" title="微信支付"></a><div><span style="color:#2DC100"><span class="icon iconify" data-icon="ri:wechat-pay-line"></span></span></div></div></div></div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>sun</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="http://example.com/2021/02/21/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/" title="前端面试题总结">http://example.com/2021/02/21/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>本博客所有文章除特别声明外，均默认采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0 "><span class="icon iconify" data-icon="ri:creative-commons-line"></span><span class="icon iconify" data-icon="ri:creative-commons-by-line"></span><span class="icon iconify" data-icon="ri:creative-commons-nc-line"></span><span class="icon iconify" data-icon="ri:creative-commons-sa-line"></span></a> 许可协议。</li></ul></article><div class="post-nav"><div class="post-nav-item"><a class="post-nav-prev" href="/2021/02/22/JS%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="prev" title="JS面试题"><span class="icon iconify" data-icon="ri:arrow-left-s-line"></span><span class="post-nav-text">JS面试题</span></a></div><div class="post-nav-item"><a class="post-nav-next" href="/2021/02/18/ES5%E4%B8%8EES6/" rel="next" title="ES5与ES6"><span class="post-nav-text">ES5与ES6</span><span class="icon iconify" data-icon="ri:arrow-right-s-line"></span></a></div></div></div><div class="hty-card" id="comment"><div class="comment-tooltip text-center"><span>如果您有任何关于博客内容的相关讨论，欢迎前往 <a href="https://github.com/YunYouJun/yunyoujun.github.io/discussions" target="_blank">GitHub Discussions</a> 与我交流。</span><br></div><div id="waline"></div><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/@waline/client@v2/dist/waline.css"><script>window.CONFIG.waline.config.path = "/2021/02/21/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/"</script><div class="js-Pjax"><script src="/js/comments/waline.js" type="module" defer></script></div></div></main><footer class="sidebar-translate" id="footer"><div class="beian"><a rel="noopener" href="https://beian.miit.gov.cn/" target="_blank">苏ICP备17038157号</a></div><div class="copyright"><span>&copy; 2016 – 2022 </span><a class="with-love" id="animate" target="_blank" rel="noopener" href="https://sponsors.yunyoujun.cn" title="云游君的赞助者们"><span class="icon iconify" data-icon="ri:cloud-line"></span></a><span class="author"> sun</span></div><div class="powered"><span>由 <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> 驱动 v5.3.0</span><span class="footer-separator">|</span><span>主题 - <a rel="noopener" href="https://github.com/YunYouJun/hexo-theme-yun" target="_blank"><span>Yun</span></a> v1.10.4</span></div><div class="footer-support"><span>本网站由</span><a class="footer-support-logo" href="https://www.upyun.com" target="blank" title="又拍云"><img height="30" src="https://cdn.yunyoujun.cn/img/logo/upyun-logo.png" alt="又拍云"></a><span>提供 CDN 加速</span></div></footer></div><a class="hty-icon-button" id="back-to-top" aria-label="back-to-top" href="#"><span class="icon iconify" data-icon="ri:arrow-up-s-line"></span><svg class="progress-circle-container" viewBox="0 0 100 100"><circle class="progress-circle" id="progressCircle" cx="50" cy="50" r="48" fill="none" stroke="#0078E7" stroke-width="2" stroke-linecap="round"></circle></svg></a></body></html>