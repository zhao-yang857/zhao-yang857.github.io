<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="theme-color" content="#0078E7"><meta name="author" content="sun"><meta name="copyright" content="sun"><meta name="generator" content="Hexo 5.3.0"><meta name="theme" content="hexo-theme-yun"><title>vue面试题 | 太阳の小屋</title><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@900&amp;display=swap" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/star-markdown-css@0.1.22/dist/yun/yun-markdown.min.css"><script src="//at.alicdn.com/t/font_1140697_ed8vp4atwoj.js" async></script><script src="https://cdn.jsdelivr.net/npm/scrollreveal/dist/scrollreveal.min.js" defer></script><script>document.addEventListener("DOMContentLoaded", () => {
  [".post-card",".post-content img"].forEach((target)=> {
    ScrollReveal().reveal(target);
  })
});
</script><link rel="shortcut icon" type="image/svg+xml" href="/feng.ico"><link rel="mask-icon" href="/feng.ico" color="#0078E7"><link rel="alternate icon" href="/yun.ico"><link rel="preload" href="/css/hexo-theme-yun.css" as="style"><link rel="preload" href="/js/utils.js" as="script"><link rel="preload" href="/js/hexo-theme-yun.js" as="script"><link rel="prefetch" href="/js/sidebar.js" as="script"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><link rel="stylesheet" href="/css/hexo-theme-yun.css"><script id="yun-config">
    const Yun = window.Yun || {};
    window.CONFIG = {"hostname":"example.com","root":"/","title":"太阳の小屋","version":"1.3.0","mode":"auto","copycode":true,"anonymous_image":"https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/avatar/none.jpg","say":{"api":"https://v1.hitokoto.cn","hitokoto":true},"fireworks":{"colors":["219, 34, 9","216, 35, 223","252, 89, 170","89, 187, 252","103, 252, 89"]}};
  </script><meta name="description" content="vue的特点是什么？1.遵循MVVM模式数据驱动视图 2.双向绑定 3.摒弃了原始的dom操作 3.可以轻松引入Vue插件或其他第三方库开发项目 vue的原理是什么？vue2.0采用数据劫持结合发布-订阅模式,通过 Object.defineproperty 来劫持各个属性的 setter和getter,在数据变动时发布消息给订阅者,在数据变化时发布消息给订阅者，然后触发响应的监听回调 具体就是：">
<meta property="og:type" content="article">
<meta property="og:title" content="vue面试题">
<meta property="og:url" content="http://example.com/2021/02/22/vue%E9%9D%A2%E8%AF%95%E9%A2%98/index.html">
<meta property="og:site_name" content="太阳の小屋">
<meta property="og:description" content="vue的特点是什么？1.遵循MVVM模式数据驱动视图 2.双向绑定 3.摒弃了原始的dom操作 3.可以轻松引入Vue插件或其他第三方库开发项目 vue的原理是什么？vue2.0采用数据劫持结合发布-订阅模式,通过 Object.defineproperty 来劫持各个属性的 setter和getter,在数据变动时发布消息给订阅者,在数据变化时发布消息给订阅者，然后触发响应的监听回调 具体就是：">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2021-02-22T07:17:05.000Z">
<meta property="article:modified_time" content="2022-05-10T01:18:53.889Z">
<meta property="article:author" content="sun">
<meta name="twitter:card" content="summary"><script src="/js/ui/mode.js"></script></head><body><script defer src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script defer src="/js/ui/fireworks.js"></script><canvas class="fireworks"></canvas><div class="container"><a class="sidebar-toggle hty-icon-button" id="menu-btn"><div class="hamburger hamburger--spin" type="button"><span class="hamburger-box"><span class="hamburger-inner"></span></span></div></a><div class="sidebar-toggle sidebar-overlay"></div><aside class="sidebar"><script src="/js/sidebar.js"></script><ul class="sidebar-nav"><li class="sidebar-nav-item sidebar-nav-toc hty-icon-button sidebar-nav-active" data-target="post-toc-wrap" title="Table of Contents"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-list-ordered"></use></svg></li><li class="sidebar-nav-item sidebar-nav-overview hty-icon-button" data-target="site-overview-wrap" title="Overview"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-passport-line"></use></svg></li></ul><div class="sidebar-panel" id="site-overview-wrap"><div class="site-info fix-top"><a class="site-author-avatar" href="/about/" title="sun"><img width="96" loading="lazy" src="/images/%E5%A4%B4%E5%83%8F6.jpeg" alt="sun"></a><div class="site-author-name"><a href="/about/">sun</a></div><a class="site-name" href="/about/site.html">太阳の小屋</a><sub class="site-subtitle"></sub><div class="site-desciption"></div></div><nav class="site-state"><a class="site-state-item hty-icon-button icon-home" href="/" title="首页"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-home-4-line"></use></svg></span></a><div class="site-state-item"><a href="/archives/" title="归档"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-archive-line"></use></svg></span><span class="site-state-item-count">21</span></a></div><div class="site-state-item"><a href="/categories/" title="分类"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-2-line"></use></svg></span><span class="site-state-item-count">1</span></a></div><div class="site-state-item"><a href="/tags/" title="标签"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="site-state-item-count">0</span></a></div><a class="site-state-item hty-icon-button" target="_blank" rel="noopener" href="https://yun.yunyoujun.cn" title="留言板"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-clipboard-line"></use></svg></span></a></nav><hr style="margin-bottom:0.5rem"><div class="links-of-author"><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://qm.qq.com/cgi-bin/qm/qr?k=epvxdq1sknJe9JMj6J1LsBw4a6cI_2ln&amp;jump_from=webapi" title="QQ" target="_blank" style="color:#12B7F5"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-qq-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://github.com/zhao-yang857" title="GitHub" target="_blank" style="color:#6e5494"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-github-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://music.163.com/#/user/home?id=333632364" title="网易云音乐" target="_blank" style="color:#C20C0C"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-netease-cloud-music-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://space.bilibili.com/74908726" title="哔哩哔哩" target="_blank" style="color:#FF8EB3"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-bilibili-line"></use></svg></a></div><hr style="margin:0.5rem 1rem"><div class="links"><a class="links-item hty-icon-button" href="/links/" title="我的小伙伴们" style="color:dodgerblue"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-genderless-line"></use></svg></a><a class="links-item hty-icon-button" href="/girls/" title="我喜欢的女孩儿们" style="color:hotpink"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-women-line"></use></svg></a></div><br><a class="links-item hty-icon-button" id="toggle-mode-btn" href="javascript:;" title="Mode" style="color: #f1cb64"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-contrast-2-line"></use></svg></a></div><div class="sidebar-panel sidebar-panel-active" id="post-toc-wrap"><div class="post-toc"><div class="post-toc-content"><ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#vue%E7%9A%84%E7%89%B9%E7%82%B9%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.</span> <span class="toc-text">vue的特点是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#vue%E7%9A%84%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">2.</span> <span class="toc-text">vue的原理是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#computed-%E5%92%8C-watch-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E5%8F%8A%E8%BF%90%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">3.</span> <span class="toc-text">computed 和 watch 有什么区别及运用场景?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E5%92%8Cmethods%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E8%80%8C%E4%B8%8D%E7%94%A8methods%EF%BC%9F"><span class="toc-number">4.</span> <span class="toc-text">计算属性和methods的区别？为什么要用计算属性而不用methods？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Vue-%E4%B8%AD%E7%9A%84-key-%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">5.</span> <span class="toc-text">Vue 中的 key 的作用？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#vue-%E4%B8%AD-data-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BF%85%E9%A1%BB%E6%98%AF%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0"><span class="toc-number">6.</span> <span class="toc-text">vue 中 data 为什么必须是一个函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#vue%E4%B8%AD%E7%9A%84%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">7.</span> <span class="toc-text">vue中的修饰符?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#vue%E4%B8%AD%E7%9A%84%E6%8C%87%E4%BB%A4%EF%BC%9F"><span class="toc-number">8.</span> <span class="toc-text">vue中的指令？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%8E%E6%A0%B7%E7%90%86%E8%A7%A3vue%E5%8D%95%E5%90%91%E6%95%B0%E6%8D%AE%E6%B5%81"><span class="toc-number">9.</span> <span class="toc-text">怎样理解vue单向数据流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#v-if-%E5%92%8C-v-for-%E5%93%AA%E4%B8%80%E4%B8%AA%E4%BC%98%E5%85%88%E7%BA%A7%E9%AB%98"><span class="toc-number">10.</span> <span class="toc-text">v-if 和 v-for 哪一个优先级高</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#v-show%E5%92%8Cv-if%E6%8C%87%E4%BB%A4%E7%9A%84%E5%85%B1%E5%90%8C%E7%82%B9%E5%92%8C%E4%B8%8D%E5%90%8C%E7%82%B9"><span class="toc-number">11.</span> <span class="toc-text">v-show和v-if指令的共同点和不同点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-MVC-%E5%92%8C-MVVM-%E5%92%8C-MVP"><span class="toc-number">12.</span> <span class="toc-text">什么是 MVC 和 MVVM 和 MVP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFMVVM%EF%BC%9F"><span class="toc-number">13.</span> <span class="toc-text">什么是MVVM？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mvvm%E5%92%8Cmvc%E5%8C%BA%E5%88%AB%EF%BC%9F%E5%AE%83%E5%92%8C%E5%85%B6%E5%AE%83%E6%A1%86%E6%9E%B6%EF%BC%88jquery%EF%BC%89%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%93%AA%E4%BA%9B%E5%9C%BA%E6%99%AF%E9%80%82%E5%90%88%EF%BC%9F"><span class="toc-number">14.</span> <span class="toc-text">mvvm和mvc区别？它和其它框架（jquery）的区别是什么？哪些场景适合？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFvue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">15.</span> <span class="toc-text">什么是vue生命周期</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">16.</span> <span class="toc-text">vue生命周期的作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E6%AC%A1%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E4%BC%9A%E8%A7%A6%E5%8F%91%E5%93%AA%E5%87%A0%E4%B8%AA%E9%92%A9%E5%AD%90"><span class="toc-number">17.</span> <span class="toc-text">第一次页面加载会触发哪几个钩子</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E6%8F%8F%E8%BF%B0%E6%AF%8F%E4%B8%AA%E5%91%A8%E6%9C%9F%E5%85%B7%E4%BD%93%E9%80%82%E5%90%88%E5%93%AA%E4%BA%9B%E5%9C%BA%E6%99%AF"><span class="toc-number">18.</span> <span class="toc-text">简单描述每个周期具体适合哪些场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B7%E5%88%97%E4%B8%BE%E5%87%BA3%E4%B8%AAVue%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0"><span class="toc-number">19.</span> <span class="toc-text">请列举出3个Vue中常用的生命周期钩子函数?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8%E5%93%AA%E4%B8%AA%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%86%85%E8%B0%83%E7%94%A8%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82%EF%BC%9F"><span class="toc-number">20.</span> <span class="toc-text">在哪个生命周期内调用异步请求？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8%E4%BB%80%E4%B9%88%E9%98%B6%E6%AE%B5%E6%89%8D%E8%83%BD%E8%AE%BF%E9%97%AE%E6%93%8D%E4%BD%9C-DOM"><span class="toc-number">21.</span> <span class="toc-text">在什么阶段才能访问操作 DOM</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Vue-%E7%9A%84%E7%88%B6%E7%BB%84%E4%BB%B6%E5%92%8C%E5%AD%90%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="toc-number">22.</span> <span class="toc-text">Vue 的父组件和子组件生命周期钩子函数执行顺序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#vuex%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8%EF%BC%9F%E5%93%AA%E7%A7%8D%E5%8A%9F%E8%83%BD%E5%9C%BA%E6%99%AF%E4%BD%BF%E7%94%A8%E5%AE%83%EF%BC%9F"><span class="toc-number">23.</span> <span class="toc-text">vuex是什么？怎么使用？哪种功能场景使用它？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#vuex%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E5%B1%9E%E6%80%A7%EF%BC%9F"><span class="toc-number">24.</span> <span class="toc-text">vuex有哪几种属性？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#vue-router%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E5%AF%BC%E8%88%AA%E5%AE%88%E5%8D%AB%EF%BC%9F"><span class="toc-number">25.</span> <span class="toc-text">vue-router有哪几种导航守卫？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E5%AE%9A%E4%B9%89vue-router%E7%9A%84%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1%EF%BC%9F%E6%80%8E%E4%B9%88%E8%8E%B7%E5%8F%96%E4%BC%A0%E8%BF%87%E6%9D%A5%E7%9A%84%E5%8A%A8%E6%80%81%E5%8F%82%E6%95%B0%EF%BC%9F"><span class="toc-number">26.</span> <span class="toc-text">怎么定义vue-router的动态路由？怎么获取传过来的动态参数？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#vue-router-%E7%9A%84%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E4%B8%A4%E7%A7%8D%E6%A8%A1%E5%BC%8F"><span class="toc-number">27.</span> <span class="toc-text">vue-router 的原理是什么？两种模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#VNode%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E8%99%9A%E6%8B%9F-DOM%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">28.</span> <span class="toc-text">VNode是什么？虚拟 DOM是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#active-class%E6%98%AF%E5%93%AA%E4%B8%AA%E7%BB%84%E4%BB%B6%E7%9A%84%E5%B1%9E%E6%80%A7%EF%BC%9F%E5%B5%8C%E5%A5%97%E8%B7%AF%E7%94%B1%E6%80%8E%E4%B9%88%E5%AE%9A%E4%B9%89%EF%BC%9F"><span class="toc-number">29.</span> <span class="toc-text">active-class是哪个组件的属性？嵌套路由怎么定义？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B7%E8%AF%B4%E5%87%BAvue-cli%E9%A1%B9%E7%9B%AE%E4%B8%ADsrc%E7%9B%AE%E5%BD%95%E6%AF%8F%E4%B8%AA%E6%96%87%E4%BB%B6%E5%A4%B9%E5%92%8C%E6%96%87%E4%BB%B6%E7%9A%84%E7%94%A8%E6%B3%95%EF%BC%9F"><span class="toc-number">30.</span> <span class="toc-text">请说出vue.cli项目中src目录每个文件夹和文件的用法？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4v-el%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">31.</span> <span class="toc-text">指令v-el的作用是什么?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Proxy-%E4%B8%8E-Object-defineProperty-%E4%BC%98%E5%8A%A3%E5%AF%B9%E6%AF%94"><span class="toc-number">32.</span> <span class="toc-text">Proxy 与 Object.defineProperty 优劣对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%9C%A8-Vue3-0-%E9%87%87%E7%94%A8%E4%BA%86-Proxy-%E6%8A%9B%E5%BC%83%E4%BA%86-Object-defineProperty%EF%BC%9F"><span class="toc-number">33.</span> <span class="toc-text">为什么在 Vue3.0 采用了 Proxy,抛弃了 Object.defineProperty？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E8%BF%87-Vue-SSR-%E5%90%97%EF%BC%9F-%E8%AF%B4%E8%AF%B4-SSR"><span class="toc-number">34.</span> <span class="toc-text">使用过 Vue SSR 吗？ 说说 SSR</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%92%E6%A7%BD%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9A"><span class="toc-number">35.</span> <span class="toc-text">插槽的作用：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#keep-alive%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">36.</span> <span class="toc-text">keep-alive的作用？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#vuex%E4%B8%8E%E5%85%A8%E5%B1%80%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">37.</span> <span class="toc-text">vuex与全局对象的区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#vue2-x%E5%92%8Cvue3-x%E6%B8%B2%E6%9F%93%E5%99%A8%E7%9A%84diff%E7%AE%97%E6%B3%95%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">38.</span> <span class="toc-text">vue2.x和vue3.x渲染器的diff算法有什么区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%82%A3%E4%BD%A0%E7%9F%A5%E9%81%93Vue3-x%E5%93%8D%E5%BA%94%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%8E%9F%E7%90%86%E5%90%97%EF%BC%9F"><span class="toc-number">39.</span> <span class="toc-text">那你知道Vue3.x响应式数据原理吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#nextTick%E7%9F%A5%E9%81%93%E5%90%97%EF%BC%8C%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">40.</span> <span class="toc-text">nextTick知道吗，实现原理是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8Bv-model%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">41.</span> <span class="toc-text">说一下v-model的原理?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Vue%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86%E8%AF%B4%E4%B8%80%E4%B8%8B"><span class="toc-number">42.</span> <span class="toc-text">Vue事件绑定原理说一下?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Vue%E4%B8%AD%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E8%B0%83%E7%94%A8%E9%A1%BA%E5%BA%8F%E8%AF%B4%E4%B8%80%E4%B8%8B"><span class="toc-number">43.</span> <span class="toc-text">Vue中组件生命周期调用顺序说一下?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Vue2-x%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-number">44.</span> <span class="toc-text">Vue2.x组件通信有哪些方式？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%A0%E9%83%BD%E5%81%9A%E8%BF%87%E5%93%AA%E4%BA%9BVue%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%9F"><span class="toc-number">45.</span> <span class="toc-text">你都做过哪些Vue的性能优化？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%92%E6%A7%BD%E4%B9%8B%E9%97%B4%E6%98%AF%E6%80%8E%E4%B9%88%E4%BC%A0%E5%80%BC%E7%9A%84%EF%BC%9F"><span class="toc-number">46.</span> <span class="toc-text">插槽之间是怎么传值的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#vue%E4%B8%AD%E7%9A%84%E5%86%85%E7%BD%AE%E7%BB%84%E4%BB%B6%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">47.</span> <span class="toc-text">vue中的内置组件有哪些？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#vue%E4%B8%AD%E7%9A%84transfrom%E7%BB%84%E4%BB%B6%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">48.</span> <span class="toc-text">vue中的transfrom组件是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#computed-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">49.</span> <span class="toc-text">computed 是什么？实现原理？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9SPA%E5%8D%95%E9%A1%B5%E9%9D%A2%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">50.</span> <span class="toc-text">说说你对SPA单页面的理解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E7%BB%99%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%E9%A1%B9%E8%B5%8B%E5%80%BC%EF%BC%8CVue-%E8%83%BD%E6%A3%80%E6%B5%8B%E5%88%B0%E5%8F%98%E5%8C%96%E5%90%97%EF%BC%9F-%E4%BD%BF%E7%94%A8-set"><span class="toc-number">51.</span> <span class="toc-text">直接给一个数组项赋值，Vue 能检测到变化吗？(使用$set)</span></a></li></ol></div></div></div></aside><main class="sidebar-translate" id="content"><div id="post"><article class="post-block" itemscope itemtype="https://schema.org/Article"><link itemprop="mainEntityOfPage" href="http://example.com/2021/02/22/vue%E9%9D%A2%E8%AF%95%E9%A2%98/"><span hidden itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="name" content="sun"><meta itemprop="description"></span><span hidden itemprop="publisher" itemscope itemtype="https://schema.org/Organization"><meta itemprop="name" content="太阳の小屋"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">vue面试题</h1><div class="post-meta"><div class="post-time" style="display:inline-block"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-line"></use></svg></span> <time title="Created: 2021-02-22 15:17:05" itemprop="dateCreated datePublished" datetime="2021-02-22T15:17:05+08:00">2021-02-22</time><span class="post-meta-divider">-</span><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-2-line"></use></svg></span> <time title="Modified: 2022-05-10 09:18:53" itemprop="dateModified" datetime="2022-05-10T09:18:53+08:00">2022-05-10</time></div><div class="post-classify"></div></div></header><section class="post-body" itemprop="articleBody"><div class="post-content markdown-body" style="--smc-primary:#0078E7;"><h4 id="vue的特点是什么？"><a href="#vue的特点是什么？" class="headerlink" title="vue的特点是什么？"></a>vue的特点是什么？</h4><pre><code>1.遵循MVVM模式数据驱动视图
2.双向绑定
3.摒弃了原始的dom操作
3.可以轻松引入Vue插件或其他第三方库开发项目</code></pre>
<h4 id="vue的原理是什么？"><a href="#vue的原理是什么？" class="headerlink" title="vue的原理是什么？"></a>vue的原理是什么？</h4><pre><code>vue2.0采用数据劫持结合发布-订阅模式,通过 Object.defineproperty 来劫持各个属性的 setter和getter,在数据变动时发布消息给订阅者,在数据变化时发布消息给订阅者，然后触发响应的监听回调
具体就是：
通过object.defineProperty中的setter和getter来监听属性变动，实现Observer进行数据的监听，然后通知订阅者Compile（就是一个数组）来解析编译模版指令， 
最后利用Watcher搭起他们两个的一个链接，达到数据变化，视图也更新

MVVM作为绑定的入口，整合Observe,Compil和Watcher三者，通过Observe来监听model的变化
通过Compil，最终利用Watcher搭起Observe和Compil之前的通信桥梁
从而达到数据变化 =&gt; 更新视图，视图交互变化(input) =&gt; 数据model变更的双向绑定效果</code></pre>
<h4 id="computed-和-watch-有什么区别及运用场景"><a href="#computed-和-watch-有什么区别及运用场景" class="headerlink" title="computed 和 watch 有什么区别及运用场景?"></a>computed 和 watch 有什么区别及运用场景?</h4><pre><code>computed 计算属性 : 根据当前的值进行简单计算返回新的数据，他是有缓存的,只有它依赖的属性值发生改变,下一次获取 computed 的值时才会重新计算 computed 的值。
watch 侦听器 : 更多的是「观察」的作用,无缓存性,类似于某些数据的监听回调,每当监听的数据变化时都会执行回调进行后续操作。
deep: true 深度监听 方法 下面的属性层层遍历，都加上监听事件

运用场景：
当我们需要进行数值计算,一个属性受多个属性影响的时候，并且依赖于其它数据时,应该使用 computed,因为可以利用 computed 的缓存特性,避免每次获取值时,都要重新计算。
比如购物车商品结算的时候，

当一条数据影响多条数据的时候，比如说搜索商品的时候
当我们需要在数据变化时执行异步或开销较大的操作时,应该使用 watch,使用 watch 选项允许我们执行异步操作 ( 访问一个 API ),
限制我们执行该操作的频率,并在我们得到最终结果前,设置中间状态。这些都是计算属性无法做到的。</code></pre>
<h4 id="计算属性和methods的区别？为什么要用计算属性而不用methods？"><a href="#计算属性和methods的区别？为什么要用计算属性而不用methods？" class="headerlink" title="计算属性和methods的区别？为什么要用计算属性而不用methods？"></a>计算属性和methods的区别？为什么要用计算属性而不用methods？</h4><pre><code>它两的执行结果是一样的。计算属性 是只有它的依赖发生变化的时候它会自动的进行计算求值，如果依赖没有发生变化，那么每次访问的时候计算属性都会立刻返回之前的执行结果，
而事件函数需要手动调用，并且调用一次触发一次比较粗暴一点，每当重新触发渲染时，调用方法总是再次执行函数。</code></pre>
<h4 id="Vue-中的-key-的作用？"><a href="#Vue-中的-key-的作用？" class="headerlink" title="Vue 中的 key 的作用？"></a>Vue 中的 key 的作用？</h4><pre><code>key的作用是为了在diff算法执行时更快的找到对应的节点，提高diff速度，具有唯一性
当有相同标签名的元素切换时，需要通过 key 特性设置唯一的值来标记以让 Vue 区分它们，否则 Vue 为了效率只会替换相同标签内部的内容。
key 的特殊属性主要用在 Vue的虚拟DOM算法，在新旧节点对比时辨识VNodes。如果不使用key，Vue会使用一种最大限度减少动态元素并且尽可能的尝试修复/再利用相同类型元素的算法。
使用key，它会基于key的变化重新排列元素顺序，并且会移除key不存在的元素。

key的作用就是更新组件时判断两个节点是否相同。相同就复用，不相同就删除旧的创建新的。如果不添加key组件默认都是就地复用，不会删除添加节点，只是改变列表项中的文本值
而添加了key之后，当对比内容不一致时，就会认为是两个节点，会先删除掉旧节点，然后添加新节点</code></pre>
<h4 id="vue-中-data-为什么必须是一个函数"><a href="#vue-中-data-为什么必须是一个函数" class="headerlink" title="vue 中 data 为什么必须是一个函数"></a>vue 中 data 为什么必须是一个函数</h4><pre><code>防止组件在重复使用时，数据互相干扰，使用函数将产生新作用域，所以同一个组件在不同位置被使用时，数据不会被影响到，
如果是一个对象，对象属于引用类型，作用域没有隔离，子组件的data属性值会互相影响，因为所有的实例会共享引用同一个数据对象</code></pre>
<h4 id="vue中的修饰符"><a href="#vue中的修饰符" class="headerlink" title="vue中的修饰符?"></a>vue中的修饰符?</h4><pre><code>.stop 阻止事件冒泡
.prevent 清除默认行为
.once 只触发一次回调
.lazy 取代input 监听change 事件
.number 输入字符串转为有效的数字
.trim 输入首尾空格过滤</code></pre>
<h4 id="vue中的指令？"><a href="#vue中的指令？" class="headerlink" title="vue中的指令？"></a>vue中的指令？</h4><pre><code>v-if、v-else、v-for、v-bind、v-model、v-on、v-text</code></pre>
<h4 id="怎样理解vue单向数据流"><a href="#怎样理解vue单向数据流" class="headerlink" title="怎样理解vue单向数据流"></a>怎样理解vue单向数据流</h4><pre><code>这个概念出现在组件通信。父组件是通过 prop 把数据传递到子组件的，但是这个 prop 只能由父组件修改，子组件不能修改，否则会报错。
子组件想修改时，只能通过 $emit 派发一个自定义事件，父组件接收到后，由父组件修改。

解决方式：
方式1：如果子组件想把它作为局部数据来使用，可以将数据存入另一个变量中再操作，不影响父组件中的数据
方式2：如果子组件想修改数据并且同步更新到父组件，两个方法：
a.使用.sync（1.0版本中支持，2.0版本中不支持，2.3版本又开始支持）
需要显式地触发一个更新事件
b.可以将父组件中的数据包装成对象，然后在子组件中修改对象的属性(因为对象是引用类型，指向同一个内存空间)，推荐</code></pre>
<blockquote>
<p>对于改变 Props 中的值存在两种情况</p>
</blockquote>
<pre><code>1.prop作为子组件的数据，并且在子组件中需要修改，在这种情况下，最好 定义一个本地的 data 属性并将这个 prop 用作其初始值。</code></pre>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">props: [&#39;initialCounter&#39;],</span><br><span class="line">data: function () &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    counter: this.initialCounter</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>2.prop 以一种原始的值传入且需要进行转换。在这种情况下，最 好使用这个 prop 的值来定义一个计算属性。</code></pre>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">props: [&#39;size&#39;],</span><br><span class="line">computed: &#123;</span><br><span class="line">  normalizedSize: function () &#123;</span><br><span class="line">    return this.size.trim().toLowerCase()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="v-if-和-v-for-哪一个优先级高"><a href="#v-if-和-v-for-哪一个优先级高" class="headerlink" title="v-if 和 v-for 哪一个优先级高"></a>v-if 和 v-for 哪一个优先级高</h4><pre><code>v-for优先级高
因为当 Vue 处理指令时，v-for 比 v-if 具有更高的优先级，这意味着 v-if 将分别重复运行于每个 v-for 循环中。通过v-if 移动到容器元素，不会再重复遍历列表中的每个值。
取而代之的是，我们只检查它一次，且不会在 v-if 为否的时候运算 v-for。</code></pre>
<h4 id="v-show和v-if指令的共同点和不同点"><a href="#v-show和v-if指令的共同点和不同点" class="headerlink" title="v-show和v-if指令的共同点和不同点"></a>v-show和v-if指令的共同点和不同点</h4><pre><code>共同点：
两者都可以控制元素的显示和隐藏

不同点：
v-show 是通过控制css中的display设置为none，控制隐藏，只会编译一次。
v-if 是动态的向DOM树内添加或者删除DOM元素，若初始值为false，就不会编译了。而且v-if不停的销毁和创建比较消耗性能，它会导致页面的回流，影响性能体验。

适用场景：
如果要频繁切换某节点，使⽤v-show(切换开销⽐较⼩，初始开销较⼤)。如果不需要频繁切换某节点使⽤v-if（初始渲染开销较⼩，切换开销⽐较⼤）。</code></pre>
<h4 id="什么是-MVC-和-MVVM-和-MVP"><a href="#什么是-MVC-和-MVVM-和-MVP" class="headerlink" title="什么是 MVC 和 MVVM 和 MVP"></a>什么是 MVC 和 MVVM 和 MVP</h4><pre><code>MVC模式：Controller负责将Model的数据用View显示出来

M：Model（数据模型），用于存放数据
V：View（视图），也就是用户界面
C：Controller是Model和View的协调者

MVVM模式：VM双向绑定，在 MVVM 框架中，View(视图) 和 Model(数据) 是不可以直接通讯的

M：Movel（数据模型）
V：View
VM：ViewModel 是一个同步View 和 Model的对象

MVP模式: View不直接与Model交互，而是通过与Presenter交互来与Model间接交互。

M——数据层(model)
V——视图层(view)
P——发布层(presenter)</code></pre>
<h4 id="什么是MVVM？"><a href="#什么是MVVM？" class="headerlink" title="什么是MVVM？"></a>什么是MVVM？</h4><pre><code>MVVM是Model-View-ViewModel缩写，也就是把MVC中的Controller演变成ViewModel。Model层代表数据模型，View代表UI组件，ViewModel是View和Model层的桥梁，
数据会绑定到viewModel层并自动将数据渲染到页面中，视图变化的时候会通知viewModel层更新数据。</code></pre>
<h4 id="mvvm和mvc区别？它和其它框架（jquery）的区别是什么？哪些场景适合？"><a href="#mvvm和mvc区别？它和其它框架（jquery）的区别是什么？哪些场景适合？" class="headerlink" title="mvvm和mvc区别？它和其它框架（jquery）的区别是什么？哪些场景适合？"></a>mvvm和mvc区别？它和其它框架（jquery）的区别是什么？哪些场景适合？</h4><pre><code>mvc和mvvm其实区别并不大。都是一种设计思想。主要就是mvc中Controller演变成mvvm中的viewModel。mvvm主要解决了mvc中大量的DOM 操作使页面渲染性能降低，加载速度变慢，影响用户体验。

区别：vue数据驱动，通过数据来显示视图层而不是节点操作。
场景：数据操作比较多的场景，更加便捷</code></pre>
<h4 id="什么是vue生命周期"><a href="#什么是vue生命周期" class="headerlink" title="什么是vue生命周期"></a>什么是vue生命周期</h4><pre><code>Vue 实例从创建到销毁的过程，就是生命周期。也就是从开始创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、卸载等一系列过程，我们称这是 Vue 的生命周期。</code></pre>
<h4 id="vue生命周期的作用"><a href="#vue生命周期的作用" class="headerlink" title="vue生命周期的作用"></a>vue生命周期的作用</h4><p>它的生命周期中有多个事件钩子，让我们在控制整个Vue实例的过程时更容易形成好的逻辑。<br>    beforeCreate 组件实例被创建之初，组件的属性生效之前，在当前阶段data、methods、computed以及watch上的数据和方法都不能被访问<br>    created 组件实例已经完全出创建，属性也绑定，但是真实 DOM 没有生成，$el 还不可以用，可以做一些初始数据的获取，<br>    在当前阶段无法与Dom进行交互，如果非要想，可以通过vm.$nextTick来访问Dom。<br>    beforeMount 在挂载开始之前被调用，相关的render函数首次被调用<br>    mounted 实例挂载后执行，这时候真实dom已经挂载完成，可以访问到dom节点，并使用$refs进行操作<br>    beforeUpdate 组件数据更新之前调用，发生在虚拟 DOM 重新渲染之前<br>    update 组件数据更新之后，dom已经完成了更新，要注意的是避免在此期间更改数据，因为这可能会导致无限循环的更新。<br>    activated keep-alive 专属，组件被激活时调用<br>    deactivated keep-alive 专属，组件被销毁时调用<br>    beforeDestory 组件销毁前调用，在当前阶段实例完全可以被使用，我们可以在这时进行善后收尾工作，比如清除计时器。<br>    destroyed 组件销毁后调用，这个时候只剩下了dom空壳。组件已被拆解，数据绑定被卸除，监听被移出，子实例也统统被销毁。</p>
<h4 id="第一次页面加载会触发哪几个钩子"><a href="#第一次页面加载会触发哪几个钩子" class="headerlink" title="第一次页面加载会触发哪几个钩子"></a>第一次页面加载会触发哪几个钩子</h4><pre><code>第一次页面加载时会触发 beforeCreate, created, beforeMount, mounted 这几个钩子</code></pre>
<h4 id="简单描述每个周期具体适合哪些场景"><a href="#简单描述每个周期具体适合哪些场景" class="headerlink" title="简单描述每个周期具体适合哪些场景"></a>简单描述每个周期具体适合哪些场景</h4><pre><code>生命周期钩子的一些使用方法：
beforecreate : 可以在这加个loading事件，在加载实例时触发
created : 初始化完成时的事件写在这里，如在这结束loading事件，异步请求也适宜在这里调用
mounted : 挂载元素，获取到DOM节点
updated : 如果对数据统一处理，在这里写上相应函数
beforeDestroy : 可以做一个确认停止事件的确认框
nextTick : 更新数据后立即操作dom</code></pre>
<h4 id="请列举出3个Vue中常用的生命周期钩子函数"><a href="#请列举出3个Vue中常用的生命周期钩子函数" class="headerlink" title="请列举出3个Vue中常用的生命周期钩子函数?"></a>请列举出3个Vue中常用的生命周期钩子函数?</h4><pre><code>created: 实例已经创建完成之后调用,在这一步,实例已经完成数据观测, 属性和方法的运算, watch/event事件回调. 然而, 挂载阶段还没有开始, $el属性目前还不可见

mounted: el被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。如果 root实例挂载了一个文档内元素，当 mounted 被调用时 vm.$el 也在文档内。

activated::keep-alive组件激活时调用</code></pre>
<h4 id="在哪个生命周期内调用异步请求？"><a href="#在哪个生命周期内调用异步请求？" class="headerlink" title="在哪个生命周期内调用异步请求？"></a>在哪个生命周期内调用异步请求？</h4><pre><code>在 钩子函数 created 、beforeMount、mounted 中进行调用，因为在这三个钩子函数中，data 已经创建，可以将服务器点的数据返回进行赋值</code></pre>
<h4 id="在什么阶段才能访问操作-DOM"><a href="#在什么阶段才能访问操作-DOM" class="headerlink" title="在什么阶段才能访问操作 DOM"></a>在什么阶段才能访问操作 DOM</h4><pre><code>在钩子函数 mounted 被调用前，Vue 已经将编译好的模板挂载到页面上，所以可以在 mounted 中访问到 DOM</code></pre>
<h4 id="Vue-的父组件和子组件生命周期钩子函数执行顺序"><a href="#Vue-的父组件和子组件生命周期钩子函数执行顺序" class="headerlink" title="Vue 的父组件和子组件生命周期钩子函数执行顺序"></a>Vue 的父组件和子组件生命周期钩子函数执行顺序</h4><pre><code>**加载渲染过程：**
父 beforeCreate -&gt; 父 created -&gt; 父 beforeMount -&gt; 子 beforeCreate -&gt; 子 created -&gt; 子 beforeMount -&gt; 子 mounted -&gt; 父 mounted

**子组件更新过程：**
父 beforeUpdate -&gt; 子 beforeUpdate -&gt; 子 updated -&gt; 父 updated

**父组件更新过程：**
父 beforeUpdate -&gt; 父 updated

**销毁过程：**
父 beforeDestroy -&gt; 子 beforeDestroy -&gt; 子 destroyed -&gt; 父 destroyed

总结：子的生命周期都会被先结束，父的才结束。先由父到子，再从子到父。</code></pre>
<h4 id="vuex是什么？怎么使用？哪种功能场景使用它？"><a href="#vuex是什么？怎么使用？哪种功能场景使用它？" class="headerlink" title="vuex是什么？怎么使用？哪种功能场景使用它？"></a>vuex是什么？怎么使用？哪种功能场景使用它？</h4><pre><code>vuex是管理vue状态的一个库
任何组件都可以和store通信
它是单一数据源</code></pre>
<h4 id="vuex有哪几种属性？"><a href="#vuex有哪几种属性？" class="headerlink" title="vuex有哪几种属性？"></a>vuex有哪几种属性？</h4><pre><code>有五种，分别是 State、 Getter、Mutation 、Action、 Module

vuex的State特性
A、Vuex就是一个仓库，仓库里面放了很多对象。其中state就是数据源存放地，对应于一般Vue对象里面的data
B、state里面存放的数据是响应式的，Vue组件从store中读取数据，若是store中的数据发生改变，依赖这个数据的组件也会发生更新
C、它通过mapState把全局的 state 和 getters 映射到当前组件的 computed 计算属性中

vuex的Getter特性
A、getters 可以对State进行计算操作，它就是Store的计算属性
B、返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。
C、 虽然在组件内也可以做计算属性，但是getters 可以在多组件之间复用
D、 如果一个状态只在一个组件内使用，是可以不用getters

vuex的Mutation特性
是唯一更改store中状态的方法，是同步函数

vuex的Action特性
Action 类似于 mutation，不同在于：Action 提交的是 mutation，而不是直接变更状态；Action 可以包含任意异步操作。

vuex的Module特性
Module 将 store 分割成模块（module）。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割</code></pre>
<h4 id="vue-router有哪几种导航守卫？"><a href="#vue-router有哪几种导航守卫？" class="headerlink" title="vue-router有哪几种导航守卫？"></a>vue-router有哪几种导航守卫？</h4><pre><code>一种是全局导航钩子
全局前置导航守卫：router.beforeEach(to,from,next)，作用：跳转前进行判断拦截。
全局后置导航守卫：router.afterEach(to,from,next)，作用：跳转前进行判断拦截。

第二种：单个路由独享的守卫 router.beforeEnter(to,from,next)

第三种：组件内的守卫；
beforeRouterEnter((to,from,next)=&gt;&#123;&#125;)
beforeRouterUpdate((to,from,next)=&gt;&#123;&#125;)
beforeRouterLeave((to,from,next)=&gt;&#123;&#125;)

每个守卫方法接收三个参数：

to: Route: 即将要进入的目标 路由对象

from: Route: 当前导航正要离开的路由

next: Function: 一定要调用该方法来 resolve 这个钩子。

在项目中，一般在beforeEach这个钩子函数中进行路由跳转的一些信息判断。必须调用next，否则路由不会跳转
判断是否登录，是否拿到对应的路由权限等等。</code></pre>
<h4 id="怎么定义vue-router的动态路由？怎么获取传过来的动态参数？"><a href="#怎么定义vue-router的动态路由？怎么获取传过来的动态参数？" class="headerlink" title="怎么定义vue-router的动态路由？怎么获取传过来的动态参数？"></a>怎么定义vue-router的动态路由？怎么获取传过来的动态参数？</h4><pre><code>在router目录下的index.js文件中，对path属性加上/:id。  使用router对象的params.id</code></pre>
<h4 id="vue-router-的原理是什么？两种模式"><a href="#vue-router-的原理是什么？两种模式" class="headerlink" title="vue-router 的原理是什么？两种模式"></a>vue-router 的原理是什么？两种模式</h4><pre><code>vue-router是什么：他可以让单页面应用拥有了多页面应用的效果，一个url对应一个页面。
它主要是通过h5新增的history和hash两种模式来实现的
hash模式： 即地址栏 URL 中的 # 符号。它的特点在于：hash 虽然出现在 URL 中，但不会被包括在 HTTP 请求中，对后端完全没有影响，因此改变 hash 不会重新加载页面。
当 # 后面的哈希值发生变化时，可以通 过 hashchange 事件来监听到 URL 的变化，从而进行跳转页面

history模式：要使用 history.pushState 和 history.replaceState 改变 URL。一个是新增历史记录，一个是替换当前的历史记录
刷新404的问题：因为你在刷新的时候，他会改变当前的url，然后会向服务器发送请求，服务器找不到相应的资源，他就会报404，在webpack中配置一个historyApiFallback就可以解决，
只要接口不存在，就会当做路由的方式去解决</code></pre>
<h4 id="VNode是什么？虚拟-DOM是什么？"><a href="#VNode是什么？虚拟-DOM是什么？" class="headerlink" title="VNode是什么？虚拟 DOM是什么？"></a>VNode是什么？虚拟 DOM是什么？</h4><pre><code>Vue在 页面上渲染的节点，及其子节点称为“虚拟节点 (Virtual Node)”，简写为“VNode”。“虚拟 DOM”是由 Vue 组件树建立起来的整个 VNode 树的称呼。</code></pre>
<h4 id="active-class是哪个组件的属性？嵌套路由怎么定义？"><a href="#active-class是哪个组件的属性？嵌套路由怎么定义？" class="headerlink" title="active-class是哪个组件的属性？嵌套路由怎么定义？"></a>active-class是哪个组件的属性？嵌套路由怎么定义？</h4><pre><code>vue-router模块的router-link组件。
嵌套路由顾名思义就是路由的多层嵌套。 一级路由里面使用children数组配置子路由，就是嵌套路由。</code></pre>
<h4 id="请说出vue-cli项目中src目录每个文件夹和文件的用法？"><a href="#请说出vue-cli项目中src目录每个文件夹和文件的用法？" class="headerlink" title="请说出vue.cli项目中src目录每个文件夹和文件的用法？"></a>请说出vue.cli项目中src目录每个文件夹和文件的用法？</h4><pre><code>assets文件夹是放静态资源；components是放组件；router是定义路由相关的配置;view视图；app.vue是一个应用主组件；main.js是入口文件</code></pre>
<h4 id="指令v-el的作用是什么"><a href="#指令v-el的作用是什么" class="headerlink" title="指令v-el的作用是什么?"></a>指令v-el的作用是什么?</h4><pre><code>提供一个在页面上已存在的 DOM 元素作为 Vue 实例的挂载目标.可以是 CSS 选择器，也可以是一个 HTMLElement 实例</code></pre>
<h4 id="Proxy-与-Object-defineProperty-优劣对比"><a href="#Proxy-与-Object-defineProperty-优劣对比" class="headerlink" title="Proxy 与 Object.defineProperty 优劣对比"></a>Proxy 与 Object.defineProperty 优劣对比</h4><pre><code>Proxy 可以直接监听对象而非属性；
Proxy 可以直接监听数组的变化；
Proxy 有多达 13 种拦截方法,不限于 apply、ownKeys、deleteProperty、has 等等是 Object.defineProperty 不具备的；
Proxy 返回的是一个新对象,我们可以只操作新的对象达到目的,而 Object.defineProperty 只能遍历对象属性直接修改；
Proxy 作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利

Object.defineProperty 的优势如下:
兼容性好，支持 IE9，而 Proxy 的存在浏览器兼容性问题,而且无法用 polyfill 磨平，因此 Vue 的作
者才声明需要等到下个大版本( 3.0 )才能用 Proxy 重写</code></pre>
<h4 id="为什么在-Vue3-0-采用了-Proxy-抛弃了-Object-defineProperty？"><a href="#为什么在-Vue3-0-采用了-Proxy-抛弃了-Object-defineProperty？" class="headerlink" title="为什么在 Vue3.0 采用了 Proxy,抛弃了 Object.defineProperty？"></a>为什么在 Vue3.0 采用了 Proxy,抛弃了 Object.defineProperty？</h4><pre><code>Object.defineProperty 本身有一定的监控到数组下标变化的能力,但是在 Vue 中,从性能/体验的性价比考虑,
尤大大就弃用了这个特性([Vue 为什么不能检测数组变动](https://link.zhihu.com/?target=https%3A//segmentfault.com/a/1190000015783546) )。
为了解决这个问题,经过 vue 内部处理后可以使用以下几种方法来监听数组</code></pre>
<h4 id="使用过-Vue-SSR-吗？-说说-SSR"><a href="#使用过-Vue-SSR-吗？-说说-SSR" class="headerlink" title="使用过 Vue SSR 吗？ 说说 SSR"></a>使用过 Vue SSR 吗？ 说说 SSR</h4><pre><code>SSR 将 Vue 在客户端将标签渲染成HTML 片段的工作放到了服务端完成，服务端形成的 HTML 片段直接返回给客户端这个过程，叫做服务端渲染

(1)服务端渲染的优点：
更好的 SEO： 因为 SPA 页面的内容是通过 Ajax 获取，而搜索引擎爬取工具并不会等待 Ajax 异步
完成后再抓取页面内容，所以在 SPA 中是抓取不到页面通过 Ajax 获取到的内容；而 SSR 是直接由
服务端返回已经渲染好的页面（数据已经包含在页面中），所以搜索引擎爬取工具可以抓取渲染好
的页面；
更快的内容到达时间（首屏加载更快）： SPA 会等待所有 Vue 编译后的 js 文件都下载完成后，才
开始进行页面的渲染，文件下载等需要一定的时间等，所以首屏渲染需要一定的时间；SSR 直接由
服务端渲染好页面直接返回显示，无需等待下载 js 文件及再去渲染等，所以 SSR 有更快的内容到
达时间；

(2)服务端渲染的缺点：
更多的开发条件限制： 例如服务端渲染只支持 beforCreate 和 created 两个钩子函数，这会导致
一些外部扩展库需要特殊处理，才能在服务端渲染应用程序中运行；并且与可以部署在任何静态文
件服务器上的完全静态单页面应用程序 SPA 不同，服务端渲染应用程序，需要处于 Node.js
server 运行环境；
更多的服务器负载：在 Node.js 中渲染完整的应用程序，显然会比仅仅提供静态文件的 server 更
加大量占用CPU 资源 (CPU-intensive - CPU 密集)，因此如果你预料在高流量环境 ( high traffic )
下使用，请准备相应的服务器负载，并明智地采用缓存策略。</code></pre>
<h4 id="插槽的作用："><a href="#插槽的作用：" class="headerlink" title="插槽的作用："></a>插槽的作用：</h4><pre><code>为了让组件更加具有扩展性。抽取共性，保留不同为插槽，让其他组件可以传递自己想展示的标签到预留插槽。它包含具名插槽，匿名插槽、还有作用域插槽。</code></pre>
<h4 id="keep-alive的作用？"><a href="#keep-alive的作用？" class="headerlink" title="keep-alive的作用？"></a>keep-alive的作用？</h4><pre><code>缓存组件的状态，在组件还原的时候能够把状态还原到组件上。然后它有3个属性，分别是：include(包括)、exclude(不包括)、max(可缓存的最大组件实例数量)
利用keep-alive组件把想要缓存的组件包一下，并且给被缓存的组件添加name属性，在include属性里面写上我们要缓存的组件name</code></pre>
<h4 id="vuex与全局对象的区别？"><a href="#vuex与全局对象的区别？" class="headerlink" title="vuex与全局对象的区别？"></a>vuex与全局对象的区别？</h4><pre><code>Vuex的状态存储是响应式的。当Vue组件从store中读取状态的时候，若store中的状态发生变化，那么相应的组件也会得到高效更新。
不能直接改变store中的状态，改变store中的状态的唯一途径就是显示地提交(commit)mutation。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。</code></pre>
<h4 id="vue2-x和vue3-x渲染器的diff算法有什么区别？"><a href="#vue2-x和vue3-x渲染器的diff算法有什么区别？" class="headerlink" title="vue2.x和vue3.x渲染器的diff算法有什么区别？"></a>vue2.x和vue3.x渲染器的diff算法有什么区别？</h4><pre><code>Vue3.x借鉴了 ivi算法和 inferno算法
Vue2的核?Diff算法采?了双端?较的算法，同时从新旧children的两端开始进??较，借助key值找到可复?的节点，再进?相关操作
在创建VNode时就确定其类型，以及在mount/patch的过程中采?位运算来判断?个VNode的类型，在这个基础之上再配合核?的Diff算法，使得性能上较Vue2.x有了提升</code></pre>
<h4 id="那你知道Vue3-x响应式数据原理吗？"><a href="#那你知道Vue3-x响应式数据原理吗？" class="headerlink" title="那你知道Vue3.x响应式数据原理吗？"></a>那你知道Vue3.x响应式数据原理吗？</h4><pre><code>Vue3.x改用Proxy替代Object.defineProperty。因为Proxy可以直接监听对象和数组的变化，并且有多达13种拦截方法。并且作为新标准将受到浏览器厂商重点持续的性能优化。
Proxy只会代理对象的第一层，那么Vue3又是怎样处理这个问题的呢？
答：判断当前Reflect.get的返回值是否为Object，如果是则再通过reactive方法做代理， 这样就实现了深度观测。
监测数组的时候可能触发多次get/set，那么如何防止触发多次呢？？
答：我们可以判断key是否为当前被代理对象target自身属性，也可以判断旧值与新值是否相等，只有满足以上两个条件之一时，才有可能执行trigger。</code></pre>
<h4 id="nextTick知道吗，实现原理是什么？"><a href="#nextTick知道吗，实现原理是什么？" class="headerlink" title="nextTick知道吗，实现原理是什么？"></a>nextTick知道吗，实现原理是什么？</h4><pre><code>在下次 DOM 更新循环结束之后执行延迟回调。nextTick主要使用了宏任务和微任务。在修改数据之后立即使用这个方法，获取更新后的 DOM。
根据执行环境分别尝试采用Promise.then MutationObserver setImmediate如果以上都不行则采用setTimeout
定义了一个异步方法，多次调用nextTick会将方法存入队列中，通过这个异步方法清空当前队列。
使用场景：我们需要页面的所有数据都渲染完成后在获取数据，通过传统的方法无法获取到渲染后的数据，举个例子，页面中通过v-for渲染的li有12个，但是，
我们却在异步获取数据的函数中无法通过document.querySelector拿到所有的数据，此时就需要使用nextTick.</code></pre>
<h4 id="说一下v-model的原理"><a href="#说一下v-model的原理" class="headerlink" title="说一下v-model的原理?"></a>说一下v-model的原理?</h4><pre><code>v-model本质就是一个语法糖，可以看成是value + input方法的语法糖。 可以通过model属性的prop和event属性来进行自定义。原生的v-model，会根据标签的不同生成不同的事件和属性。</code></pre>
<h4 id="Vue事件绑定原理说一下"><a href="#Vue事件绑定原理说一下" class="headerlink" title="Vue事件绑定原理说一下?"></a>Vue事件绑定原理说一下?</h4><pre><code>原生事件绑定是通过addEventListener绑定给真实元素的，组件事件绑定是通过Vue自定义的$on实现的。</code></pre>
<h4 id="Vue中组件生命周期调用顺序说一下"><a href="#Vue中组件生命周期调用顺序说一下" class="headerlink" title="Vue中组件生命周期调用顺序说一下?"></a>Vue中组件生命周期调用顺序说一下?</h4><pre><code>组件的调用顺序都是先父后子,渲染完成的顺序是先子后父。
组件的销毁操作是先父后子，销毁完成的顺序是先子后父。
加载渲染过程
父beforeCreate-&gt;父created-&gt;父beforeMount-&gt;子beforeCreate-&gt;子created-&gt;子beforeMount- &gt;子mounted-&gt;父mounted
子组件更新过程
父beforeUpdate-&gt;子beforeUpdate-&gt;子updated-&gt;父updated
父组件更新过程
父 beforeUpdate -&gt; 父 updated
销毁过程
父beforeDestroy-&gt;子beforeDestroy-&gt;子destroyed-&gt;父destroyed</code></pre>
<h4 id="Vue2-x组件通信有哪些方式？"><a href="#Vue2-x组件通信有哪些方式？" class="headerlink" title="Vue2.x组件通信有哪些方式？"></a>Vue2.x组件通信有哪些方式？</h4><pre><code>父子组件通信
父-&gt;子props，子-&gt;父 $on、$emit
获取父子组件实例 $parent、$children
Ref 获取实例的方式调用组件的属性或者方法
兄弟组件通信
Event Bus 实现跨组件通信 Vue.prototype.$bus = new Vue
Vuex
跨级组件通信
Vuex
$attrs、$listeners
Provide、inject</code></pre>
<h4 id="你都做过哪些Vue的性能优化？"><a href="#你都做过哪些Vue的性能优化？" class="headerlink" title="你都做过哪些Vue的性能优化？"></a>你都做过哪些Vue的性能优化？</h4><pre><code>编码阶段

1,尽量减少data中的数据，data中的数据都会增加getter和setter，会收集对应的watcherv-if和v-for不能连用
2,如果需要使用v-for给每项元素绑定事件时使用事件代理SPA 页面采用keep-alive缓存组件在更多的情况下，
3,使用v-if替代v-show  key保证唯一使用路由懒加载、异步组件防抖、节流第三方模块按需导入长列表滚动到可视区域动态加载图片懒加载
4,SEO优化
5,预渲染服务端渲染SSR
6,打包优化
7,压缩代码Tree Shaking/Scope Hoisting使用cdn加载第三方模块多线程打包happypacksplitChunks抽离公共文件sourceMap优化用户体验
8,骨架屏 PWA</code></pre>
<h4 id="插槽之间是怎么传值的？"><a href="#插槽之间是怎么传值的？" class="headerlink" title="插槽之间是怎么传值的？"></a>插槽之间是怎么传值的？</h4><pre><code>可以用作用域插槽进行传值。子组件的slot标签中动态绑定属性，父组件中给template标签绑定(v-slot)值，子组件抛出来的接口，可以通过这个值访问到子组件的数据</code></pre>
<h4 id="vue中的内置组件有哪些？"><a href="#vue中的内置组件有哪些？" class="headerlink" title="vue中的内置组件有哪些？"></a>vue中的内置组件有哪些？</h4><pre><code>component、
transition、
transition-group、
keep-alive、
slot</code></pre>
<h4 id="vue中的transfrom组件是什么？"><a href="#vue中的transfrom组件是什么？" class="headerlink" title="vue中的transfrom组件是什么？"></a>vue中的transfrom组件是什么？</h4><pre><code>使用transfrom可以完成任何元素进入/离开的过渡效果。
它的用法是：首先在这个组件内设置一个那么属性，然后再css中用v-enter、v-enter-active、v-leave、v-leave-active
来实现整体的效果。</code></pre>
<h4 id="computed-是什么？实现原理？"><a href="#computed-是什么？实现原理？" class="headerlink" title="computed 是什么？实现原理？"></a>computed 是什么？实现原理？</h4><pre><code>是：计算属性。基于当前的数据进行简单的加工返回新的数据，当计算属性所依赖的数据发生变化时，它会自动进行计算。
写起来像函数，本质是属性。

对大量计算有优化效果。仅仅在依赖的数据发生变化时，才执行。
computed 内部实现了一个惰性的 watcher，在实例化的时候不会去求值，其内部通过 dirty 属性标记计算属性是否需要重新求值。
当 computed 依赖的任意状态发生改变，都会通知这个惰性的 watcher，让它把 dirty 属性设置为 true，所以，当再次读取这个计算属性的时候，就会重新去求值。
惰性的watcher 计算属性在创建时不会去求值的，是在使用时去求值。

computed 本质是一个惰性求值的观察者。

computed 内部实现了一个惰性的 watcher,也就是 computed watcher,computed watcher 不会立刻求值,同时持有一个 dep 实例。

其内部通过 this.dirty 属性标记计算属性是否需要重新求值。

当 computed 的依赖状态发生改变时,就会通知这个惰性的 watcher,

computed watcher 通过 this.dep.subs.length 判断有没有订阅者,

有的话,会重新计算,然后对比新旧值,如果变化了,会重新渲染。 (Vue 想确保不仅仅是计算属性依赖的值发生变化，而是当计算属性最终计算的值发生变化时才会触发渲染 watcher 重新渲染，本质上是一种优化。)
没有的话,仅仅把 this.dirty = true。 (**当计算属性依赖于其他数据时，属性并不会立即重新计算，只有之后其他地方需要读取属性的时候，它才会真正计算，即具备 lazy（懒计算）特性。**)</code></pre>
<h4 id="说说你对SPA单页面的理解"><a href="#说说你对SPA单页面的理解" class="headerlink" title="说说你对SPA单页面的理解"></a>说说你对SPA单页面的理解</h4><p>SPA（ single-page application ）仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS。一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转；<br>取而代之的是利用路由机制实现 HTML 内容的变换，UI 与用户的交互，避免页面的重新加载。</p>
<pre><code>优点：

用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染；
基于上面一点，SPA 相对对服务器压力小；
前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理；

缺点：

初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面按需加载；
前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理；
SEO 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。</code></pre>
<h4 id="直接给一个数组项赋值，Vue-能检测到变化吗？-使用-set"><a href="#直接给一个数组项赋值，Vue-能检测到变化吗？-使用-set" class="headerlink" title="直接给一个数组项赋值，Vue 能检测到变化吗？(使用$set)"></a>直接给一个数组项赋值，Vue 能检测到变化吗？(使用$set)</h4><p>不能<br>由于 JavaScript 的限制，Vue 不能检测到数组的变动</p>
<p>解决办法：</p>
<pre><code>Vue.set(target, key, newValue) (要更改的数据源[数组或对象]，要更改的数据[字符串或数字]，新值) //对数组
vm.$set（Vue.set的一个别名）// 对对象
Array.prototype.splice
vm.items.splice(newLength)修改数组的长度</code></pre>
</div><div id="reward-container"><span class="hty-icon-button button-glow" id="reward-button" title="Donate" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === &quot;none&quot;) ? &quot;block&quot; : &quot;none&quot;;"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-hand-coin-line"></use></svg></span><div id="reward-comment">喜欢的话就打赏点吧</div><div id="qr" style="display:none;"><div style="display:inline-block"></div><div style="display:inline-block"></div><div style="display:inline-block"></div></div></div><ul class="post-copyright"><li class="post-copyright-author"><strong>Post author: </strong>sun</li><li class="post-copyright-link"><strong>Post link: </strong><a href="http://example.com/2021/02/22/vue%E9%9D%A2%E8%AF%95%E9%A2%98/" title="vue面试题">http://example.com/2021/02/22/vue%E9%9D%A2%E8%AF%95%E9%A2%98/</a></li><li class="post-copyright-license"><strong>Copyright Notice: </strong>All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0 "><svg class="icon"><use xlink:href="#icon-creative-commons-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-by-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-nc-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-sa-line"></use></svg></a> unless otherwise stated.</li></ul></section></article><div class="post-nav"><div class="post-nav-item"><a class="post-nav-prev" href="/2021/02/23/react%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="prev" title="react面试题"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-left-s-line"></use></svg><span class="post-nav-text">react面试题</span></a></div><div class="post-nav-item"><a class="post-nav-next" href="/2021/02/22/JS%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="next" title="JS面试题"><span class="post-nav-text">JS面试题</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-right-s-line"></use></svg></a></div></div></div><div id="comment"><div class="comment-tooltip text-center"><span>点击按钮跳转 GitHub Issues 评论。</span><br><span>若没有本文 Issue，您可以使用 Comment 模版新建。</span><br><a class="hty-button hty-button--raised" id="github-issues" target="_blank" rel="noopener" href="https://github.com/YunYouJun/yunyoujun.github.io/issues?q=is:issue+vue面试题">GitHub Issues</a></div></div></main><footer class="sidebar-translate" id="footer"><div class="copyright"><span>&copy; 2019 – 2022 </span><span class="with-love" id="animate"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-cloud-line"></use></svg></span><span class="author"> sun</span></div><div class="powered"><span>Powered by <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> v5.3.0</span><span class="footer-separator">|</span><span>Theme - <a rel="noopener" href="https://github.com/YunYouJun/hexo-theme-yun" target="_blank"><span>Yun</span></a> v1.3.0</span></div></footer><a class="hty-icon-button" id="goUp" aria-label="back-to-top" href="#"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-up-s-line"></use></svg><svg class="progress-circle-container" viewBox="0 0 100 100"><circle class="progress-circle" id="progressCircle" cx="50" cy="50" r="48" fill="none" stroke="#0078E7" stroke-width="2" stroke-linecap="round"></circle></svg></a></div><script defer src="/js/utils.js"></script><script defer src="/js/hexo-theme-yun.js"></script></body></html>