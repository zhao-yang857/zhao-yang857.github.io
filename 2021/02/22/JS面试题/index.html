<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="theme-color" content="#0078E7"><meta name="author" content="sun"><meta name="copyright" content="sun"><meta name="generator" content="Hexo 5.3.0"><meta name="theme" content="hexo-theme-yun"><title>JS面试题 | 太阳の小屋</title><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@900&amp;display=swap" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/star-markdown-css@0.1.22/dist/yun/yun-markdown.min.css"><script src="//at.alicdn.com/t/font_1140697_ed8vp4atwoj.js" async></script><script src="https://cdn.jsdelivr.net/npm/scrollreveal/dist/scrollreveal.min.js" defer></script><script>document.addEventListener("DOMContentLoaded", () => {
  [".post-card",".post-content img"].forEach((target)=> {
    ScrollReveal().reveal(target);
  })
});
</script><link rel="shortcut icon" type="image/svg+xml" href="/feng.ico"><link rel="mask-icon" href="/feng.ico" color="#0078E7"><link rel="alternate icon" href="/yun.ico"><link rel="preload" href="/css/hexo-theme-yun.css" as="style"><link rel="preload" href="/js/utils.js" as="script"><link rel="preload" href="/js/hexo-theme-yun.js" as="script"><link rel="prefetch" href="/js/sidebar.js" as="script"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><link rel="stylesheet" href="/css/hexo-theme-yun.css"><script id="yun-config">
    const Yun = window.Yun || {};
    window.CONFIG = {"hostname":"example.com","root":"/","title":"太阳の小屋","version":"1.3.0","mode":"auto","copycode":true,"anonymous_image":"https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/avatar/none.jpg","say":{"api":"https://v1.hitokoto.cn","hitokoto":true},"fireworks":{"colors":["219, 34, 9","216, 35, 223","252, 89, 170","89, 187, 252","103, 252, 89"]}};
  </script><meta name="description" content="js是什么语言js是一种运行在浏览器的脚本语言，这种语言主要的功能是可以制作出动态的页面的效果 我们可以通过js+css+html布局来形成我们现在可以访问展示的页面  js语言是弱语言类型， 因此我们在项目开发中当我们随意更改某个变量的数据类型后 有可能会导致其他引用这个变量的方法中报错等等。 js的基本数据类型有哪些，基本数据类型和复杂数据类型的区别基本：String、Number、Boole">
<meta property="og:type" content="article">
<meta property="og:title" content="JS面试题">
<meta property="og:url" content="http://example.com/2021/02/22/JS%E9%9D%A2%E8%AF%95%E9%A2%98/index.html">
<meta property="og:site_name" content="太阳の小屋">
<meta property="og:description" content="js是什么语言js是一种运行在浏览器的脚本语言，这种语言主要的功能是可以制作出动态的页面的效果 我们可以通过js+css+html布局来形成我们现在可以访问展示的页面  js语言是弱语言类型， 因此我们在项目开发中当我们随意更改某个变量的数据类型后 有可能会导致其他引用这个变量的方法中报错等等。 js的基本数据类型有哪些，基本数据类型和复杂数据类型的区别基本：String、Number、Boole">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2021-02-22T06:35:33.000Z">
<meta property="article:modified_time" content="2022-05-07T02:10:40.558Z">
<meta property="article:author" content="sun">
<meta name="twitter:card" content="summary"><script src="/js/ui/mode.js"></script></head><body><script defer src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script defer src="/js/ui/fireworks.js"></script><canvas class="fireworks"></canvas><div class="container"><a class="sidebar-toggle hty-icon-button" id="menu-btn"><div class="hamburger hamburger--spin" type="button"><span class="hamburger-box"><span class="hamburger-inner"></span></span></div></a><div class="sidebar-toggle sidebar-overlay"></div><aside class="sidebar"><script src="/js/sidebar.js"></script><ul class="sidebar-nav"><li class="sidebar-nav-item sidebar-nav-toc hty-icon-button sidebar-nav-active" data-target="post-toc-wrap" title="Table of Contents"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-list-ordered"></use></svg></li><li class="sidebar-nav-item sidebar-nav-overview hty-icon-button" data-target="site-overview-wrap" title="Overview"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-passport-line"></use></svg></li></ul><div class="sidebar-panel" id="site-overview-wrap"><div class="site-info fix-top"><a class="site-author-avatar" href="/about/" title="sun"><img width="96" loading="lazy" src="/images/%E5%A4%B4%E5%83%8F6.jpeg" alt="sun"></a><div class="site-author-name"><a href="/about/">sun</a></div><a class="site-name" href="/about/site.html">太阳の小屋</a><sub class="site-subtitle"></sub><div class="site-desciption"></div></div><nav class="site-state"><a class="site-state-item hty-icon-button icon-home" href="/" title="首页"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-home-4-line"></use></svg></span></a><div class="site-state-item"><a href="/archives/" title="归档"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-archive-line"></use></svg></span><span class="site-state-item-count">21</span></a></div><div class="site-state-item"><a href="/categories/" title="分类"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-2-line"></use></svg></span><span class="site-state-item-count">1</span></a></div><div class="site-state-item"><a href="/tags/" title="标签"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="site-state-item-count">3</span></a></div><a class="site-state-item hty-icon-button" target="_blank" rel="noopener" href="https://yun.yunyoujun.cn" title="留言板"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-clipboard-line"></use></svg></span></a></nav><hr style="margin-bottom:0.5rem"><div class="links-of-author"><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://qm.qq.com/cgi-bin/qm/qr?k=epvxdq1sknJe9JMj6J1LsBw4a6cI_2ln&amp;jump_from=webapi" title="QQ" target="_blank" style="color:#12B7F5"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-qq-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://github.com/zhao-yang857" title="GitHub" target="_blank" style="color:#6e5494"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-github-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://music.163.com/#/user/home?id=333632364" title="网易云音乐" target="_blank" style="color:#C20C0C"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-netease-cloud-music-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://space.bilibili.com/74908726" title="哔哩哔哩" target="_blank" style="color:#FF8EB3"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-bilibili-line"></use></svg></a></div><hr style="margin:0.5rem 1rem"><div class="links"><a class="links-item hty-icon-button" href="/links/" title="我的小伙伴们" style="color:dodgerblue"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-genderless-line"></use></svg></a><a class="links-item hty-icon-button" href="/girls/" title="我喜欢的女孩儿们" style="color:hotpink"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-women-line"></use></svg></a></div><br><a class="links-item hty-icon-button" id="toggle-mode-btn" href="javascript:;" title="Mode" style="color: #f1cb64"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-contrast-2-line"></use></svg></a></div><div class="sidebar-panel sidebar-panel-active" id="post-toc-wrap"><div class="post-toc"><div class="post-toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#js%E6%98%AF%E4%BB%80%E4%B9%88%E8%AF%AD%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">js是什么语言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#js%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%8C%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%A4%8D%E6%9D%82%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.</span> <span class="toc-text">js的基本数据类型有哪些，基本数据类型和复杂数据类型的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%92%8C-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">3.</span> <span class="toc-text">&#x3D;&#x3D; 和 &#x3D;&#x3D;&#x3D; 有什么区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E4%B8%BE3%E7%A7%8D%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%92%8C2%E7%A7%8D%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">4.</span> <span class="toc-text">例举3种强制类型转换和2种隐式类型转换?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#split-%E5%92%8C-join-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">5.</span> <span class="toc-text">split() 和 join() 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ajax%E8%AF%B7%E6%B1%82%E7%9A%84%E6%97%B6%E5%80%99get-%E5%92%8Cpost%E6%96%B9%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">6.</span> <span class="toc-text">ajax请求的时候get 和post方式的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%87%8Ajsonp%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%8C%E4%BB%A5%E5%8F%8A%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%98%AF%E7%9C%9F%E6%AD%A3%E7%9A%84ajax"><span class="toc-number">7.</span> <span class="toc-text">解释jsonp的原理，以及为什么不是真正的ajax</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#call-%E3%80%81bind-%E3%80%81apply-%E5%8C%BA%E5%88%AB"><span class="toc-number">8.</span> <span class="toc-text">call()、bind()、apply()区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E6%9C%89%E5%93%AA%E4%BA%9B%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95"><span class="toc-number">9.</span> <span class="toc-text">数组有哪些操作方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E6%9C%89%E5%93%AA%E4%BA%9B%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95"><span class="toc-number">10.</span> <span class="toc-text">对象有哪些操作方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%97%AD%E5%8C%85-%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E6%80%A7%EF%BC%8C%E5%AF%B9%E9%A1%B5%E9%9D%A2%E6%9C%89%E4%BB%80%E4%B9%88%E5%BD%B1%E5%93%8D"><span class="toc-number">11.</span> <span class="toc-text">什么是闭包,有什么特性，对页面有什么影响</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AD%E5%8C%85%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-number">11.1.</span> <span class="toc-text">闭包的好处</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9A%82%E6%97%B6%E6%80%A7%E6%AD%BB%E5%8C%BA"><span class="toc-number">11.2.</span> <span class="toc-text">暂时性死区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E5%88%9B%E5%BB%BA%E9%97%AD%E5%8C%85"><span class="toc-number">11.3.</span> <span class="toc-text">怎么创建闭包</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%98%BB%E6%AD%A2%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1"><span class="toc-number">12.</span> <span class="toc-text">如何阻止事件冒泡</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%98%BB%E6%AD%A2%E9%BB%98%E8%AE%A4%E4%BA%8B%E4%BB%B6%E3%80%81%E9%98%BB%E6%AD%A2%E6%A0%87%E7%AD%BE%E8%87%AA%E5%B8%A6%E5%8A%9F%E8%83%BD"><span class="toc-number">13.</span> <span class="toc-text">如何阻止默认事件、阻止标签自带功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0%E7%BA%A7%E4%BA%8B%E4%BB%B6%E5%92%8C2%E7%BA%A7%E4%BA%8B%E4%BB%B6"><span class="toc-number">14.</span> <span class="toc-text">0级事件和2级事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0-%E5%88%A0%E9%99%A4-%E6%9B%BF%E6%8D%A2-%E6%8F%92%E5%85%A5%E5%88%B0%E6%9F%90%E4%B8%AA%E6%8E%A5%E7%82%B9%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">15.</span> <span class="toc-text">添加 删除 替换 插入到某个接点的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#null-%E5%92%8C-undefined-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">16.</span> <span class="toc-text">null 和 undefined 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87"><span class="toc-number">17.</span> <span class="toc-text">什么是变量提升</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98"><span class="toc-number">18.</span> <span class="toc-text">什么是事件委托</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-number">19.</span> <span class="toc-text">深拷贝和浅拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#async%E4%B8%8Edefer%E5%8C%BA%E5%88%AB"><span class="toc-number">20.</span> <span class="toc-text">async与defer区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cookies%EF%BC%8CsessionStorage%E5%92%8ClocalStorage-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">21.</span> <span class="toc-text">cookies，sessionStorage和localStorage 有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95"><span class="toc-number">22.</span> <span class="toc-text">数组去重有哪些方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A9%E7%94%A8ES6-Set%E5%8E%BB%E9%87%8D"><span class="toc-number">22.1.</span> <span class="toc-text">利用ES6 Set去重</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E5%86%92%E6%B3%A1for%E5%BE%AA%E7%8E%AF%E5%B5%8C%E5%A5%97%EF%BC%8C%E7%84%B6%E5%90%8Esplice-%E5%8E%BB%E9%87%8D-%E5%A6%82%EF%BC%9A"><span class="toc-number">22.2.</span> <span class="toc-text">利用冒泡for循环嵌套，然后splice()去重 如：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#indexOf-%E5%8E%BB%E9%87%8D-%E5%A6%82%EF%BC%9A"><span class="toc-number">22.3.</span> <span class="toc-text">indexOf()去重 如：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sort-%E5%8E%BB%E9%87%8D-%E5%A6%82%EF%BC%9A"><span class="toc-number">22.4.</span> <span class="toc-text">sort()去重 如：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#filter-%E5%8E%BB%E9%87%8D-%E5%A6%82"><span class="toc-number">22.5.</span> <span class="toc-text">filter()去重 如:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%EF%BC%9F"><span class="toc-number">22.6.</span> <span class="toc-text">一行代码实现数组去重？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="toc-number">22.7.</span> <span class="toc-text">冒泡排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%99%8D%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">22.8.</span> <span class="toc-text">降维数组</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5"><span class="toc-number">23.</span> <span class="toc-text">同源策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%A8%E5%9F%9F%E6%9C%89%E5%87%A0%E7%A7%8D%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">24.</span> <span class="toc-text">跨域有几种解决方案</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-jsonp"><span class="toc-number">24.1.</span> <span class="toc-text">1. jsonp</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-document-domain-iframe-%EF%BC%88%E9%80%82%E7%94%A8%E4%BA%8E%E4%B8%BB%E5%9F%9F%E5%90%8D%E7%9B%B8%E5%90%8C-%E5%AD%90%E5%9F%9F%E5%90%8D%E4%B8%8D%E5%90%8C-%E4%B8%A4%E4%B8%AA%E9%A1%B5%E9%9D%A2%E9%83%BD%E9%80%9A%E8%BF%87js%E5%BC%BA%E5%88%B6%E8%AE%BE%E7%BD%AEdocument-domain%E4%B8%BA%E5%9F%BA%E7%A1%80%E4%B8%BB%E5%9F%9F%EF%BC%8C%E5%B0%B1%E5%AE%9E%E7%8E%B0%E4%BA%86%E5%90%8C%E5%9F%9F%EF%BC%89"><span class="toc-number">24.2.</span> <span class="toc-text">2. document.domain + iframe （适用于主域名相同 子域名不同  两个页面都通过js强制设置document.domain为基础主域，就实现了同域）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-location-hash-iframe"><span class="toc-number">24.3.</span> <span class="toc-text">3. location.hash + iframe</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-window-name-iframe"><span class="toc-number">24.4.</span> <span class="toc-text">4. window.name + iframe</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-postMessage-data-origin-%E6%96%B9%E6%B3%95%E6%8E%A5%E5%8F%97%E4%B8%A4%E4%B8%AA%E5%8F%82%E6%95%B0"><span class="toc-number">24.5.</span> <span class="toc-text">5. postMessage (data,origin)方法接受两个参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E8%B7%A8%E5%9F%9F%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB%EF%BC%88CORS%EF%BC%89"><span class="toc-number">24.6.</span> <span class="toc-text">6. 跨域资源共享（CORS）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#axios%E5%92%8Cajax%E5%92%8Cfetch%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">25.</span> <span class="toc-text">axios和ajax和fetch的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#typeof%E5%92%8Cinstanceof%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">26.</span> <span class="toc-text">typeof和instanceof有什么区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E%E4%B8%8E%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">27.</span> <span class="toc-text">函数声明与函数表达式的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Javascript%E7%9A%84%E4%BA%8B%E4%BB%B6%E6%B5%81%E6%A8%A1%E5%9E%8B%E9%83%BD%E6%9C%89%E4%BB%80%E4%B9%88"><span class="toc-number">28.</span> <span class="toc-text">Javascript的事件流模型都有什么?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%8C%E6%9C%9B%E8%8E%B7%E5%8F%96%E5%88%B0%E9%A1%B5%E9%9D%A2%E4%B8%AD%E6%89%80%E6%9C%89%E7%9A%84checkbox%E6%80%8E%E4%B9%88%E5%81%9A%EF%BC%9F-%E4%B8%8D%E4%BD%BF%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6"><span class="toc-number">29.</span> <span class="toc-text">希望获取到页面中所有的checkbox怎么做？(不使用第三方框架)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96javascript%E4%B8%89%E4%B8%AA%E6%95%B0%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC%E5%92%8C%E6%9C%80%E5%B0%8F%E5%80%BC%EF%BC%9F"><span class="toc-number">30.</span> <span class="toc-text">如何获取javascript三个数中的最大值和最小值？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#javascript%E6%98%AF%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%EF%BC%8C%E6%80%8E%E4%B9%88%E4%BD%93%E7%8E%B0javascript%E7%9A%84%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%EF%BC%9F"><span class="toc-number">31.</span> <span class="toc-text">javascript是面向对象的，怎么体现javascript的继承关系？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%97%E4%B8%BEjavaScript%E7%9A%843%E7%A7%8D%E4%B8%BB%E8%A6%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%8C2%E7%A7%8D%E5%A4%8D%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C2%E7%A7%8D%E7%89%B9%E6%AE%8A%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E3%80%82"><span class="toc-number">32.</span> <span class="toc-text">列举javaScript的3种主要数据类型，2种复合数据类型和2种特殊数据类型。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A%E4%BB%80%E4%B9%88%E6%98%AFJson"><span class="toc-number">33.</span> <span class="toc-text">解释什么是Json:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#js%E4%B8%AD%E7%9A%843%E7%A7%8D%E5%BC%B9%E5%87%BA%E5%BC%8F%E6%B6%88%E6%81%AF%E6%8F%90%E9%86%92%EF%BC%88%E8%AD%A6%E5%91%8A%E7%AA%97%E5%8F%A3%EF%BC%8C%E7%A1%AE%E8%AE%A4%E7%AA%97%E5%8F%A3%EF%BC%8C%E4%BF%A1%E6%81%AF%E8%BE%93%E5%85%A5%E7%AA%97%E5%8F%A3%EF%BC%89%E7%9A%84%E5%91%BD%E4%BB%A4%E5%BC%8F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">34.</span> <span class="toc-text">js中的3种弹出式消息提醒（警告窗口，确认窗口，信息输入窗口）的命令式什么？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E6%BB%9A%E5%8A%A8%E8%B7%9D%E7%A6%BB%EF%BC%9A"><span class="toc-number">34.1.</span> <span class="toc-text">浏览器的滚动距离：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#innerHTML%E3%80%81innerText%E5%92%8CouterHTML%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">35.</span> <span class="toc-text">innerHTML、innerText和outerHTML的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#offsetWidth-offsetHeight%E5%92%8CclientWidth-clientHeight%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">36.</span> <span class="toc-text">offsetWidth offsetHeight和clientWidth clientHeight的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B7%E8%AF%B4%E5%87%BA%E4%B8%89%E7%A7%8D%E5%87%8F%E4%BD%8E%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E6%97%B6%E9%97%B4%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">37.</span> <span class="toc-text">请说出三种减低页面加载时间的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B7%E8%A7%A3%E9%87%8A%E4%BB%80%E4%B9%88%E6%98%AFJavascript%E7%9A%84%E6%A8%A1%E5%9D%97%E6%A8%A1%E5%BC%8F%EF%BC%8C%E5%B9%B6%E4%B8%BE%E5%87%BA%E5%AE%9E%E7%94%A8%E5%AE%9E%E4%BE%8B%E3%80%82"><span class="toc-number">38.</span> <span class="toc-text">请解释什么是Javascript的模块模式，并举出实用实例。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%A0%E5%A6%82%E4%BD%95%E7%BB%84%E7%BB%87%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81%EF%BC%9F%E6%98%AF%E4%BD%BF%E7%94%A8%E6%A8%A1%E5%9D%97%E6%A8%A1%E5%BC%8F%EF%BC%8C%E8%BF%98%E6%98%AF%E4%BD%BF%E7%94%A8%E7%BB%8F%E5%85%B8%E7%BB%A7%E6%89%BF%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-number">39.</span> <span class="toc-text">你如何组织自己的代码？是使用模块模式，还是使用经典继承的方法？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%A0%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81%EF%BC%9F"><span class="toc-number">40.</span> <span class="toc-text">你如何优化自己的代码？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%A0%E8%83%BD%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8BJavaScript%E4%B8%AD%E7%9A%84%E7%BB%A7%E6%89%BF%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%90%97%EF%BC%9F"><span class="toc-number">40.1.</span> <span class="toc-text">你能解释一下JavaScript中的继承是如何工作的吗？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dom%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98%E4%BB%80%E4%B9%88%E5%8E%9F%E7%90%86%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">41.</span> <span class="toc-text">dom事件委托什么原理，有什么优缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#js%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E8%BF%99%E4%B8%AA%E5%89%8D%E6%8F%90%E6%9D%A1%E4%BB%B6%E4%B8%8B%E5%86%99%E4%B8%80%E4%B8%AAgetType%EF%BC%8C%E8%BF%94%E5%9B%9E%E7%9B%B8%E5%BA%94%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">42.</span> <span class="toc-text">js基础数据类型和引用类型分别是什么？这个前提条件下写一个getType，返回相应的类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#js%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E7%9F%A5%E9%81%93%E5%93%AA%E4%BA%9B%EF%BC%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E7%9A%84%E5%A5%BD%E5%A4%84%E5%92%8C%E5%9D%8F%E5%A4%84"><span class="toc-number">43.</span> <span class="toc-text">js垃圾回收机制知道哪些，垃圾回收机制的好处和坏处</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="toc-number">43.1.</span> <span class="toc-text">什么是垃圾回收机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">43.2.</span> <span class="toc-text">内存泄漏的原因</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">43.3.</span> <span class="toc-text">垃圾回收的方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#setTimeout-%E5%92%8C-setInterval-%E7%BB%86%E8%B0%88"><span class="toc-number">44.</span> <span class="toc-text">setTimeout 和 setInterval 细谈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E6%95%B0%E7%BB%84"><span class="toc-number">45.</span> <span class="toc-text">判断数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#window-name"><span class="toc-number">46.</span> <span class="toc-text">window.name</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#forEach%E5%92%8Cmap%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">47.</span> <span class="toc-text">forEach和map的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%90%8C%E7%82%B9"><span class="toc-number">47.1.</span> <span class="toc-text">相同点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E7%82%B9"><span class="toc-number">47.2.</span> <span class="toc-text">不同点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E2%80%94%E2%80%94%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE"><span class="toc-number">48.</span> <span class="toc-text">面向对象——原型与原型链</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B"><span class="toc-number">48.1.</span> <span class="toc-text">原型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E9%93%BE"><span class="toc-number">48.2.</span> <span class="toc-text">原型链</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E9%93%BE%E4%B8%8E%E9%9A%90%E5%BC%8F%E5%8E%9F%E5%9E%8B"><span class="toc-number">48.3.</span> <span class="toc-text">原型链与隐式原型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E9%83%A8%E6%9B%B2"><span class="toc-number">48.4.</span> <span class="toc-text">面向对象三部曲</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%85%B3%E9%94%AE%E5%90%8D%E7%A7%B0%E6%80%BB%E7%BB%93"><span class="toc-number">48.5.</span> <span class="toc-text">面向对象关键名称总结</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%A1%88%E4%BE%8B"><span class="toc-number">48.5.1.</span> <span class="toc-text">原型链案例</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%85%A5URL%E5%9B%9E%E8%BD%A6%E5%90%8E%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">48.6.</span> <span class="toc-text">输入URL回车后的过程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tcp%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C4%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-number">49.</span> <span class="toc-text">tcp三次握手和4次挥手</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="toc-number">49.1.</span> <span class="toc-text">三次握手</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-number">49.2.</span> <span class="toc-text">四次挥手</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%B2%E6%8A%96%E8%8A%82%E6%B5%81"><span class="toc-number">50.</span> <span class="toc-text">防抖节流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%B2%E6%8A%96%EF%BC%88debounce%EF%BC%89"><span class="toc-number">50.1.</span> <span class="toc-text">防抖（debounce）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8A%82%E6%B5%81"><span class="toc-number">50.2.</span> <span class="toc-text">节流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">50.3.</span> <span class="toc-text">防抖和节流的区别？</span></a></li></ol></li></ol></div></div></div></aside><main class="sidebar-translate" id="content"><div id="post"><article class="post-block" itemscope itemtype="https://schema.org/Article"><link itemprop="mainEntityOfPage" href="http://example.com/2021/02/22/JS%E9%9D%A2%E8%AF%95%E9%A2%98/"><span hidden itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="name" content="sun"><meta itemprop="description"></span><span hidden itemprop="publisher" itemscope itemtype="https://schema.org/Organization"><meta itemprop="name" content="太阳の小屋"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">JS面试题</h1><div class="post-meta"><div class="post-time" style="display:inline-block"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-line"></use></svg></span> <time title="Created: 2021-02-22 14:35:33" itemprop="dateCreated datePublished" datetime="2021-02-22T14:35:33+08:00">2021-02-22</time><span class="post-meta-divider">-</span><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-2-line"></use></svg></span> <time title="Modified: 2022-05-07 10:10:40" itemprop="dateModified" datetime="2022-05-07T10:10:40+08:00">2022-05-07</time></div><div class="post-classify"></div></div></header><section class="post-body" itemprop="articleBody"><div class="post-content markdown-body" style="--smc-primary:#0078E7;"><h3 id="js是什么语言"><a href="#js是什么语言" class="headerlink" title="js是什么语言"></a>js是什么语言</h3><pre><code>js是一种运行在浏览器的脚本语言，这种语言主要的功能是可以制作出动态的页面的效果
我们可以通过js+css+html布局来形成我们现在可以访问展示的页面

js语言是弱语言类型， 因此我们在项目开发中当我们随意更改某个变量的数据类型后
有可能会导致其他引用这个变量的方法中报错等等。</code></pre>
<h3 id="js的基本数据类型有哪些，基本数据类型和复杂数据类型的区别"><a href="#js的基本数据类型有哪些，基本数据类型和复杂数据类型的区别" class="headerlink" title="js的基本数据类型有哪些，基本数据类型和复杂数据类型的区别"></a>js的基本数据类型有哪些，基本数据类型和复杂数据类型的区别</h3><pre><code>基本：String、Number、Boolean、Null、undefined

复杂：Object</code></pre>
<p>区别：</p>
<pre><code>基本数据类型把数据名和值直接存储在栈当中

复杂数据类型在栈中存储数据名和一个堆的地址，在堆中存储属性和值，访问时先从栈中获取地址再到堆中取相应的值</code></pre>
<h3 id="和-有什么区别"><a href="#和-有什么区别" class="headerlink" title="== 和 === 有什么区别"></a>== 和 === 有什么区别</h3><pre><code>==用于一般比较 比较时可以转换数据类型 

===用于严格比较 比较时只要类型不匹配就返回false</code></pre>
<h3 id="例举3种强制类型转换和2种隐式类型转换"><a href="#例举3种强制类型转换和2种隐式类型转换" class="headerlink" title="例举3种强制类型转换和2种隐式类型转换?"></a>例举3种强制类型转换和2种隐式类型转换?</h3><pre><code>强制：通过String（），Number（），Boolean（）函数强制转换
隐式：（乘，除，大于，小于，减，==）</code></pre>
<h3 id="split-和-join-的区别"><a href="#split-和-join-的区别" class="headerlink" title="split() 和 join() 的区别"></a>split() 和 join() 的区别</h3><pre><code>split() 字符串转数组 如：var str = &quot;hello?word?welcome&quot;  console.log(str.split(“？”)) 返回值为 [&quot;hello&quot;, &quot;word&quot;, &quot;welcome&quot;]

join() 数组转字符串 如：var arr = new Array() arr[0] = &quot;hello&quot; arr[1] = &quot;world&quot; arr[3] = &quot;welcome&quot; arr.join(&quot;、&quot;)  返回值为 &quot;hello、world、welcome&quot;</code></pre>
<h3 id="ajax请求的时候get-和post方式的区别"><a href="#ajax请求的时候get-和post方式的区别" class="headerlink" title="ajax请求的时候get 和post方式的区别"></a>ajax请求的时候get 和post方式的区别</h3><pre><code>1.使用Get请求时,参数在URL中显示，安全性比较低,而post请求在send（）方法中传递参数,使用Post方式,则不会显示出来。
2.使用Get请求发送数据量小,Post请求发送数据量大。
3.get请求可以被缓存,post不可以，不建议被缓存，每次调用都会对服务器资源造成影响。
4.post请求必须设置Content-Type值为application/x-form-www-urlencoded。
5.发送请求时,因为get请求的参数都在url里,所以send函数发送的参数为null,而post请求在使用send方法时,却需赋予其参数。</code></pre>
<h3 id="解释jsonp的原理，以及为什么不是真正的ajax"><a href="#解释jsonp的原理，以及为什么不是真正的ajax" class="headerlink" title="解释jsonp的原理，以及为什么不是真正的ajax"></a>解释jsonp的原理，以及为什么不是真正的ajax</h3><pre><code>jsonp的核心原理就是目标页面回调本地页面的方法,并带入参数
动态创建script标签，使用回调函数作为参数
Ajax是页面无刷新请求数据操作</code></pre>
<h3 id="call-、bind-、apply-区别"><a href="#call-、bind-、apply-区别" class="headerlink" title="call()、bind()、apply()区别"></a>call()、bind()、apply()区别</h3><pre><code>三者都是可以改变this的指向

call调用 将方法中的this指向call中第一个参数，第一个参数是对象 后面是字符串。当第一个参数为null、undefined时，默认指向window; call中第一个参数之后是要传递给方法的参数列表。

apply与call相似，不同之处在于传递给方法的参数形式不一致。apply传递给方法的参数是数组的形式。第一个参数是对象  后面是数组

call和apply在改变方法的this指向时，会同时执行方法；

而bind不会执行方法，而是返回改变this指向后的新方法。bind() 返回对应函数便于稍后调用；call()、apply()则是立即调用</code></pre>
<h3 id="数组有哪些操作方法"><a href="#数组有哪些操作方法" class="headerlink" title="数组有哪些操作方法"></a>数组有哪些操作方法</h3><pre><code>unshift()  把参数添加到数组开头
shift() 把数组的第一个元素删除
push() 向数组末尾添加一个或多个元素
pop() 把数组的最后一个元素删除 
concat() 连接两个或多个数组
join() 数组转成字符串
reverse() 数组倒叙
slice() 截取后返回新数组 [&#39;H&#39;,&#39;el&#39;,&#39;lo&#39;,&#39;wo&#39;,&#39;rld!&#39;].slice(1,3) 返回 [&quot;el&quot;, &quot;lo&quot;]
splice() 添加或删除数组中的元素，这种方法会改变原始数组
sort() 数组元素排序
forEach() 遍历数组
filter() 返回符合条件的新数组，arr.filter((item,index,arr)=&gt;&#123;return 测试语句&#125;)
Map()  </code></pre>
<h3 id="对象有哪些操作方法"><a href="#对象有哪些操作方法" class="headerlink" title="对象有哪些操作方法"></a>对象有哪些操作方法</h3><pre><code>assign() 合并对像
is() 对象比较是否严格相等
keys() 遍历键名，返回所有键名数组
values() 遍历键值，返回键值数组</code></pre>
<h3 id="什么是闭包-有什么特性，对页面有什么影响"><a href="#什么是闭包-有什么特性，对页面有什么影响" class="headerlink" title="什么是闭包,有什么特性，对页面有什么影响"></a>什么是闭包,有什么特性，对页面有什么影响</h3><p>可以调用其它函数内部变量的函数</p>
<pre><code>简单来说就是函数嵌套函数，内部函数引用来外部函数的变量，从而导致来垃圾回收机制没有生效，变量被保存来下来。
也就是所谓的内存泄漏，然后由于内存泄漏又会导致你项目逐渐变得卡顿等等问题。因此要避免内存泄漏。

优点：避免变量污染、加强了封装性，逻辑性比较强代码的可读性高；加载到内存中执行效率高；

缺点：在内存中，造成了内存浪费，如果滥用闭包是灾难性的；</code></pre>
<h4 id="闭包的好处"><a href="#闭包的好处" class="headerlink" title="闭包的好处"></a>闭包的好处</h4><pre><code>(1)希望一个变量长期驻扎在内存当中(不被垃圾回收机制回收)

(2)避免全局变量的污染

(3)私有成员的存在

(4)安全性提高</code></pre>
<h4 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h4><pre><code>只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。
假如存在全局变量tmp，但是块级作用域内let又声明了一个局部变量tmp，导致后者绑定这个块级作用域，所以在let声明变量前，对tmp赋值会报错。</code></pre>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var tmp &#x3D; 123;</span><br><span class="line"> </span><br><span class="line">if (true) &#123;</span><br><span class="line">  tmp &#x3D; &#39;abc&#39;; &#x2F;&#x2F; ReferenceError</span><br><span class="line">  let tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">上面代码中，存在全局变量tmp，但是块级作用域内let又声明了一个局部变量tmp，导致后者绑定这个块级作用域，所以在let声明变量前，对tmp赋值会报错。</span><br><span class="line"></span><br><span class="line">ES6 明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。</span><br><span class="line">（access &#39;a&#39; before initialization 在初始化之前无法访问a）</span><br><span class="line"></span><br><span class="line">总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。</span><br></pre></td></tr></table></figure>
<h4 id="怎么创建闭包"><a href="#怎么创建闭包" class="headerlink" title="怎么创建闭包"></a>怎么创建闭包</h4><pre><code>在函数内部嵌套使用函数</code></pre>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function fn() &#123;</span><br><span class="line">        for (var i &#x3D; 0; i &lt; 2; i++) &#123;</span><br><span class="line">            (function () &#123;</span><br><span class="line">                var variate &#x3D; i;</span><br><span class="line">                setTimeout(function () &#123;</span><br><span class="line">                    console.log(&quot;setTimeout执行后:&quot;+variate);</span><br><span class="line">                &#125;, 1000);</span><br><span class="line">            &#125;)();&#x2F;&#x2F;闭包,立即执行函数,匿名函数</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        console.log(i);&#x2F;&#x2F;2</span><br><span class="line">        console.log(variate);&#x2F;&#x2F;variate is not defined</span><br><span class="line">    &#125;</span><br><span class="line">    fn();</span><br></pre></td></tr></table></figure>
<h3 id="如何阻止事件冒泡"><a href="#如何阻止事件冒泡" class="headerlink" title="如何阻止事件冒泡"></a>如何阻止事件冒泡</h3><pre><code>e.stopPropagation()（IE:window.event.cancelBubble=true）</code></pre>
<h3 id="如何阻止默认事件、阻止标签自带功能"><a href="#如何阻止默认事件、阻止标签自带功能" class="headerlink" title="如何阻止默认事件、阻止标签自带功能"></a>如何阻止默认事件、阻止标签自带功能</h3><pre><code>e.preventDefault()（IE:window.event.returnValue=false）</code></pre>
<h3 id="0级事件和2级事件"><a href="#0级事件和2级事件" class="headerlink" title="0级事件和2级事件"></a>0级事件和2级事件</h3><pre><code>0级：dom.on事件名称=function()&#123;&#125;
2级：dom.addEvenListener(&#39;事件类型&#39;,function()&#123;&#125;,布尔值(为true表在捕du获阶段调用处理函数.false在冒泡阶段调用.为了兼zhi,一般都用false))</code></pre>
<h3 id="添加-删除-替换-插入到某个接点的方法"><a href="#添加-删除-替换-插入到某个接点的方法" class="headerlink" title="添加 删除 替换 插入到某个接点的方法"></a>添加 删除 替换 插入到某个接点的方法</h3><pre><code>1）创建新节点
createElement() //创建一个具体的元素
createTextNode() //创建一个文本节点

2）添加、移除、替换、插入
appendChild() //添加
removeChild() //移除
replaceChild() //替换
insertBefore() //插入

3）查找
getElementsByTagName() //通过标签名称
getElementsByName() //通过元素的Name属性的值
getElementById() //通过元素Id，唯一性</code></pre>
<h3 id="null-和-undefined-的区别"><a href="#null-和-undefined-的区别" class="headerlink" title="null 和 undefined 的区别"></a>null 和 undefined 的区别</h3><pre><code>null表示没有对象，该处不该有值，转为数值时为0

undefined表示缺少值，该处应该有值，但是未定义，转为数值时为NaN
undefined是当你声明一个变量没有赋值的时候，，我们引用这个变量，他就是一个undefined ，那么null呢 他是typeof（null）他是一个object类型，
就是null呢他相当是一个空对象，只有你主动给他赋值的时候他才会变成一个null值，像没有赋值或者没有响应，他就是一个undefined</code></pre>
<h3 id="什么是变量提升"><a href="#什么是变量提升" class="headerlink" title="什么是变量提升"></a>什么是变量提升</h3><pre><code>变量提升是js的默认行为，变量提升会将所有变量声明移动到当前作用域的顶部，并可以在声明之前使用该变量，初始化不会被提升，提升的仅作用于变量的声明</code></pre>
<h3 id="什么是事件委托"><a href="#什么是事件委托" class="headerlink" title="什么是事件委托"></a>什么是事件委托</h3><pre><code>利用事件冒泡的原理，把原本需要绑定的事件委托给父元素，让父元素负责事件监听</code></pre>
<h3 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h3><pre><code>深拷贝的话，比如对象数组，他会把所有的值分配到堆内存里面，像浅拷贝的话，他只会拷贝一层，或者两层，他不会吧所有的引用地址都拷贝到堆内存里面，
当他使用浅拷贝时，比如说你引用的是这个地址，然后假设你改变的是这个地址里的一个值，假设他是在第二层，他就会把这个值也一同修改，像js里的api object.create，object.assign其实都是浅拷贝，
深拷贝他是有js自带的一个方式，叫JSON.parse（JSON.stringify），但是这种方式也有缺点，比如说拷贝函数的时候或者拷贝不是JSON数据格式的时候，他就会出现很多问题，像完整深拷贝的话，他就需要用递归的方式去实现</code></pre>
<p>递归实现深拷贝</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">var obj &#x3D; &#123;   &#x2F;&#x2F;原数据，包含字符串、对象、函数、数组等不同的类型</span><br><span class="line">       name:&quot;test&quot;,</span><br><span class="line">       main:&#123;</span><br><span class="line">           a:1,</span><br><span class="line">           b:2</span><br><span class="line">       &#125;,</span><br><span class="line">       fn:function()&#123;</span><br><span class="line">           </span><br><span class="line">       &#125;，</span><br><span class="line">        friends:[1,2,3,[22,33]]</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   function copy(obj)&#123;</span><br><span class="line">        let newobj &#x3D; null;   &#x2F;&#x2F;声明一个变量用来储存拷贝之后的内容</span><br><span class="line">        </span><br><span class="line">     &#x2F;&#x2F;判断数据类型是否是复杂类型，如果是则调用自己，再次循环，如果不是，直接赋值即可，</span><br><span class="line">     &#x2F;&#x2F;由于null不可以循环但类型又是object，所以这个需要对null进行判断</span><br><span class="line">        if(typeof(obj) &#x3D;&#x3D; &#39;object&#39; &amp;&amp; obj !&#x3D;&#x3D; null)&#123; </span><br><span class="line">        </span><br><span class="line">	&#x2F;&#x2F;声明一个变量用以储存拷贝出来的值,根据参数的具体数据类型声明不同的类型来储存</span><br><span class="line">            newobj &#x3D; obj instanceof Array? [] : &#123;&#125;;   </span><br><span class="line">            </span><br><span class="line">	&#x2F;&#x2F;循环obj 中的每一项，如果里面还有复杂数据类型，则直接利用递归再次调用copy函数</span><br><span class="line">            for(var i in obj)&#123;  </span><br><span class="line">                newobj[i] &#x3D; copy(obj[i])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            newobj &#x3D; obj</span><br><span class="line">        &#125;    </span><br><span class="line">      return newobj;    &#x2F;&#x2F;函数必须有返回值，否则结构为undefined</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    var obj2 &#x3D; copy(obj)</span><br><span class="line">    obj2.name &#x3D; &#39;修改成功&#39;</span><br><span class="line">    obj2.main.a &#x3D; 100</span><br><span class="line">   console.log(obj,obj2)</span><br></pre></td></tr></table></figure>
<h3 id="async与defer区别"><a href="#async与defer区别" class="headerlink" title="async与defer区别"></a>async与defer区别</h3><pre><code>异步(async) 脚本将在其加载完成后立即执行，而 延迟(defer) 脚本将等待 HTML 解析完成后，并按加载顺序执行。</code></pre>
<h3 id="cookies，sessionStorage和localStorage-有什么区别？"><a href="#cookies，sessionStorage和localStorage-有什么区别？" class="headerlink" title="cookies，sessionStorage和localStorage 有什么区别？"></a>cookies，sessionStorage和localStorage 有什么区别？</h3><pre><code>共同点：都是保存在浏览器端、且同源的
不同点：
    1.cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递。
    cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下
    sessionStorage和localStorage不会自动把数据发送给服务器，仅在本地保存。
    2.存储大小限制也不同，cookie数据不能超过4K，sessionStorage和localStorage可以达到5M或更大
    3.cookie：只在设置的cookie过期时间之前有效，即使窗口关闭或浏览器关闭
    sessionStorage：仅在当前浏览器窗口关闭之前有效；数据在当前浏览器窗口关闭后自动删除。
    localStorage：始终有效，窗口或浏览器关闭也一直保存，本地存储，因此用作存储持久数据；浏览器关闭后数据不丢失除非主动删除数据
    4.作用域不同
    cookie: 也是在所有同源窗口中都是共享的.也就是说只要浏览器不关闭，数据仍然存在
    sessionStorage：不在不同的浏览器窗口中共享，即使是同一个页面；
    localstorage：在所有同源窗口中都是共享的；也就是说只要浏览器不关闭，数据仍然存在</code></pre>
<h3 id="数组去重有哪些方法"><a href="#数组去重有哪些方法" class="headerlink" title="数组去重有哪些方法"></a>数组去重有哪些方法</h3><h4 id="利用ES6-Set去重"><a href="#利用ES6-Set去重" class="headerlink" title="利用ES6 Set去重"></a>利用ES6 Set去重</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new Set()  如：var arr &#x3D; [1,2,3,9,6,3,1,2,6] new set(arr)</span><br></pre></td></tr></table></figure>
<h4 id="利用冒泡for循环嵌套，然后splice-去重-如："><a href="#利用冒泡for循环嵌套，然后splice-去重-如：" class="headerlink" title="利用冒泡for循环嵌套，然后splice()去重 如："></a>利用冒泡for循环嵌套，然后splice()去重 如：</h4><p>双层循环，外层循环元素，内层循环时比较值。值相同时，则删去这个值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function unique(arr)&#123;            </span><br><span class="line">        for(var i&#x3D;0; i&lt;arr.length; i++)&#123;</span><br><span class="line">            for(var j&#x3D;i+1; j&lt;arr.length; j++)&#123;</span><br><span class="line">                if(arr[i]&#x3D;&#x3D;arr[j])&#123;         &#x2F;&#x2F;第一个等同于第二个，splice方法删除第二个</span><br><span class="line">                    arr.splice(j,1);</span><br><span class="line">                    j--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">return arr;</span><br><span class="line">&#125;</span><br><span class="line">var arr &#x3D; [1,2,3,9,6,3,1,2,6]</span><br><span class="line">console.log(unique(arr))</span><br></pre></td></tr></table></figure>
<h4 id="indexOf-去重-如："><a href="#indexOf-去重-如：" class="headerlink" title="indexOf()去重 如："></a>indexOf()去重 如：</h4><p>新建一个空的结果数组，for 循环原数组，判断结果数组是否存在当前元素，如果有相同的值则跳过，不相同则push进数组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function unique(arr) &#123;</span><br><span class="line">    if (!Array.isArray(arr)) &#123;</span><br><span class="line">        console.log(&#39;type error!&#39;)</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    var array &#x3D; [];</span><br><span class="line">    for (var i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">        if (array .indexOf(arr[i]) &#x3D;&#x3D;&#x3D; -1) &#123;</span><br><span class="line">            array .push(arr[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return array;</span><br><span class="line">&#125;</span><br><span class="line">var arr &#x3D; [1,2,3,9,6,3,1,2,6]</span><br><span class="line">    console.log(unique(arr))</span><br></pre></td></tr></table></figure>
<h4 id="sort-去重-如："><a href="#sort-去重-如：" class="headerlink" title="sort()去重 如："></a>sort()去重 如：</h4><p>利用sort()排序方法，然后根据排序后的结果进行遍历及相邻元素比对</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function unique(arr) &#123; </span><br><span class="line">    if (!Array.isArray(arr)) &#123; </span><br><span class="line">        console.log(&#39;type error!&#39;) return;</span><br><span class="line">    &#125; </span><br><span class="line">    arr &#x3D; arr.sort() </span><br><span class="line">    var arrry&#x3D; [arr[0]]; </span><br><span class="line">    for (var i &#x3D; 1; i &lt; arr.length; i++) &#123; </span><br><span class="line">        if (arr[i] !&#x3D;&#x3D; arr[i-1]) &#123; </span><br><span class="line">            arrry.push(arr[i]);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    return arrry; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">var arr &#x3D; [1,2,3,9,6,3,1,2,6]</span><br><span class="line"></span><br><span class="line">console.log(unique(arr))</span><br></pre></td></tr></table></figure>
<h4 id="filter-去重-如"><a href="#filter-去重-如" class="headerlink" title="filter()去重 如:"></a>filter()去重 如:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function unique(arr) &#123; </span><br><span class="line">    return arr.filter(function(item, index, arr) &#123; </span><br><span class="line">        return arr.indexOf(item, 0) &#x3D;&#x3D;&#x3D; index;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var arr &#x3D; [1,2,3,9,6,3,1,2,6]</span><br><span class="line"></span><br><span class="line">console.log(unique(arr))</span><br></pre></td></tr></table></figure>
<h4 id="一行代码实现数组去重？"><a href="#一行代码实现数组去重？" class="headerlink" title="一行代码实现数组去重？"></a>一行代码实现数组去重？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[...new Set([1,2,3,1,&#39;a&#39;,1,&#39;a&#39;])]</span><br></pre></td></tr></table></figure>
<h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var array &#x3D; [5, 4, 3, 2, 1];</span><br><span class="line">var temp &#x3D; 0;</span><br><span class="line">for (var i &#x3D; 0; i &lt;array.length; i++)&#123;</span><br><span class="line">    for (var j &#x3D; 0; j &lt;array.length - i; j++)&#123;</span><br><span class="line">        if (array[j] &gt; array[j + 1])&#123;</span><br><span class="line">            temp &#x3D; array[j + 1];</span><br><span class="line">            array[j + 1] &#x3D; array[j];</span><br><span class="line">            array[j] &#x3D; temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="降维数组"><a href="#降维数组" class="headerlink" title="降维数组"></a>降维数组</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var arr&#x3D;[[1,2],[3,4]];</span><br><span class="line">function Jw(obj)&#123;</span><br><span class="line">    return Array.prototype.concat.apply([],obj);</span><br><span class="line">&#125;</span><br><span class="line">Jw(arr);</span><br></pre></td></tr></table></figure>
<h3 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h3><pre><code>DOM 同源策略：禁止对不同源页面 DOM 进行操作。这里主要场景是 iframe 跨域的情况，不同域名的 iframe 是限制互相访问的。
XMLHttpRequest 同源策略：禁止使用 XHR 对象向不同源的服务器地址发起 HTTP 请求</code></pre>
<h3 id="跨域有几种解决方案"><a href="#跨域有几种解决方案" class="headerlink" title="跨域有几种解决方案"></a>跨域有几种解决方案</h3><h4 id="1-jsonp"><a href="#1-jsonp" class="headerlink" title="1. jsonp"></a>1. jsonp</h4><pre><code>通过动态创建 script 标签，然后利用 src 属性进行跨域，这也就是 JSONP 跨域的基本原理。</code></pre>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 1. 定义一个 回调函数 handleResponse 用来接收返回的数据</span><br><span class="line">function handleResponse(data) &#123;</span><br><span class="line">    console.log(data);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 2. 动态创建一个 script 标签，并且告诉后端回调函数名叫 handleResponse</span><br><span class="line">var body &#x3D; document.getElementsByTagName(&#39;body&#39;)[0];</span><br><span class="line">var script &#x3D; document.gerElement(&#39;script&#39;);</span><br><span class="line">script.src &#x3D; &#39;http:&#x2F;&#x2F;www.laixiangran.cn&#x2F;json?callback&#x3D;handleResponse&#39;;</span><br><span class="line">body.appendChild(script);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 3. 通过 script.src 请求 &#96;http:&#x2F;&#x2F;www.laixiangran.cn&#x2F;json?callback&#x3D;handleResponse&#96;，</span><br><span class="line">&#x2F;&#x2F; 4. 后端能够识别这样的 URL 格式并处理该请求，然后返回 handleResponse(&#123;&quot;name&quot;: &quot;laixiangran&quot;&#125;) 给浏览器</span><br><span class="line">&#x2F;&#x2F; 5. 浏览器在接收到 handleResponse(&#123;&quot;name&quot;: &quot;laixiangran&quot;&#125;) 之后立即执行 ，也就是执行 handleResponse 方法，获得后端返回的数据，这样就完成一次跨域请求了。</span><br></pre></td></tr></table></figure>
<pre><code>优点：使用简便，没有兼容性问题，目前最流行的一种跨域方法
缺点：
只支持 GET 请求。
由于是从其它域中加载代码执行，因此如果其他域不安全，很可能会在响应中夹带一些恶意代码。
要确定 JSONP 请求是否失败并不容易。虽然 HTML5 给 script 标签新增了一个 onerror 事件处理程序，但是存在兼容性问题。</code></pre>
<h4 id="2-document-domain-iframe-（适用于主域名相同-子域名不同-两个页面都通过js强制设置document-domain为基础主域，就实现了同域）"><a href="#2-document-domain-iframe-（适用于主域名相同-子域名不同-两个页面都通过js强制设置document-domain为基础主域，就实现了同域）" class="headerlink" title="2. document.domain + iframe （适用于主域名相同 子域名不同  两个页面都通过js强制设置document.domain为基础主域，就实现了同域）"></a>2. document.domain + iframe （适用于主域名相同 子域名不同  两个页面都通过js强制设置document.domain为基础主域，就实现了同域）</h4><pre><code>对于主域名相同，而子域名不同的情况，可以使用 document.domain 来跨域。这种方式非常适用于 iframe 跨域的情况。
比如，有一个页面，它的地址是 http://www.laixiangran.cn/a.html，在这个页面里面有一个 iframe，它的 src 是 http://laixiangran.cn/b.html。很显然，
这个页面与它里面的 iframe 框架是不同域的，所以我们是无法通过在页面中书写 js 代码来获取 iframe 中的东西的。
这个时候，document.domain 就可以派上用场了，我们只要把 http://www.laixiangran.cn/a.html 和 http://laixiangran.cn/b.html 这两个页面的 document.domain 都设成
相同的域名就可以了。但要注意的是，document.domain 的设置是有限制的，我们只能把 document.domain 设置成自身或更高一级的父域，且主域必须相同。
例如：a.b.laixiangran.cn 中某个文档的 document.domain 可以设成 a.b.laixiangran.cn、b.laixiangran.cn 、laixiangran.cn 中的任意一个，
但是不可以设成 c.a.b.laixiangran.cn ，因为这是当前域的子域，也不可以设成 baidu.com，因为主域已经不相同了。</code></pre>
<p>例如，在页面 <a target="_blank" rel="noopener" href="http://www.laixiangran.cn/a.html">http://www.laixiangran.cn/a.html</a> 中设置document.domain：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe src&#x3D;&quot;http:&#x2F;&#x2F;laixiangran.cn&#x2F;b.html&quot; id&#x3D;&quot;myIframe&quot; onload&#x3D;&quot;test()&quot;&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    document.domain &#x3D; &#39;laixiangran.cn&#39;; &#x2F;&#x2F; 设置成主域</span><br><span class="line">    function test() &#123;</span><br><span class="line">        console.log(document.getElementById(&#39;myIframe&#39;).contentWindow);</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">在页面 http:&#x2F;&#x2F;laixiangran.cn&#x2F;b.html 中也设置 document.domain，而且这也是必须的，虽然这个文档的 domain 就是 laixiangran.cn，</span><br><span class="line">但是还是必须显式地设置 document.domain 的值：</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    document.domain &#x3D; &#39;laixiangran.cn&#39;; &#x2F;&#x2F; document.domain 设置成与主页面相同</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<pre><code>这样，http://www.laixiangran.cn/a.html 就可以通过 js 访问到 http://laixiangran.cn/b.html 中的各种属性和对象了。</code></pre>
<h4 id="3-location-hash-iframe"><a href="#3-location-hash-iframe" class="headerlink" title="3. location.hash + iframe"></a>3. location.hash + iframe</h4><pre><code>是子框架修改父框架 src 的 hash 值，通过这个属性进行传递数据，且更改 hash 值，页面不会刷新。但是传递的数据的字节数是有限的</code></pre>
<h4 id="4-window-name-iframe"><a href="#4-window-name-iframe" class="headerlink" title="4. window.name + iframe"></a>4. window.name + iframe</h4><pre><code>window 对象有个 name 属性，该属性有个特征：即在一个窗口（window）的生命周期内，窗口载入的所有的页面（不管是相同域的页面还是不同域的页面）都是共享一个 window.name 的，
每个页面对 window.name 都有读写的权限，window.name 是持久存在一个窗口载入过的所有页面中的，并不会因新页面的载入而进行重置。</code></pre>
<h4 id="5-postMessage-data-origin-方法接受两个参数"><a href="#5-postMessage-data-origin-方法接受两个参数" class="headerlink" title="5. postMessage (data,origin)方法接受两个参数"></a>5. postMessage (data,origin)方法接受两个参数</h4><pre><code>是 HTML5 新引进的特性

data：需要传递的数据(发送的消息)，html5规范支持任意基本类型或可复制的对象，但部分浏览器只支持字符串，所以传参时最好用JSON.stringify()序列化。
origin：协议+主机+端口号，也可以设置为&quot;*&quot;，表示可以传递给任意窗口，来限定接收消息的那个 window 对象所在的域,如果要指定和当前窗口同源的话设置为&quot;/&quot;。</code></pre>
<h4 id="6-跨域资源共享（CORS）"><a href="#6-跨域资源共享（CORS）" class="headerlink" title="6. 跨域资源共享（CORS）"></a>6. 跨域资源共享（CORS）</h4><pre><code>CORS 背后的基本思想，就是使用自定义的 HTTP 头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功，还是应该失败。</code></pre>
<p>浏览器将CORS请求分成两类：简单请求和非简单请求<br>只要同时满足以下两大条件，就属于简单请求。</p>
<pre><code>1、请求方法是以下三种方法之一：

HEAD
GET
POST

2、HTTP的头信息不超出以下几种字段：

Accept
Accept-Language
Content-Language
Last-Event-ID
Content-Type：只限于三个值 application/x-www-form-urlencoded、multipart/form-data、text/plain</code></pre>
<p>凡是不同时满足上面两个条件，就属于非简单请求。<br>浏览器对这两种请求的处理，是不一样的。</p>
<p>简单请求</p>
<pre><code>1.在请求中需要附加一个额外的 Origin 头部，其中包含请求页面的源信息（协议、域名和端口），以便服务器根据这个头部信息来决定是否给予响应。
例如：Origin: http://www.laixiangran.cn
2.如果服务器认为这个请求可以接受，就在 Access-Control-Allow-Origin 头部中回发相同的源信息（如果是公共资源，可以回发 * ）。
例如：Access-Control-Allow-Origin：http://www.laixiangran.cn
3.没有这个头部或者有这个头部但源信息不匹配，浏览器就会驳回请求。正常情况下，浏览器会处理请求。注意，请求和响应都不包含 cookie 信息。
4.如果需要包含 cookie 信息，ajax 请求需要设置 xhr 的属性 withCredentials 为 true，服务器需要设置响应头部 Access-Control-Allow-Credentials: true。</code></pre>
<p>非简单请求</p>
<pre><code>浏览器在发送真正的请求之前，会先发送一个 Preflight 请求给服务器，这种请求使用 OPTIONS 方法，发送下列头部：</code></pre>
<p>Origin：与简单的请求相同。<br>Access-Control-Request-Method: 请求自身使用的方法。<br>Access-Control-Request-Headers: （可选）自定义的头部信息，多个头部以逗号分隔。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Origin: http:&#x2F;&#x2F;www.laixiangran.cn</span><br><span class="line">Access-Control-Request-Method: POST</span><br><span class="line">Access-Control-Request-Headers: NCZ</span><br></pre></td></tr></table></figure>
<p>发送这个请求后，服务器可以决定是否允许这种类型的请求。服务器通过在响应中发送如下头部与浏览器进行沟通：</p>
<pre><code>Access-Control-Allow-Origin：与简单的请求相同。
Access-Control-Allow-Methods: 允许的方法，多个方法以逗号分隔。
Access-Control-Allow-Headers: 允许的头部，多个方法以逗号分隔。
Access-Control-Max-Age: 应该将这个 Preflight 请求缓存多长时间（以秒表示）</code></pre>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: http:&#x2F;&#x2F;www.laixiangran.cn</span><br><span class="line">Access-Control-Allow-Methods: GET, POST</span><br><span class="line">Access-Control-Allow-Headers: NCZ</span><br><span class="line">Access-Control-Max-Age: 1728000</span><br></pre></td></tr></table></figure>
<p>一旦服务器通过 Preflight 请求允许该请求之后，以后每次浏览器正常的 CORS 请求，就都跟简单请求一样了。</p>
<p>优点：<br>    CORS 通信与同源的 AJAX 通信没有差别，代码完全一样，容易维护。<br>    支持所有类型的 HTTP 请求。<br>缺点：<br>    存在兼容性问题，特别是 IE10 以下的浏览器。<br>    第一次发送非简单请求时会多一次请求。</p>
<h3 id="axios和ajax和fetch的区别"><a href="#axios和ajax和fetch的区别" class="headerlink" title="axios和ajax和fetch的区别"></a>axios和ajax和fetch的区别</h3><pre><code>其实axios是通过 promise 实现对 ajax 技术的一种封装。就像 ajax 是 通过 jQuery 来封装一样。
也就是说，jQuery 将请求技术进行了封装 变成了 ajax , 而 通过 promise 又把 ajax 进行封装就成了 axios。
ajax，本身是针对MVC的编程，不符合现在前端MVVM的浪潮。基于原生的XHR开发，XHR本身的架构不清晰，已经有了fetch的替代方案。JQuery整个项目太大，单纯使用ajax却要引入整个JQuery非常的不合理

ajax：

1、本身是针对MVC编程，不符合前端MVVM的浪潮
2、基于原生XHR开发，XHR本身的架构不清晰，已经有了fetch的替代方案，jquery整个项目太大，单纯使用ajax却要引入整个jquery非常不合理（采取个性化打包方案又不能享受cdn服务）
3、ajax不支持浏览器的back按钮
4、安全问题ajax暴露了与服务器交互的细节
5、对搜索引擎的支持比较弱
6、破坏程序的异常机制
7、不容易调试

axios：

1、从浏览器中创建XHR
2、从node.js创建http请求
3、支持Promise API
4、客户端防止CSRF（网站恶意利用）攻击
5、提供了一些并发请求的接口
6、支持拦截请求和响应、取消请求

fetch

1、只对网络请求报错，对400、500都当做成功的请求
2、默认不带cookie，需要添加配置项
3、没有办法监测请求的进度、而XHR可以</code></pre>
<h3 id="typeof和instanceof有什么区别"><a href="#typeof和instanceof有什么区别" class="headerlink" title="typeof和instanceof有什么区别"></a>typeof和instanceof有什么区别</h3><pre><code>typeof 判断一个数据是什么数据类型；一般只能返回如下几个结果：&quot;number&quot;、&quot;string&quot;、&quot;boolean&quot;、&quot;object&quot;、&quot;function&quot; 和 &quot;undefined&quot;。
instanceof 判断一个对象是否在另一个对象的原型链上</code></pre>
<h3 id="函数声明与函数表达式的区别？"><a href="#函数声明与函数表达式的区别？" class="headerlink" title="函数声明与函数表达式的区别？"></a>函数声明与函数表达式的区别？</h3><pre><code>在Javscript中，解析器在向执行环境中加载数据时，对函数声明和函数表达式并非是一视同仁的，解析器会率先读取函数声明，并使其在执行任何代码之前可用（可以访问），
至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解析执行。</code></pre>
<h3 id="Javascript的事件流模型都有什么"><a href="#Javascript的事件流模型都有什么" class="headerlink" title="Javascript的事件流模型都有什么?"></a>Javascript的事件流模型都有什么?</h3><pre><code>“事件冒泡”：事件开始由最具体的元素接受，然后逐级向上传播

“事件捕捉”：事件由最不具体的节点先接收，然后逐级向下，一直到最具体的

“DOM事件流”：三个阶段：事件捕捉，目标阶段，事件冒泡</code></pre>
<h3 id="希望获取到页面中所有的checkbox怎么做？-不使用第三方框架"><a href="#希望获取到页面中所有的checkbox怎么做？-不使用第三方框架" class="headerlink" title="希望获取到页面中所有的checkbox怎么做？(不使用第三方框架)"></a>希望获取到页面中所有的checkbox怎么做？(不使用第三方框架)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var inputs &#x3D; document.getElementsByTagName(&quot;input&quot;);&#x2F;&#x2F;获取所有的input标签对象</span><br><span class="line">var checkboxArray &#x3D; [];&#x2F;&#x2F;初始化空数组，用来存放checkbox对象。</span><br><span class="line">for(var i&#x3D;0;i&lt;inputs.length;i++)&#123;</span><br><span class="line">    var obj &#x3D; inputs[i];</span><br><span class="line">    if(obj.type&#x3D;&#x3D;&#39;checkbox&#39;)&#123;</span><br><span class="line">        checkboxArray.push(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="如何获取javascript三个数中的最大值和最小值？"><a href="#如何获取javascript三个数中的最大值和最小值？" class="headerlink" title="如何获取javascript三个数中的最大值和最小值？"></a>如何获取javascript三个数中的最大值和最小值？</h3><pre><code>Math.max(a,b,c);//最大值

Math.min(a,b,c)//最小值</code></pre>
<h3 id="javascript是面向对象的，怎么体现javascript的继承关系？"><a href="#javascript是面向对象的，怎么体现javascript的继承关系？" class="headerlink" title="javascript是面向对象的，怎么体现javascript的继承关系？"></a>javascript是面向对象的，怎么体现javascript的继承关系？</h3><pre><code>使用prototype原型来实现。</code></pre>
<h3 id="列举javaScript的3种主要数据类型，2种复合数据类型和2种特殊数据类型。"><a href="#列举javaScript的3种主要数据类型，2种复合数据类型和2种特殊数据类型。" class="headerlink" title="列举javaScript的3种主要数据类型，2种复合数据类型和2种特殊数据类型。"></a>列举javaScript的3种主要数据类型，2种复合数据类型和2种特殊数据类型。</h3><pre><code>主要数据类型：string, boolean, number

复合数据类型：function, object

特殊类型：undefined，null</code></pre>
<h3 id="解释什么是Json"><a href="#解释什么是Json" class="headerlink" title="解释什么是Json:"></a>解释什么是Json:</h3><pre><code>(1)JSON 是一种轻量级的数据交换格式。

(2)JSON 独立于语言和平台，JSON 解析器和 JSON 库支持许多不同的编程语言。

(3)JSON的语法表示三种类型值，简单值(字符串，数值，布尔值，null),数组，对象</code></pre>
<h3 id="js中的3种弹出式消息提醒（警告窗口，确认窗口，信息输入窗口）的命令式什么？"><a href="#js中的3种弹出式消息提醒（警告窗口，确认窗口，信息输入窗口）的命令式什么？" class="headerlink" title="js中的3种弹出式消息提醒（警告窗口，确认窗口，信息输入窗口）的命令式什么？"></a>js中的3种弹出式消息提醒（警告窗口，确认窗口，信息输入窗口）的命令式什么？</h3><pre><code>alert
confirm
prompt</code></pre>
<h4 id="浏览器的滚动距离："><a href="#浏览器的滚动距离：" class="headerlink" title="浏览器的滚动距离："></a>浏览器的滚动距离：</h4><pre><code>可视区域距离页面顶部的距离

scrollTop=document.documentElement.scrollTop||document.body.scrollTop</code></pre>
<h3 id="innerHTML、innerText和outerHTML的区别"><a href="#innerHTML、innerText和outerHTML的区别" class="headerlink" title="innerHTML、innerText和outerHTML的区别"></a>innerHTML、innerText和outerHTML的区别</h3><pre><code>innerHTML(元素内包含的内容）

innerText(元素的文本内容）

outerHTML(自己以及元素内的内容）</code></pre>
<h3 id="offsetWidth-offsetHeight和clientWidth-clientHeight的区别"><a href="#offsetWidth-offsetHeight和clientWidth-clientHeight的区别" class="headerlink" title="offsetWidth offsetHeight和clientWidth clientHeight的区别"></a>offsetWidth offsetHeight和clientWidth clientHeight的区别</h3><pre><code>(1)offsetWidth （content宽度+padding宽度+border宽度）

(2)offsetHeight（content高度+padding高度+border高度）

(3)clientWidth（content宽度+padding宽度）

(4)clientHeight（content高度+padding高度）</code></pre>
<h3 id="请说出三种减低页面加载时间的方法"><a href="#请说出三种减低页面加载时间的方法" class="headerlink" title="请说出三种减低页面加载时间的方法"></a>请说出三种减低页面加载时间的方法</h3><pre><code>1、压缩css、js文件
2、合并js、css文件，减少http请求
3、外部js、css文件放在最底下
4、减少dom操作，尽可能用变量替代不必要的dom操作</code></pre>
<h3 id="请解释什么是Javascript的模块模式，并举出实用实例。"><a href="#请解释什么是Javascript的模块模式，并举出实用实例。" class="headerlink" title="请解释什么是Javascript的模块模式，并举出实用实例。"></a>请解释什么是Javascript的模块模式，并举出实用实例。</h3><pre><code>js模块化mvc（数据层、表现层、控制层）
seajs
命名空间</code></pre>
<h3 id="你如何组织自己的代码？是使用模块模式，还是使用经典继承的方法？"><a href="#你如何组织自己的代码？是使用模块模式，还是使用经典继承的方法？" class="headerlink" title="你如何组织自己的代码？是使用模块模式，还是使用经典继承的方法？"></a>你如何组织自己的代码？是使用模块模式，还是使用经典继承的方法？</h3><pre><code>对内：模块模式
对外：继承</code></pre>
<h3 id="你如何优化自己的代码？"><a href="#你如何优化自己的代码？" class="headerlink" title="你如何优化自己的代码？"></a>你如何优化自己的代码？</h3><pre><code>代码重用
避免全局变量（命名空间，封闭空间，模块化mvc..）
拆分函数避免函数过于臃肿
注释</code></pre>
<h4 id="你能解释一下JavaScript中的继承是如何工作的吗？"><a href="#你能解释一下JavaScript中的继承是如何工作的吗？" class="headerlink" title="你能解释一下JavaScript中的继承是如何工作的吗？"></a>你能解释一下JavaScript中的继承是如何工作的吗？</h4><pre><code>子构造函数中执行父构造函数，并用call\apply改变this
克隆父构造函数原型上的方法</code></pre>
<h3 id="dom事件委托什么原理，有什么优缺点"><a href="#dom事件委托什么原理，有什么优缺点" class="headerlink" title="dom事件委托什么原理，有什么优缺点"></a>dom事件委托什么原理，有什么优缺点</h3><pre><code>事件委托原理:事件冒泡机制

优点
1.可以大量节省内存占用，减少事件注册。比如ul上代理所有li的click事件就很不错。
2.可以实现当新增子对象时，无需再对其进行事件绑定，对于动态内容部分尤为合适

缺点
事件代理的常用应用应该仅限于上述需求，如果把所有事件都用事件代理，可能会出现事件误判。即本不该被触发的事件被绑定上了事件。</code></pre>
<h3 id="js基础数据类型和引用类型分别是什么？这个前提条件下写一个getType，返回相应的类型"><a href="#js基础数据类型和引用类型分别是什么？这个前提条件下写一个getType，返回相应的类型" class="headerlink" title="js基础数据类型和引用类型分别是什么？这个前提条件下写一个getType，返回相应的类型"></a>js基础数据类型和引用类型分别是什么？这个前提条件下写一个getType，返回相应的类型</h3><pre><code>1.基本数据类型（自身不可拆分的）：Undefined、Null、Boolean、Number、String
2.引用数据类型（对象）：Object （Array，Date，RegExp，Function）
ES6基本数据类型多了个symbol 据说这道题刷了百分之二十的人 感谢Abbyshen提出</code></pre>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function gettype(nm)&#123;</span><br><span class="line">    return Object.prototype.toString.call(nm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="js垃圾回收机制知道哪些，垃圾回收机制的好处和坏处"><a href="#js垃圾回收机制知道哪些，垃圾回收机制的好处和坏处" class="headerlink" title="js垃圾回收机制知道哪些，垃圾回收机制的好处和坏处"></a>js垃圾回收机制知道哪些，垃圾回收机制的好处和坏处</h3><h4 id="什么是垃圾回收机制"><a href="#什么是垃圾回收机制" class="headerlink" title="什么是垃圾回收机制"></a>什么是垃圾回收机制</h4><pre><code>JS的垃圾回收机制是为了以防内存泄漏，内存泄漏的含义就是当已经不需要某块内存时这块内存还存在着，垃圾回收机制就是间歇的不定期的寻找到不再使用的变量，并释放掉它们所指向的内存。</code></pre>
<h4 id="内存泄漏的原因"><a href="#内存泄漏的原因" class="headerlink" title="内存泄漏的原因"></a>内存泄漏的原因</h4><pre><code>内存泄漏指由于疏忽或错误造成程序未能释放已经不再使用的内存。内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，导致在释放该段内存之前就失去了对该段内存的控制，
从而造成了内存的浪费。这里就讲一些常见会带来内存泄露的原因。</code></pre>
<h4 id="垃圾回收的方式"><a href="#垃圾回收的方式" class="headerlink" title="垃圾回收的方式"></a>垃圾回收的方式</h4><pre><code>1 标记清除（mark and sweep）
s中最常用的垃圾回收方式就是标记清除。当变量进入环境时，例如，在一个函数中声明一个变量，就将这个变量标记为&quot;进入环境&quot;，从逻辑上讲，永远不能释放进入环境变量所占用的内存，
因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其标记为&quot;离开环境&quot;。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function test()&#123;</span><br><span class="line">    var a &#x3D; 10;    &#x2F;&#x2F;被标记&quot;进入环境&quot;</span><br><span class="line">    var b &#x3D; &quot;hello&quot;;    &#x2F;&#x2F;被标记&quot;进入环境&quot;</span><br><span class="line">&#125;</span><br><span class="line">test();    &#x2F;&#x2F;执行完毕后之后，a和b又被标记&quot;离开环境&quot;，被回收</span><br></pre></td></tr></table></figure>
垃圾回收机制在运行的时候会给存储再内存中的所有变量都加上标记（可以是任何标记方式），然后，它会去掉处在环境中的变量及被环境中的变量引用的变量标记（闭包）。
而在此之后剩下的带有标记的变量被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后垃圾回收机制到下一个周期运行时，将释放这些变量的内存，回收它们所占用的空间。

2 引用计数（reference counting）

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let arr &#x3D; [1,2,3,4];</span><br><span class="line">console.log(&quot;hello world&quot;);</span><br><span class="line">arr &#x3D; null;</span><br></pre></td></tr></table></figure>
上面的代码中，数组[1,2,3,4]是一个值，会占用内存。变量arr是仅有的对这个值的引用，因此引用次数为1。尽管后面的代码没有用到arr，它是会持续占用内存。

如果增加一行代码，解除arr对[1,2,3,4]引用，这块内存就可以被垃圾回收机制释放了。</code></pre>
<p>好处：大幅简化程序的内存管理代码，减轻程序猿负担，并且减少因为长时间运转而带来的内存泄露问题。</p>
<p>坏处：自动回收意味着程序猿无法掌控内存。ECMAScript中没有暴露垃圾回收的借口，我们无法强迫其进行垃圾回收，更加无法干预内存管理。</p>
<h3 id="setTimeout-和-setInterval-细谈"><a href="#setTimeout-和-setInterval-细谈" class="headerlink" title="setTimeout 和 setInterval 细谈"></a>setTimeout 和 setInterval 细谈</h3><pre><code>常问的点，前者是在一定时间过后将函数添加至执行队列，执行时间=延迟时间+之前函数代码执行时间+执行函数时间。
后者是不管前一次是否执行完毕，每隔一定时间重复执行，用于精准执行互相没有影响的重复操作。
如果需要控制前后执行顺序，最好使用setTimeout模拟setInterval</code></pre>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var time &#x3D; 400, times &#x3D; 0, max &#x3D; 10;</span><br><span class="line">function func()&#123;</span><br><span class="line">times++;</span><br><span class="line">if(times &lt; max)&#123;</span><br><span class="line">    &#x2F;&#x2F;code here</span><br><span class="line">    setTimeout(func, time);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    console.log(&quot;finished&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">setTimeout(func, time);</span><br></pre></td></tr></table></figure>
<h3 id="判断数组"><a href="#判断数组" class="headerlink" title="判断数组"></a>判断数组</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function isArray(arr)&#123;</span><br><span class="line">    return Object.prototype.toString.call(arr) &#x3D;&#x3D;&#x3D; &#39;[Object Array]&#39;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="window-name"><a href="#window-name" class="headerlink" title="window.name"></a>window.name</h3><pre><code>即使在页面打开多层iframe后，每个iframe中window.name 属性值都是相同的，以此用作数据传输的工具。
但由于跨域的限制，是无法获取另一个frame中的window.name数据，所以要使用一个同域的代理(proxy.html)：</code></pre>
<h3 id="forEach和map的区别"><a href="#forEach和map的区别" class="headerlink" title="forEach和map的区别"></a>forEach和map的区别</h3><h4 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h4><pre><code>都是循环遍历数组中的每一项
forEach和map方法里每次执行匿名函数都支持3个参数，参数分别是item（当前每一项）、index（索引值）、arr（原数组）
匿名函数中的this都是指向window
只能遍历数组
都有兼容问题</code></pre>
<h4 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h4><pre><code>forEach没法中断或者跳出循环，他也没有返回值，返回结果是undefined，他直接修改的就是原数组，
map有返回值，他可以创建一个新数组，会循环数组中的每个元素，返回一个新的数组，他修改的是这个新数组
map速度比forEach快
map因为返回数组所以可以链式操作，forEach不能</code></pre>
<h3 id="面向对象——原型与原型链"><a href="#面向对象——原型与原型链" class="headerlink" title="面向对象——原型与原型链"></a>面向对象——原型与原型链</h3><h4 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h4><pre><code>构造函数 ，是一种特殊的方法。主要用来在创建对象时初始化对象。
每个函数都有prototype(原型)属性，这个属性是一个指针，指向一个对象，
这个对象的用途是包含特定类型的所有实例共享的属性和方法，即这个原型对象是用来给实例共享属性和方法的。
而每个实例内部都有一个指向原型对象的指针。

每一个对象创建的时候都会形成两个&#39;对象&#39;：
    1.对象本身————类
    2.原型对象————类.prototype</code></pre>
<h4 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h4><pre><code>提到原型链就不得不提原型的继承，继承的完美实现方案是借助寄生组合继承，主要实现原理
PersonB.prototype = Object.create(PersonA.prototype)实现来继承PersonA的原型
当我们通过new关键字实例化的对象身上就有了PersonB自身的属性和方法，也有了PersonA的原型方法
当实例化对象调用某个方法时会先在自身和原型上查找，然后是在_proto_上一层层查找，这种方式就是原型链。</code></pre>
<h4 id="原型链与隐式原型"><a href="#原型链与隐式原型" class="headerlink" title="原型链与隐式原型"></a>原型链与隐式原型</h4><pre><code>从一个对象上找属性的时候，他会先找自身，如果没有的话会去隐式原型（__proto__）上找,如果没有，接着去下一个隐式原型上找，任何一个对象都有__proto__属性，指向的都是原型对象。
这样形成的链式结构就是原型链。</code></pre>
<h4 id="面向对象三部曲"><a href="#面向对象三部曲" class="headerlink" title="面向对象三部曲"></a>面向对象三部曲</h4><pre><code>封装:对象把实现过程封装在方法中，调用者只需要调用即可。而不需要了解过程。良好的封装能够减少耦合,常用于封装插件，方法公用
继承：子承父业。 对象b可以继承对象a中的属性和方法。可以减少代码冗余,实现继承的方法：利用原型prototype来实现,经常用的是在vue原型中加一个属性方法，在vue全局中都可以使用
多态：一种事物，可以具有多种表现形式（鸭、狗、猫…）。同一操作作用于不同的对象上面，可以产生不同的解释和不同的执行结果。换句话说，给不同的对象发送同一个消息的时候，这些对象会根据这个消息分别给出不同的反馈

1.创建类
2.原型对象
3.实例化</code></pre>
<h4 id="面向对象关键名称总结"><a href="#面向对象关键名称总结" class="headerlink" title="面向对象关键名称总结"></a>面向对象关键名称总结</h4><pre><code>1.类
2.实例
3.静态属性、方法
4.成员属性、方法
5.构造函数
6.原型
7.隐式原型
8.实例、类、原型、隐式原型的关系
    类===类.prototype.constructor  //true
    实例.__proto__ === 类.prototype</code></pre>
<h5 id="原型链案例"><a href="#原型链案例" class="headerlink" title="原型链案例"></a>原型链案例</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">function Arr(name,age)&#123;</span><br><span class="line">    this.name&#x3D;name,    &#x2F;&#x2F;this生成的方法、属性都是成员方法或属性</span><br><span class="line">    this.age&#x3D;age,</span><br><span class="line">    this.fn&#x3D;function()&#123;</span><br><span class="line">        console.log(this.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;生成静态方法、属性</span><br><span class="line">Arr.name2&#x3D;&#39;李四&#39;</span><br><span class="line">Arr.fn2&#x3D;function()&#123;</span><br><span class="line">        console.log(Arr.name2)</span><br><span class="line">&#125;</span><br><span class="line">console.log(Arr.name2)  &#x2F;&#x2F;李四</span><br><span class="line">console.log(Arr.fn2)  &#x2F;&#x2F;打印出一个方法</span><br><span class="line">Arr.fn2()  &#x2F;&#x2F;李四</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;生成实例</span><br><span class="line">const MyArr &#x3D; new Arr(&#39;张三&#39;,&#39;23&#39;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;实例访问成员属性</span><br><span class="line">console.log(MyArr.name) &#x2F;&#x2F;张三</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;实例访问静态属性</span><br><span class="line">&#x2F;&#x2F; console.log(MyArr.name2)  &#x2F;&#x2F;undefined   用实例去操作静态属性时会是undefined，而方法会报错，如下：</span><br><span class="line">&#x2F;&#x2F; console.log(MyArr.fn2())</span><br><span class="line">&#x2F;&#x2F; MyArr.fn2() &#x2F;&#x2F;报错  MyArr.fn2 is not a function</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 创建实例方法(实例私有的)</span><br><span class="line">MyArr.fn3&#x3D;function()&#123;</span><br><span class="line">    console.log(MyArr.name)  &#x2F;&#x2F;张三  访问不到静态方法、属性  如下：</span><br><span class="line">    console.log(Arr.fn2)   &#x2F;&#x2F;打印出一个方法</span><br><span class="line">    Arr.fn2()  &#x2F;&#x2F;李四</span><br><span class="line">&#125;</span><br><span class="line">MyArr.fn3()</span><br><span class="line">console.log(MyArr)  &#x2F;&#x2F;打印结果如下</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Arr &#123;name: &quot;张三&quot;, age: &quot;23&quot;, fn: ƒ, fn3: ƒ&#125;</span><br><span class="line">&#x2F;&#x2F; age: &quot;23&quot;</span><br><span class="line">&#x2F;&#x2F; fn: ƒ ()</span><br><span class="line">&#x2F;&#x2F; fn3: ƒ ()</span><br><span class="line">&#x2F;&#x2F; name: &quot;张三&quot;</span><br><span class="line">&#x2F;&#x2F; __proto__: Object</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 很明显看不到静态方法和属性</span><br></pre></td></tr></table></figure>
<h4 id="输入URL回车后的过程"><a href="#输入URL回车后的过程" class="headerlink" title="输入URL回车后的过程"></a>输入URL回车后的过程</h4><pre><code>1.读取缓存：
搜索自身的 DNS 缓存。(如果 DNS 缓存中找到IP 地址就跳过了接下来查找 IP 地址步骤，直接访问该 IP 地址。)
2.DNS 解析:将域名解析成 IP 地址
3.TCP 连接：TCP 三次握手，简易描述三次握手
客户端：服务端你在么？
服务端：客户端我在，你要连接我么？
客户端：是的服务端，我要链接。
连接打通，可以开始请求来
4.发送 HTTP 请求
5.服务器处理请求并返回 HTTP 报文
6.浏览器解析渲染页面
7.断开连接：TCP 四次挥手</code></pre>
<p>关于第六步浏览器解析渲染页面又可以聊聊如果返回的是html页面<br>根据 HTML 解析出 DOM 树<br>根据 CSS 解析生成 CSS 规则树<br>结合 DOM 树和 CSS 规则树，生成渲染树<br>根据渲染树计算每一个节点的信息<br>根据计算好的信息绘制页面</p>
<p>第二种说法：</p>
<pre><code>1.浏览器查找域名的 IP 地址
2.这一步包括 DNS 具体的查找过程，包括：浏览器缓存-&gt;系统缓存-&gt;路由器缓存…
3.浏览器向 web 服务器发送一个 HTTP 请求
4.服务器的永久重定向响应（从 http://example.com 到 http://www.example.com）
5.浏览器跟踪重定向地址
6.服务器处理请求
7.服务器返回一个 HTTP 响应
8.浏览器显示 HTML
9.浏览器发送请求获取嵌入在 HTML 中的资源（如图片、音频、视频、CSS、JS等等）
10.浏览器发送异步请求</code></pre>
<h3 id="tcp三次握手和4次挥手"><a href="#tcp三次握手和4次挥手" class="headerlink" title="tcp三次握手和4次挥手"></a>tcp三次握手和4次挥手</h3><p>字段    含义<br>URG    紧急指针是否有效。为1，表示某一位需要被优先处理<br>ACK    确认号是否有效，一般置为1。<br>PSH    提示接收端应用程序立即从TCP缓冲区把数据读走。<br>RST    对方要求重新建立连接，复位。<br>SYN    请求建立连接，并在其序列号的字段进行序列号的初始值设定。建立连接，设置为1<br>FIN        希望断开连接。<br>————————————————</p>
<h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><pre><code>第一次握手：建立连接时，客户端发送syn包（syn=x）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。

第二次握手：服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（syn=y），即SYN+ACK包，此时服务器进入SYN_RECV状态；

第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=y+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。
————————————————</code></pre>
<h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><pre><code>第一次挥手：客户端A发送一个FIN = 1、初始化序列号seq = u，到服务器B，用来主动关闭客户A到服务器B的数据传送，客户机A进入FIN-WAIT-1状态，等待服务器B发送FIN；

第二次挥手：服务器B收到这个FIN，它发回ACK = 1、确认序号ack number为收到的序号加1（ack number=u+1）；和SYN一样，一个FIN将占用一个序号seq = v，
客户机A进入FIN-WAIT-2，稍后关闭连接，服务器B进入CLOSE_WAIT，等待关闭连接;

第三次挥手：服务器B关闭与客户端A的连接，发回标识位FIN = 1，ACK = 1,seq = w和确认码ack number=u+1给客户端A，服务器B进入LAST_ACK，等待最后一次ACK确认;

第四次挥手：客户端A发送ACK = 1报文确认，并将确认序号设置为收到序号加1（ack number=w+1）到服务器B，客户机A进入TIME-WAIT等待2MAL后进入CLOSE可用状态，服务器B进入CLOSE可用状态
————————————————</code></pre>
<p>问题1】为什么连接的时候是三次握手，关闭的时候却是四次握手？</p>
<pre><code>答：因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。
但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，&quot;你发的FIN报文我收到了&quot;。
只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。</code></pre>
<p>【问题2】为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？</p>
<pre><code>答：虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。
所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。在Client发送出最后的ACK回复，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片段。
所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。
如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。
MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。</code></pre>
<p>【问题3】为什么不能用两次握手进行连接？</p>
<pre><code>答：3次握手完成两个重要的功能，既要双方做好发送数据的准备工作(双方都知道彼此已准备好)，也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。

       现在把三次握手改成仅需要两次握手，死锁是可能发生的。作为例子，考虑计算机S和C之间的通信，假定C给S发送一个连接请求分组，S收到了这个分组，并发 送了确认应答分组。
按照两次握手的协定，S认为连接已经成功地建立了，可以开始发送数据分组。可是，C在S的应答分组在传输中被丢失的情况下，将不知道S 是否已准备好，不知道S建立什么样的序列号，
C甚至怀疑S是否收到自己的连接请求分组。在这种情况下，C认为连接还未建立成功，将忽略S发来的任何数据分 组，只等待连接确认应答分组。而S在发出的分组超时后，重复发送同样的分组。这样就形成了死锁。</code></pre>
<p>【问题4】如果已经建立了连接，但是客户端突然出现故障了怎么办？</p>
<pre><code>TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，
时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。
————————————————</code></pre>
<h3 id="防抖节流"><a href="#防抖节流" class="headerlink" title="防抖节流"></a>防抖节流</h3><h4 id="防抖（debounce）"><a href="#防抖（debounce）" class="headerlink" title="防抖（debounce）"></a>防抖（debounce）</h4><pre><code>定义：就是你触发事件后，在n秒内函数只执行一次，如果在n秒内你又触发了这个事件，他就会重新计算函数的执行时间
（将多次高频操作优化为只在最后一次执行，通常应用场景是：用户输入，只需在输入完成后做一次校验即可。）</code></pre>
<p>思路：在第一次触发事件的时候，不是立即执行函数，而是给出一个delay时间值，例如200ms</p>
<ul>
<li><p>如果在200ms内没有再次触发该事件，则执行函数</p>
</li>
<li><p>如果在200ms内有再次触发事件，则清除当前的计时器，重新开始计时器</p>
</li>
</ul>
<p>效果：短时间内大量出发同一事件最终只会执行一次</p>
<p>实现：利用setTimeOut来实现计时器的功能</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">        &#x2F;&#x2F; 防抖</span><br><span class="line">        const debounce &#x3D; (fn, delay) &#x3D;&gt; &#123;</span><br><span class="line">            &#x2F;**</span><br><span class="line">             * @param [Function] fn 需要使用防抖的函数</span><br><span class="line">             * @param [Number] delay 毫秒，防抖期限值</span><br><span class="line">            *&#x2F;</span><br><span class="line">            let timer &#x3D; null</span><br><span class="line">            return () &#x3D;&gt; &#123;</span><br><span class="line">                if (timer) &#123;</span><br><span class="line">                    &#x2F;&#x2F; 进入此分支说明：当前正在一个计时周期中，并且再次触发了事件,取消当前计时，重新开始计时</span><br><span class="line">                    clearTimeout(timer)</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F; 进入此分支说明：当前没有计时，则开始新的计时</span><br><span class="line">                timer &#x3D; setTimeout(fn, delay)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">​</span><br><span class="line">        const showTop &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">            let scrollTop &#x3D; document.body.scrollTop || document.documentElement.scrollTop</span><br><span class="line">            console.log(&#39;当前位置：&#39; + scrollTop)</span><br><span class="line">        &#125;</span><br><span class="line">        window.onscroll &#x3D; debounce(showTop, 1000)</span><br></pre></td></tr></table></figure>
<h4 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h4><pre><code>定义：连续触发一个事件，但是他在一个时间段内只执行一次，等过了这个时间段再重新激活（苏醒）。节流他会稀释函数的执行的一个频率
（每隔一段时间后执行一次，也就是降低频率，将高频操作优化成低频操作，通常使用场景：滚动条事件或resize时间，通常每隔100~500ms执行一次即可）

应用场景：
1.搜索框input事件，我们之前有个项目，他是要求点击搜素的时候，过一段时间让他出来相关的内容，或者输入间隔大于某个值的话（例如500s），就当做用户已经输入完了，具体使用那种方案要看业务需求。
2.页面resize事件，常见于需要做页面适配的时候。需要根据最终呈现的页面进行dom渲染（这种情形一般使用防抖，只需要判断最后一次的变化情况）。
实现：状态位 / 时间戳 / setTimeout标记</code></pre>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">        &#x2F;&#x2F; 方案一：状态位</span><br><span class="line">        const throttle &#x3D; (fn, delay) &#x3D;&gt; &#123;</span><br><span class="line">            &#x2F;**</span><br><span class="line">             * @param [Function] fn 需要使用防抖的函数</span><br><span class="line">             * @param [Number] delay 毫秒，防抖期限值</span><br><span class="line">            *&#x2F;</span><br><span class="line">            let valid &#x3D; true</span><br><span class="line">            return () &#x3D;&gt; &#123;</span><br><span class="line">                if (!valid) &#123;</span><br><span class="line">                    return false</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F; 执行函数+把状态位设置为无效</span><br><span class="line">                valid &#x3D; false</span><br><span class="line">                setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">                    fn()</span><br><span class="line">                    valid &#x3D; true</span><br><span class="line">                &#125;, delay)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">​</span><br><span class="line">        const showTop &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">            let scrollTop &#x3D; document.body.scrollTop || document.documentElement.scrollTop</span><br><span class="line">            console.log(&#39;当前位置：&#39; + scrollTop)</span><br><span class="line">        &#125;</span><br><span class="line">        window.onscroll &#x3D; throttle(showTop, 1000)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">        &#x2F;&#x2F; 方案二：时间戳</span><br><span class="line">        const throttle &#x3D; (fn, delay) &#x3D;&gt; &#123;</span><br><span class="line">            &#x2F;**</span><br><span class="line">             * @param [Function] fn 需要使用防抖的函数</span><br><span class="line">             * @param [Number] delay 毫秒，防抖期限值</span><br><span class="line">            *&#x2F;</span><br><span class="line">            let start</span><br><span class="line">            return () &#x3D;&gt; &#123;</span><br><span class="line">                let now &#x3D; Date.now()</span><br><span class="line">                if (!start) &#123;</span><br><span class="line">                    start &#x3D; now</span><br><span class="line">                &#125;</span><br><span class="line">​</span><br><span class="line">                if (now - start &gt;&#x3D; delay) &#123;</span><br><span class="line">                    fn()</span><br><span class="line">                    start &#x3D; null</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">​</span><br><span class="line">        const showTop &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">            let scrollTop &#x3D; document.body.scrollTop || document.documentElement.scrollTop</span><br><span class="line">            console.log(&#39;当前位置：&#39; + scrollTop)</span><br><span class="line">        &#125;</span><br><span class="line">        window.onscroll &#x3D; throttle(showTop, 1000)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">        &#x2F;&#x2F; 方案三：setTimeout标记</span><br><span class="line">        const throttle &#x3D; (fn, delay) &#x3D;&gt; &#123;</span><br><span class="line">            &#x2F;**</span><br><span class="line">             * @param [Function] fn 需要使用防抖的函数</span><br><span class="line">             * @param [Number] delay 毫秒，防抖期限值</span><br><span class="line">            *&#x2F;</span><br><span class="line">            let timer &#x3D; null</span><br><span class="line">            return () &#x3D;&gt; &#123;</span><br><span class="line">                if (!timer) &#123;</span><br><span class="line">                    timer &#x3D; setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">                        fn()</span><br><span class="line">                        timer &#x3D; null</span><br><span class="line">                    &#125;, delay)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">​</span><br><span class="line">        const showTop &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">            let scrollTop &#x3D; document.body.scrollTop || document.documentElement.scrollTop</span><br><span class="line">            console.log(&#39;当前位置：&#39; + scrollTop)</span><br><span class="line">        &#125;</span><br><span class="line">        window.onscroll &#x3D; throttle(showTop, 1000)</span><br></pre></td></tr></table></figure>
<h4 id="防抖和节流的区别？"><a href="#防抖和节流的区别？" class="headerlink" title="防抖和节流的区别？"></a>防抖和节流的区别？</h4><p>防抖：短时间内多次触发，最终在停止触发后的某个指定时间执行一次函数————只执行一次</p>
<p>节流：短时间内多次触发，即使触发仍在继续也可以根据指定时间触发一次函数————至少执行一次</p>
</div><div id="reward-container"><span class="hty-icon-button button-glow" id="reward-button" title="Donate" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === &quot;none&quot;) ? &quot;block&quot; : &quot;none&quot;;"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-hand-coin-line"></use></svg></span><div id="reward-comment">喜欢的话就打赏点吧</div><div id="qr" style="display:none;"><div style="display:inline-block"></div><div style="display:inline-block"></div><div style="display:inline-block"></div></div></div><ul class="post-copyright"><li class="post-copyright-author"><strong>Post author: </strong>sun</li><li class="post-copyright-link"><strong>Post link: </strong><a href="http://example.com/2021/02/22/JS%E9%9D%A2%E8%AF%95%E9%A2%98/" title="JS面试题">http://example.com/2021/02/22/JS%E9%9D%A2%E8%AF%95%E9%A2%98/</a></li><li class="post-copyright-license"><strong>Copyright Notice: </strong>All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0 "><svg class="icon"><use xlink:href="#icon-creative-commons-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-by-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-nc-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-sa-line"></use></svg></a> unless otherwise stated.</li></ul></section></article><div class="post-nav"><div class="post-nav-item"><a class="post-nav-prev" href="/2021/02/22/vue%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="prev" title="vue面试题"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-left-s-line"></use></svg><span class="post-nav-text">vue面试题</span></a></div><div class="post-nav-item"><a class="post-nav-next" href="/2021/02/18/ES5%E4%B8%8EES6/" rel="next" title="ES5与ES6"><span class="post-nav-text">ES5与ES6</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-right-s-line"></use></svg></a></div></div></div><div id="comment"><div class="comment-tooltip text-center"><span>点击按钮跳转 GitHub Issues 评论。</span><br><span>若没有本文 Issue，您可以使用 Comment 模版新建。</span><br><a class="hty-button hty-button--raised" id="github-issues" target="_blank" rel="noopener" href="https://github.com/YunYouJun/yunyoujun.github.io/issues?q=is:issue+JS面试题">GitHub Issues</a></div></div></main><footer class="sidebar-translate" id="footer"><div class="copyright"><span>&copy; 2019 – 2022 </span><span class="with-love" id="animate"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-cloud-line"></use></svg></span><span class="author"> sun</span></div><div class="powered"><span>Powered by <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> v5.3.0</span><span class="footer-separator">|</span><span>Theme - <a rel="noopener" href="https://github.com/YunYouJun/hexo-theme-yun" target="_blank"><span>Yun</span></a> v1.3.0</span></div></footer><a class="hty-icon-button" id="goUp" aria-label="back-to-top" href="#"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-up-s-line"></use></svg><svg class="progress-circle-container" viewBox="0 0 100 100"><circle class="progress-circle" id="progressCircle" cx="50" cy="50" r="48" fill="none" stroke="#0078E7" stroke-width="2" stroke-linecap="round"></circle></svg></a></div><script defer src="/js/utils.js"></script><script defer src="/js/hexo-theme-yun.js"></script></body></html>