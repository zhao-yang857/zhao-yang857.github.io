<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="theme-color" content="#0078E7"><meta name="author" content="sun"><meta name="copyright" content="sun"><meta name="generator" content="Hexo 5.3.0"><meta name="theme" content="hexo-theme-yun"><title>JS面试题 | 太阳の小屋</title><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@900&amp;display=swap" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/star-markdown-css@0.1.22/dist/yun/yun-markdown.min.css"><script src="//at.alicdn.com/t/font_1140697_ed8vp4atwoj.js" async></script><script src="https://cdn.jsdelivr.net/npm/scrollreveal/dist/scrollreveal.min.js" defer></script><script>document.addEventListener("DOMContentLoaded", () => {
  [".post-card",".post-content img"].forEach((target)=> {
    ScrollReveal().reveal(target);
  })
});
</script><link rel="shortcut icon" type="image/svg+xml" href="/feng.ico"><link rel="mask-icon" href="/feng.ico" color="#0078E7"><link rel="alternate icon" href="/yun.ico"><link rel="preload" href="/css/hexo-theme-yun.css" as="style"><link rel="preload" href="/js/utils.js" as="script"><link rel="preload" href="/js/hexo-theme-yun.js" as="script"><link rel="prefetch" href="/js/sidebar.js" as="script"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><link rel="stylesheet" href="/css/hexo-theme-yun.css"><script id="yun-config">
    const Yun = window.Yun || {};
    window.CONFIG = {"hostname":"example.com","root":"/","title":"太阳の小屋","version":"1.3.0","mode":"auto","copycode":true,"anonymous_image":"https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/avatar/none.jpg","say":{"api":"https://v1.hitokoto.cn","hitokoto":true},"fireworks":{"colors":["219, 34, 9","216, 35, 223","252, 89, 170","89, 187, 252","103, 252, 89"]}};
  </script><meta name="description" content="js的基本数据类型有哪些，基本数据类型和复杂数据类型的区别String、Number、Boolean、Null、undefined  Object为复杂数据类型  基本数据类型把数据名和值直接存储在栈当中  复杂数据类型在栈中存储数据名和一个堆的地址，在堆中存储属性和值，访问时先从栈中获取地址再到堆中取相应的值 &#x3D;&#x3D; 和 &#x3D;&#x3D;&#x3D; 有什么区别&#x3D;&#x3D;用于一般比较 比较时可以转换数据类型   &#x3D;&#x3D;&#x3D;用于严">
<meta property="og:type" content="article">
<meta property="og:title" content="JS面试题">
<meta property="og:url" content="http://example.com/2021/02/22/JS%E9%9D%A2%E8%AF%95%E9%A2%98/index.html">
<meta property="og:site_name" content="太阳の小屋">
<meta property="og:description" content="js的基本数据类型有哪些，基本数据类型和复杂数据类型的区别String、Number、Boolean、Null、undefined  Object为复杂数据类型  基本数据类型把数据名和值直接存储在栈当中  复杂数据类型在栈中存储数据名和一个堆的地址，在堆中存储属性和值，访问时先从栈中获取地址再到堆中取相应的值 &#x3D;&#x3D; 和 &#x3D;&#x3D;&#x3D; 有什么区别&#x3D;&#x3D;用于一般比较 比较时可以转换数据类型   &#x3D;&#x3D;&#x3D;用于严">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2021-02-22T06:35:33.000Z">
<meta property="article:modified_time" content="2021-03-05T05:56:11.573Z">
<meta property="article:author" content="sun">
<meta name="twitter:card" content="summary"><script src="/js/ui/mode.js"></script></head><body><script defer src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script defer src="/js/ui/fireworks.js"></script><canvas class="fireworks"></canvas><div class="container"><a class="sidebar-toggle hty-icon-button" id="menu-btn"><div class="hamburger hamburger--spin" type="button"><span class="hamburger-box"><span class="hamburger-inner"></span></span></div></a><div class="sidebar-toggle sidebar-overlay"></div><aside class="sidebar"><script src="/js/sidebar.js"></script><ul class="sidebar-nav"><li class="sidebar-nav-item sidebar-nav-toc hty-icon-button sidebar-nav-active" data-target="post-toc-wrap" title="Table of Contents"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-list-ordered"></use></svg></li><li class="sidebar-nav-item sidebar-nav-overview hty-icon-button" data-target="site-overview-wrap" title="Overview"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-passport-line"></use></svg></li></ul><div class="sidebar-panel" id="site-overview-wrap"><div class="site-info fix-top"><a class="site-author-avatar" href="/about/" title="sun"><img width="96" loading="lazy" src="/images/%E5%A4%B4%E5%83%8F6.jpeg" alt="sun"></a><div class="site-author-name"><a href="/about/">sun</a></div><a class="site-name" href="/about/site.html">太阳の小屋</a><sub class="site-subtitle"></sub><div class="site-desciption"></div></div><nav class="site-state"><a class="site-state-item hty-icon-button icon-home" href="/" title="首页"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-home-4-line"></use></svg></span></a><div class="site-state-item"><a href="/archives/" title="归档"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-archive-line"></use></svg></span><span class="site-state-item-count">21</span></a></div><div class="site-state-item"><a href="/categories/" title="分类"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-2-line"></use></svg></span><span class="site-state-item-count">0</span></a></div><div class="site-state-item"><a href="/tags/" title="标签"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="site-state-item-count">0</span></a></div><a class="site-state-item hty-icon-button" target="_blank" rel="noopener" href="https://yun.yunyoujun.cn" title="留言板"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-clipboard-line"></use></svg></span></a></nav><hr style="margin-bottom:0.5rem"><div class="links-of-author"><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://qm.qq.com/cgi-bin/qm/qr?k=epvxdq1sknJe9JMj6J1LsBw4a6cI_2ln&amp;jump_from=webapi" title="QQ" target="_blank" style="color:#12B7F5"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-qq-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://github.com/zhao-yang857" title="GitHub" target="_blank" style="color:#6e5494"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-github-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://music.163.com/#/user/home?id=333632364" title="网易云音乐" target="_blank" style="color:#C20C0C"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-netease-cloud-music-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://space.bilibili.com/74908726" title="哔哩哔哩" target="_blank" style="color:#FF8EB3"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-bilibili-line"></use></svg></a></div><hr style="margin:0.5rem 1rem"><div class="links"><a class="links-item hty-icon-button" href="/links/" title="我的小伙伴们" style="color:dodgerblue"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-genderless-line"></use></svg></a><a class="links-item hty-icon-button" href="/girls/" title="我喜欢的女孩儿们" style="color:hotpink"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-women-line"></use></svg></a></div><br><a class="links-item hty-icon-button" id="toggle-mode-btn" href="javascript:;" title="Mode" style="color: #f1cb64"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-contrast-2-line"></use></svg></a></div><div class="sidebar-panel sidebar-panel-active" id="post-toc-wrap"><div class="post-toc"><div class="post-toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#js%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%8C%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%A4%8D%E6%9D%82%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.</span> <span class="toc-text">js的基本数据类型有哪些，基本数据类型和复杂数据类型的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%92%8C-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">2.</span> <span class="toc-text">&#x3D;&#x3D; 和 &#x3D;&#x3D;&#x3D; 有什么区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E4%B8%BE3%E7%A7%8D%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%92%8C2%E7%A7%8D%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.</span> <span class="toc-text">例举3种强制类型转换和2种隐式类型转换?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#split-%E5%92%8C-join-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.</span> <span class="toc-text">split() 和 join() 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ajax%E8%AF%B7%E6%B1%82%E7%9A%84%E6%97%B6%E5%80%99get-%E5%92%8Cpost%E6%96%B9%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">5.</span> <span class="toc-text">ajax请求的时候get 和post方式的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%87%8Ajsonp%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%8C%E4%BB%A5%E5%8F%8A%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%98%AF%E7%9C%9F%E6%AD%A3%E7%9A%84ajax"><span class="toc-number">6.</span> <span class="toc-text">解释jsonp的原理，以及为什么不是真正的ajax</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#call-%E3%80%81bind-%E3%80%81apply-%E5%8C%BA%E5%88%AB"><span class="toc-number">7.</span> <span class="toc-text">call()、bind()、apply()区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E6%9C%89%E5%93%AA%E4%BA%9B%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95"><span class="toc-number">8.</span> <span class="toc-text">数组有哪些操作方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E6%9C%89%E5%93%AA%E4%BA%9B%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95"><span class="toc-number">9.</span> <span class="toc-text">对象有哪些操作方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%97%AD%E5%8C%85-%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E6%80%A7%EF%BC%8C%E5%AF%B9%E9%A1%B5%E9%9D%A2%E6%9C%89%E4%BB%80%E4%B9%88%E5%BD%B1%E5%93%8D"><span class="toc-number">10.</span> <span class="toc-text">什么是闭包,有什么特性，对页面有什么影响</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AD%E5%8C%85%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-number">10.1.</span> <span class="toc-text">闭包的好处</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E5%88%9B%E5%BB%BA%E9%97%AD%E5%8C%85"><span class="toc-number">10.2.</span> <span class="toc-text">怎么创建闭包</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%98%BB%E6%AD%A2%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1"><span class="toc-number">11.</span> <span class="toc-text">如何阻止事件冒泡</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%98%BB%E6%AD%A2%E9%BB%98%E8%AE%A4%E4%BA%8B%E4%BB%B6%E3%80%81%E9%98%BB%E6%AD%A2%E6%A0%87%E7%AD%BE%E8%87%AA%E5%B8%A6%E5%8A%9F%E8%83%BD"><span class="toc-number">12.</span> <span class="toc-text">如何阻止默认事件、阻止标签自带功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0%E7%BA%A7%E4%BA%8B%E4%BB%B6%E5%92%8C2%E7%BA%A7%E4%BA%8B%E4%BB%B6"><span class="toc-number">13.</span> <span class="toc-text">0级事件和2级事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0-%E5%88%A0%E9%99%A4-%E6%9B%BF%E6%8D%A2-%E6%8F%92%E5%85%A5%E5%88%B0%E6%9F%90%E4%B8%AA%E6%8E%A5%E7%82%B9%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">14.</span> <span class="toc-text">添加 删除 替换 插入到某个接点的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#null-%E5%92%8C-undefined-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">15.</span> <span class="toc-text">null 和 undefined 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87"><span class="toc-number">16.</span> <span class="toc-text">什么是变量提升</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98"><span class="toc-number">17.</span> <span class="toc-text">什么是事件委托</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-number">18.</span> <span class="toc-text">深拷贝和浅拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#async%E4%B8%8Edefer%E5%8C%BA%E5%88%AB"><span class="toc-number">19.</span> <span class="toc-text">async与defer区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cookies%EF%BC%8CsessionStorage%E5%92%8ClocalStorage-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">20.</span> <span class="toc-text">cookies，sessionStorage和localStorage 有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95"><span class="toc-number">21.</span> <span class="toc-text">数组去重有哪些方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#indexOf-%E5%8E%BB%E9%87%8D-%E5%A6%82%EF%BC%9A"><span class="toc-number">21.1.</span> <span class="toc-text">indexOf()去重 如：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sort-%E5%8E%BB%E9%87%8D-%E5%A6%82%EF%BC%9A"><span class="toc-number">21.2.</span> <span class="toc-text">sort()去重 如：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#filter-%E5%8E%BB%E9%87%8D-%E5%A6%82"><span class="toc-number">21.3.</span> <span class="toc-text">filter()去重 如:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%8C%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%EF%BC%9F"><span class="toc-number">21.4.</span> <span class="toc-text">行代码实现数组去重？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="toc-number">21.5.</span> <span class="toc-text">冒泡排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%99%8D%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">21.6.</span> <span class="toc-text">降维数组</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GET-%E5%92%8C-POST-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">22.</span> <span class="toc-text">GET 和 POST 有什么区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%A8%E5%9F%9F%E6%9C%89%E5%87%A0%E7%A7%8D%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">23.</span> <span class="toc-text">跨域有几种解决方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#typeof%E5%92%8Cinstanceof%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">24.</span> <span class="toc-text">typeof和instanceof有什么区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E%E4%B8%8E%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">25.</span> <span class="toc-text">函数声明与函数表达式的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Javascript%E7%9A%84%E4%BA%8B%E4%BB%B6%E6%B5%81%E6%A8%A1%E5%9E%8B%E9%83%BD%E6%9C%89%E4%BB%80%E4%B9%88"><span class="toc-number">26.</span> <span class="toc-text">Javascript的事件流模型都有什么?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%8C%E6%9C%9B%E8%8E%B7%E5%8F%96%E5%88%B0%E9%A1%B5%E9%9D%A2%E4%B8%AD%E6%89%80%E6%9C%89%E7%9A%84checkbox%E6%80%8E%E4%B9%88%E5%81%9A%EF%BC%9F-%E4%B8%8D%E4%BD%BF%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6"><span class="toc-number">27.</span> <span class="toc-text">希望获取到页面中所有的checkbox怎么做？(不使用第三方框架)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96javascript%E4%B8%89%E4%B8%AA%E6%95%B0%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC%E5%92%8C%E6%9C%80%E5%B0%8F%E5%80%BC%EF%BC%9F"><span class="toc-number">28.</span> <span class="toc-text">如何获取javascript三个数中的最大值和最小值？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#javascript%E6%98%AF%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%EF%BC%8C%E6%80%8E%E4%B9%88%E4%BD%93%E7%8E%B0javascript%E7%9A%84%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%EF%BC%9F"><span class="toc-number">29.</span> <span class="toc-text">javascript是面向对象的，怎么体现javascript的继承关系？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%97%E4%B8%BEjavaScript%E7%9A%843%E7%A7%8D%E4%B8%BB%E8%A6%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%8C2%E7%A7%8D%E5%A4%8D%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C2%E7%A7%8D%E7%89%B9%E6%AE%8A%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E3%80%82"><span class="toc-number">30.</span> <span class="toc-text">列举javaScript的3种主要数据类型，2种复合数据类型和2种特殊数据类型。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A%E4%BB%80%E4%B9%88%E6%98%AFJson"><span class="toc-number">31.</span> <span class="toc-text">解释什么是Json:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#js%E4%B8%AD%E7%9A%843%E7%A7%8D%E5%BC%B9%E5%87%BA%E5%BC%8F%E6%B6%88%E6%81%AF%E6%8F%90%E9%86%92%EF%BC%88%E8%AD%A6%E5%91%8A%E7%AA%97%E5%8F%A3%EF%BC%8C%E7%A1%AE%E8%AE%A4%E7%AA%97%E5%8F%A3%EF%BC%8C%E4%BF%A1%E6%81%AF%E8%BE%93%E5%85%A5%E7%AA%97%E5%8F%A3%EF%BC%89%E7%9A%84%E5%91%BD%E4%BB%A4%E5%BC%8F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">32.</span> <span class="toc-text">js中的3种弹出式消息提醒（警告窗口，确认窗口，信息输入窗口）的命令式什么？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E6%BB%9A%E5%8A%A8%E8%B7%9D%E7%A6%BB%EF%BC%9A"><span class="toc-number">32.1.</span> <span class="toc-text">浏览器的滚动距离：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#innerHTML%E3%80%81innerText%E5%92%8CouterHTML%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">33.</span> <span class="toc-text">innerHTML、innerText和outerHTML的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#offsetWidth-offsetHeight%E5%92%8CclientWidth-clientHeight%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">34.</span> <span class="toc-text">offsetWidth offsetHeight和clientWidth clientHeight的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B7%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8B%E4%BB%80%E4%B9%88%E6%98%AF%E8%AF%AD%E4%B9%89%E5%8C%96%E7%9A%84HTML%E3%80%82"><span class="toc-number">35.</span> <span class="toc-text">请解释一下什么是语义化的HTML。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B7%E8%AF%B4%E5%87%BA%E4%B8%89%E7%A7%8D%E5%87%8F%E4%BD%8E%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E6%97%B6%E9%97%B4%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">36.</span> <span class="toc-text">请说出三种减低页面加载时间的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B7%E8%A7%A3%E9%87%8A%E4%BB%80%E4%B9%88%E6%98%AFJavascript%E7%9A%84%E6%A8%A1%E5%9D%97%E6%A8%A1%E5%BC%8F%EF%BC%8C%E5%B9%B6%E4%B8%BE%E5%87%BA%E5%AE%9E%E7%94%A8%E5%AE%9E%E4%BE%8B%E3%80%82"><span class="toc-number">37.</span> <span class="toc-text">请解释什么是Javascript的模块模式，并举出实用实例。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%A0%E5%A6%82%E4%BD%95%E7%BB%84%E7%BB%87%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81%EF%BC%9F%E6%98%AF%E4%BD%BF%E7%94%A8%E6%A8%A1%E5%9D%97%E6%A8%A1%E5%BC%8F%EF%BC%8C%E8%BF%98%E6%98%AF%E4%BD%BF%E7%94%A8%E7%BB%8F%E5%85%B8%E7%BB%A7%E6%89%BF%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-number">38.</span> <span class="toc-text">你如何组织自己的代码？是使用模块模式，还是使用经典继承的方法？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%A0%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81%EF%BC%9F"><span class="toc-number">39.</span> <span class="toc-text">你如何优化自己的代码？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%A0%E8%83%BD%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8BJavaScript%E4%B8%AD%E7%9A%84%E7%BB%A7%E6%89%BF%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%90%97%EF%BC%9F"><span class="toc-number">39.1.</span> <span class="toc-text">你能解释一下JavaScript中的继承是如何工作的吗？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E4%B8%80%E9%81%93%E9%A2%98"><span class="toc-number">40.</span> <span class="toc-text">最简单的一道题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dom%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98%E4%BB%80%E4%B9%88%E5%8E%9F%E7%90%86%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">41.</span> <span class="toc-text">dom事件委托什么原理，有什么优缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#js%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E8%BF%99%E4%B8%AA%E5%89%8D%E6%8F%90%E6%9D%A1%E4%BB%B6%E4%B8%8B%E5%86%99%E4%B8%80%E4%B8%AAgetType%EF%BC%8C%E8%BF%94%E5%9B%9E%E7%9B%B8%E5%BA%94%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">42.</span> <span class="toc-text">js基础数据类型和引用类型分别是什么？这个前提条件下写一个getType，返回相应的类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#js%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E7%9F%A5%E9%81%93%E5%93%AA%E4%BA%9B%EF%BC%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E7%9A%84%E5%A5%BD%E5%A4%84%E5%92%8C%E5%9D%8F%E5%A4%84"><span class="toc-number">43.</span> <span class="toc-text">js垃圾回收机制知道哪些，垃圾回收机制的好处和坏处</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="toc-number">43.1.</span> <span class="toc-text">什么是垃圾回收机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">43.2.</span> <span class="toc-text">内存泄漏的原因</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">43.3.</span> <span class="toc-text">垃圾回收的方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#setTimeout-%E5%92%8C-setInterval-%E7%BB%86%E8%B0%88"><span class="toc-number">44.</span> <span class="toc-text">setTimeout 和 setInterval 细谈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E6%95%B0%E7%BB%84"><span class="toc-number">45.</span> <span class="toc-text">判断数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#window-name"><span class="toc-number">46.</span> <span class="toc-text">window.name</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#forEach%E5%92%8Cmap%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">47.</span> <span class="toc-text">forEach和map的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%90%8C%E7%82%B9"><span class="toc-number">47.1.</span> <span class="toc-text">相同点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E7%82%B9"><span class="toc-number">47.2.</span> <span class="toc-text">不同点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E2%80%94%E2%80%94%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE"><span class="toc-number">48.</span> <span class="toc-text">面向对象——原型与原型链</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B"><span class="toc-number">48.1.</span> <span class="toc-text">原型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E9%93%BE%E4%B8%8E%E9%9A%90%E5%BC%8F%E5%8E%9F%E5%9E%8B"><span class="toc-number">48.2.</span> <span class="toc-text">原型链与隐式原型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E9%83%A8%E6%9B%B2"><span class="toc-number">48.3.</span> <span class="toc-text">面向对象三部曲</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%85%B3%E9%94%AE%E5%90%8D%E7%A7%B0%E6%80%BB%E7%BB%93"><span class="toc-number">48.4.</span> <span class="toc-text">面向对象关键名称总结</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%A1%88%E4%BE%8B"><span class="toc-number">48.4.1.</span> <span class="toc-text">原型链案例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tcp%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C4%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-number">49.</span> <span class="toc-text">tcp三次握手和4次挥手</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="toc-number">49.1.</span> <span class="toc-text">三次握手</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-number">49.2.</span> <span class="toc-text">四次挥手</span></a></li></ol></li></ol></div></div></div></aside><main class="sidebar-translate" id="content"><div id="post"><article class="post-block" itemscope itemtype="https://schema.org/Article"><link itemprop="mainEntityOfPage" href="http://example.com/2021/02/22/JS%E9%9D%A2%E8%AF%95%E9%A2%98/"><span hidden itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="name" content="sun"><meta itemprop="description"></span><span hidden itemprop="publisher" itemscope itemtype="https://schema.org/Organization"><meta itemprop="name" content="太阳の小屋"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">JS面试题</h1><div class="post-meta"><div class="post-time" style="display:inline-block"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-line"></use></svg></span> <time title="Created: 2021-02-22 14:35:33" itemprop="dateCreated datePublished" datetime="2021-02-22T14:35:33+08:00">2021-02-22</time><span class="post-meta-divider">-</span><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-2-line"></use></svg></span> <time title="Modified: 2021-03-05 13:56:11" itemprop="dateModified" datetime="2021-03-05T13:56:11+08:00">2021-03-05</time></div><div class="post-classify"></div></div></header><section class="post-body" itemprop="articleBody"><div class="post-content markdown-body" style="--smc-primary:#0078E7;"><h3 id="js的基本数据类型有哪些，基本数据类型和复杂数据类型的区别"><a href="#js的基本数据类型有哪些，基本数据类型和复杂数据类型的区别" class="headerlink" title="js的基本数据类型有哪些，基本数据类型和复杂数据类型的区别"></a>js的基本数据类型有哪些，基本数据类型和复杂数据类型的区别</h3><pre><code>String、Number、Boolean、Null、undefined

Object为复杂数据类型

基本数据类型把数据名和值直接存储在栈当中

复杂数据类型在栈中存储数据名和一个堆的地址，在堆中存储属性和值，访问时先从栈中获取地址再到堆中取相应的值</code></pre>
<h3 id="和-有什么区别"><a href="#和-有什么区别" class="headerlink" title="== 和 === 有什么区别"></a>== 和 === 有什么区别</h3><pre><code>==用于一般比较 比较时可以转换数据类型 

===用于严格比较 比较时只要类型不匹配就返回false</code></pre>
<h3 id="例举3种强制类型转换和2种隐式类型转换"><a href="#例举3种强制类型转换和2种隐式类型转换" class="headerlink" title="例举3种强制类型转换和2种隐式类型转换?"></a>例举3种强制类型转换和2种隐式类型转换?</h3><pre><code>强制：通过String（），Number（），Boolean（）函数强制转换
隐式：（乘，除，大于，小于，减，==）</code></pre>
<h3 id="split-和-join-的区别"><a href="#split-和-join-的区别" class="headerlink" title="split() 和 join() 的区别"></a>split() 和 join() 的区别</h3><pre><code>split() 字符串转数组 如：var str = &quot;hello?word?welcome&quot;  console.log(str.split(“？”)) 返回值为 [&quot;hello&quot;, &quot;word&quot;, &quot;welcome&quot;]

join() 数组转字符串 如：var arr = new Array() arr[0] = &quot;hello&quot; arr[1] = &quot;world&quot; arr[3] = &quot;welcome&quot; arr.join(&quot;、&quot;)  返回值为 &quot;hello、world、welcome&quot;</code></pre>
<h3 id="ajax请求的时候get-和post方式的区别"><a href="#ajax请求的时候get-和post方式的区别" class="headerlink" title="ajax请求的时候get 和post方式的区别"></a>ajax请求的时候get 和post方式的区别</h3><pre><code>一个在url后面 ，一个放在虚拟载体里面
get有大小限制(只能提交少量参数)
安全问题
应用不同 ，请求数据和提交数据</code></pre>
<h3 id="解释jsonp的原理，以及为什么不是真正的ajax"><a href="#解释jsonp的原理，以及为什么不是真正的ajax" class="headerlink" title="解释jsonp的原理，以及为什么不是真正的ajax"></a>解释jsonp的原理，以及为什么不是真正的ajax</h3><pre><code>jsonp的核心原理就是目标页面回调本地页面的方法,并带入参数
动态创建script标签，使用回调函数
Ajax是页面无刷新请求数据操作</code></pre>
<h3 id="call-、bind-、apply-区别"><a href="#call-、bind-、apply-区别" class="headerlink" title="call()、bind()、apply()区别"></a>call()、bind()、apply()区别</h3><pre><code>三者都是可以改变this的指向

bind() 返回对应函数便于稍后调用；call()、apply()则是立即调用

call() call(thisArg, case1, case2, case3,...) 第一个参数是对象 后面是字符串

apply() apply(thisArg, [case1, case2, case3,...]) 第一个参数是对象  后面是数组</code></pre>
<h3 id="数组有哪些操作方法"><a href="#数组有哪些操作方法" class="headerlink" title="数组有哪些操作方法"></a>数组有哪些操作方法</h3><pre><code>unshift()  把参数添加到数组开头
shift() 把数组的第一个元素删除
push() 向数组末尾添加一个或多个元素
pop() 把数组的最后一个元素删除 
concat() 连接两个或多个数组
join() 数组转成字符串
reverse() 数组倒叙
slice() 截取后返回新数组 [&#39;H&#39;,&#39;el&#39;,&#39;lo&#39;,&#39;wo&#39;,&#39;rld!&#39;].slice(1,3) 返回 [&quot;el&quot;, &quot;lo&quot;]
splice() 添加或删除数组中的元素，这种方法会改变原始数组
sort() 数组元素排序
forEach() 遍历数组
filter() 返回符合条件的新数组，arr.filter((item,index,arr)=&gt;&#123;return 测试语句&#125;)
Map()  </code></pre>
<h3 id="对象有哪些操作方法"><a href="#对象有哪些操作方法" class="headerlink" title="对象有哪些操作方法"></a>对象有哪些操作方法</h3><pre><code>assign() 合并对像
is() 对象比较是否严格相等
keys() 遍历键名，返回所有键名数组
values() 遍历键值，返回键值数组</code></pre>
<h3 id="什么是闭包-有什么特性，对页面有什么影响"><a href="#什么是闭包-有什么特性，对页面有什么影响" class="headerlink" title="什么是闭包,有什么特性，对页面有什么影响"></a>什么是闭包,有什么特性，对页面有什么影响</h3><pre><code>可以调用其它函数内部变量的函数

闭包就是能够读取其他函数内部变量的函数,避免变量污染、加强了封装性，逻辑性比较强代码的可读性高；加载到内存中执行效率高,使得函数不被GC回收，
如果过多使用闭包，容易导致内存泄露,在内存中，造成了内存浪费，如果滥用闭包是灾难性的；</code></pre>
<h4 id="闭包的好处"><a href="#闭包的好处" class="headerlink" title="闭包的好处"></a>闭包的好处</h4><pre><code>(1)希望一个变量长期驻扎在内存当中(不被垃圾回收机制回收)

(2)避免全局变量的污染

(3)私有成员的存在

(4)安全性提高</code></pre>
<h4 id="怎么创建闭包"><a href="#怎么创建闭包" class="headerlink" title="怎么创建闭包"></a>怎么创建闭包</h4><pre><code>在函数内部嵌套使用函数</code></pre>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function fn() &#123;</span><br><span class="line">        for (var i &#x3D; 0; i &lt; 2; i++) &#123;</span><br><span class="line">            (function () &#123;</span><br><span class="line">                var variate &#x3D; i;</span><br><span class="line">                setTimeout(function () &#123;</span><br><span class="line">                    console.log(&quot;setTimeout执行后:&quot;+variate);</span><br><span class="line">                &#125;, 1000);</span><br><span class="line">            &#125;)();&#x2F;&#x2F;闭包,立即执行函数,匿名函数</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        console.log(i);&#x2F;&#x2F;2</span><br><span class="line">        console.log(variate);&#x2F;&#x2F;variate is not defined</span><br><span class="line">    &#125;</span><br><span class="line">    fn();</span><br></pre></td></tr></table></figure>
<h3 id="如何阻止事件冒泡"><a href="#如何阻止事件冒泡" class="headerlink" title="如何阻止事件冒泡"></a>如何阻止事件冒泡</h3><pre><code>e.stopPropagation()（IE:window.event.cancelBubble=true）</code></pre>
<h3 id="如何阻止默认事件、阻止标签自带功能"><a href="#如何阻止默认事件、阻止标签自带功能" class="headerlink" title="如何阻止默认事件、阻止标签自带功能"></a>如何阻止默认事件、阻止标签自带功能</h3><pre><code>e.preventDefault()（IE:window.event.returnValue=false）</code></pre>
<h3 id="0级事件和2级事件"><a href="#0级事件和2级事件" class="headerlink" title="0级事件和2级事件"></a>0级事件和2级事件</h3><pre><code>0级：dom.on事件名称=function()&#123;&#125;
2级：dom.addEvenListener(&#39;事件类型&#39;,function()&#123;&#125;,布尔值(为true表在捕du获阶段调用处理函数.false在冒泡阶段调用.为了兼zhi,一般都用false))</code></pre>
<h3 id="添加-删除-替换-插入到某个接点的方法"><a href="#添加-删除-替换-插入到某个接点的方法" class="headerlink" title="添加 删除 替换 插入到某个接点的方法"></a>添加 删除 替换 插入到某个接点的方法</h3><pre><code>1）创建新节点
createElement() //创建一个具体的元素
createTextNode() //创建一个文本节点

2）添加、移除、替换、插入
appendChild() //添加
removeChild() //移除
replaceChild() //替换
insertBefore() //插入

3）查找
getElementsByTagName() //通过标签名称
getElementsByName() //通过元素的Name属性的值
getElementById() //通过元素Id，唯一性</code></pre>
<h3 id="null-和-undefined-的区别"><a href="#null-和-undefined-的区别" class="headerlink" title="null 和 undefined 的区别"></a>null 和 undefined 的区别</h3><pre><code>null表示没有对象，该处不该有值，转为数值时为0

undefined表示缺少值，该处应该有值，但是未定义，转为数值时为NaN</code></pre>
<h3 id="什么是变量提升"><a href="#什么是变量提升" class="headerlink" title="什么是变量提升"></a>什么是变量提升</h3><pre><code>变量提升是js的默认行为，变量提升会将所有变量声明移动到当前作用域的顶部，并可以在声明之前使用该变量，初始化不会被提升，提升的仅作用于变量的声明</code></pre>
<h3 id="什么是事件委托"><a href="#什么是事件委托" class="headerlink" title="什么是事件委托"></a>什么是事件委托</h3><pre><code>利用事件冒泡的原理，把原本需要绑定的事件委托给父元素，让父元素负责事件监听</code></pre>
<h3 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h3><pre><code>浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。

深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象</code></pre>
<h3 id="async与defer区别"><a href="#async与defer区别" class="headerlink" title="async与defer区别"></a>async与defer区别</h3><pre><code>异步(async) 脚本将在其加载完成后立即执行，而 延迟(defer) 脚本将等待 HTML 解析完成后，并按加载顺序执行。</code></pre>
<h3 id="cookies，sessionStorage和localStorage-有什么区别？"><a href="#cookies，sessionStorage和localStorage-有什么区别？" class="headerlink" title="cookies，sessionStorage和localStorage 有什么区别？"></a>cookies，sessionStorage和localStorage 有什么区别？</h3><pre><code>共同点：都是保存在浏览器端、且同源的
不同点：
    1.cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递。
    cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下
    sessionStorage和localStorage不会自动把数据发送给服务器，仅在本地保存。
    2.存储大小限制也不同，cookie数据不能超过4K，sessionStorage和localStorage可以达到5M或更大
    3.cookie：只在设置的cookie过期时间之前有效，即使窗口关闭或浏览器关闭
    sessionStorage：仅在当前浏览器窗口关闭之前有效；数据在当前浏览器窗口关闭后自动删除。
    localStorage：始终有效，窗口或浏览器关闭也一直保存，本地存储，因此用作存储持久数据；浏览器关闭后数据不丢失除非主动删除数据
    4.作用域不同
    cookie: 也是在所有同源窗口中都是共享的.也就是说只要浏览器不关闭，数据仍然存在
    sessionStorage：不在不同的浏览器窗口中共享，即使是同一个页面；
    localstorage：在所有同源窗口中都是共享的；也就是说只要浏览器不关闭，数据仍然存在</code></pre>
<h3 id="数组去重有哪些方法"><a href="#数组去重有哪些方法" class="headerlink" title="数组去重有哪些方法"></a>数组去重有哪些方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new Set()  如：var arr &#x3D; [1,2,3,9,6,3,1,2,6] new set(arr)</span><br></pre></td></tr></table></figure>
<p>利用冒泡for循环嵌套，然后splice()去重 如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function unique(arr)&#123;            </span><br><span class="line">        for(var i&#x3D;0; i&lt;arr.length; i++)&#123;</span><br><span class="line">            for(var j&#x3D;i+1; j&lt;arr.length; j++)&#123;</span><br><span class="line">                if(arr[i]&#x3D;&#x3D;arr[j])&#123;         &#x2F;&#x2F;第一个等同于第二个，splice方法删除第二个</span><br><span class="line">                    arr.splice(j,1);</span><br><span class="line">                    j--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">return arr;</span><br><span class="line">&#125;</span><br><span class="line">var arr &#x3D; [1,2,3,9,6,3,1,2,6]</span><br><span class="line">console.log(unique(arr))</span><br></pre></td></tr></table></figure>
<h4 id="indexOf-去重-如："><a href="#indexOf-去重-如：" class="headerlink" title="indexOf()去重 如："></a>indexOf()去重 如：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function unique(arr) &#123;</span><br><span class="line">    if (!Array.isArray(arr)) &#123;</span><br><span class="line">        console.log(&#39;type error!&#39;)</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    var array &#x3D; [];</span><br><span class="line">    for (var i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">        if (array .indexOf(arr[i]) &#x3D;&#x3D;&#x3D; -1) &#123;</span><br><span class="line">            array .push(arr[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return array;</span><br><span class="line">&#125;</span><br><span class="line">var arr &#x3D; [1,2,3,9,6,3,1,2,6]</span><br><span class="line">    console.log(unique(arr))</span><br></pre></td></tr></table></figure>
<h4 id="sort-去重-如："><a href="#sort-去重-如：" class="headerlink" title="sort()去重 如："></a>sort()去重 如：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function unique(arr) &#123; </span><br><span class="line">    if (!Array.isArray(arr)) &#123; </span><br><span class="line">        console.log(&#39;type error!&#39;) return;</span><br><span class="line">    &#125; </span><br><span class="line">    arr &#x3D; arr.sort() </span><br><span class="line">    var arrry&#x3D; [arr[0]]; </span><br><span class="line">    for (var i &#x3D; 1; i &lt; arr.length; i++) &#123; </span><br><span class="line">        if (arr[i] !&#x3D;&#x3D; arr[i-1]) &#123; </span><br><span class="line">            arrry.push(arr[i]);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    return arrry; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">var arr &#x3D; [1,2,3,9,6,3,1,2,6]</span><br><span class="line"></span><br><span class="line">console.log(unique(arr))</span><br></pre></td></tr></table></figure>
<h4 id="filter-去重-如"><a href="#filter-去重-如" class="headerlink" title="filter()去重 如:"></a>filter()去重 如:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function unique(arr) &#123; </span><br><span class="line">    return arr.filter(function(item, index, arr) &#123; </span><br><span class="line">        return arr.indexOf(item, 0) &#x3D;&#x3D;&#x3D; index;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var arr &#x3D; [1,2,3,9,6,3,1,2,6]</span><br><span class="line"></span><br><span class="line">console.log(unique(arr))</span><br></pre></td></tr></table></figure>
<h4 id="行代码实现数组去重？"><a href="#行代码实现数组去重？" class="headerlink" title="行代码实现数组去重？"></a>行代码实现数组去重？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[...new Set([1,2,3,1,&#39;a&#39;,1,&#39;a&#39;])]</span><br></pre></td></tr></table></figure>
<h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var array &#x3D; [5, 4, 3, 2, 1];</span><br><span class="line">var temp &#x3D; 0;</span><br><span class="line">for (var i &#x3D; 0; i &lt;array.length; i++)&#123;</span><br><span class="line">    for (var j &#x3D; 0; j &lt;array.length - i; j++)&#123;</span><br><span class="line">        if (array[j] &gt; array[j + 1])&#123;</span><br><span class="line">            temp &#x3D; array[j + 1];</span><br><span class="line">            array[j + 1] &#x3D; array[j];</span><br><span class="line">            array[j] &#x3D; temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="降维数组"><a href="#降维数组" class="headerlink" title="降维数组"></a>降维数组</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var arr&#x3D;[[1,2],[3,4]];</span><br><span class="line">function Jw(obj)&#123;</span><br><span class="line">    return Array.prototype.concat.apply([],obj);</span><br><span class="line">&#125;</span><br><span class="line">Jw(arr);</span><br></pre></td></tr></table></figure>
<h3 id="GET-和-POST-有什么区别"><a href="#GET-和-POST-有什么区别" class="headerlink" title="GET 和 POST 有什么区别"></a>GET 和 POST 有什么区别</h3><pre><code>GET请求在浏览器回退和刷新时是无害的，而POST请求会告知用户数据会被重新提交；

GET请求可以收藏为书签，POST请求不可以收藏为书签；

GET请求可以被缓存，POST请求不可以被缓存，除非在响应头中包含合适的Cache-Control/Expires字段，但是不建议缓存POST请求，其不满足幂等性，每次调用都会对服务器资源造成影响；

GET请求一般不具有请求体，因此只能进行url编码，而POST请求支持多种编码方式。

GET请求的参数可以被保留在浏览器的历史中，POST请求不会被保留；

GET请求因为是向URL添加数据，不同的浏览器厂商，代理服务器，web服务器都可能会有自己的长度限制，而POST请求无长度限制；

GET请求只允许ASCII字符，POST请求无限制，支持二进制数据；

GET请求的安全性较差，数据被暴露在浏览器的URL中，所以不能用来传递敏感信息，POST请求的安全性较好，数据不会暴露在URL中；

GET请求具有幂等性(多次请求不会对资源造成影响)，POST请求不幂等；

GET请求一般不具有请求体，请求中一般不包含100-continue 协议，所以只会发一次请求，而POST请求在发送数据到服务端之前允许双方&quot;握手&quot;，
客户端先发送Expect:100-continue消息，询问服务端是否愿意接收数据，接收到服务端正确的100-continue应答后才会将请求体发送给服务端，服务端再响应200返回数据。</code></pre>
<h3 id="跨域有几种解决方案"><a href="#跨域有几种解决方案" class="headerlink" title="跨域有几种解决方案"></a>跨域有几种解决方案</h3><pre><code>jsonp 适用于get请求
document.domain + iframe 适用于主域相同 子域不同  两个页面都通过js强制设置document.domain为基础主域，就实现了同域
location.hash + iframe 
window.name + iframe 
postMessage (data,origin)方法接受两个参数
data：需要传递的数据，html5规范支持任意基本类型或可复制的对象，但部分浏览器只支持字符串，所以传参时最好用JSON.stringify()序列化。

origin：协议+主机+端口号，也可以设置为&quot;*&quot;，表示可以传递给任意窗口，如果要指定和当前窗口同源的话设置为&quot;/&quot;。

跨域资源共享（CORS）</code></pre>
<h3 id="typeof和instanceof有什么区别"><a href="#typeof和instanceof有什么区别" class="headerlink" title="typeof和instanceof有什么区别"></a>typeof和instanceof有什么区别</h3><pre><code>typeof 判断一个数据是什么数据类型；一般只能返回如下几个结果：&quot;number&quot;、&quot;string&quot;、&quot;boolean&quot;、&quot;object&quot;、&quot;function&quot; 和 &quot;undefined&quot;。
instanceof 判断一个对象是否在另一个对象的原型链上</code></pre>
<h3 id="函数声明与函数表达式的区别？"><a href="#函数声明与函数表达式的区别？" class="headerlink" title="函数声明与函数表达式的区别？"></a>函数声明与函数表达式的区别？</h3><pre><code>在Javscript中，解析器在向执行环境中加载数据时，对函数声明和函数表达式并非是一视同仁的，解析器会率先读取函数声明，并使其在执行任何代码之前可用（可以访问），
至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解析执行。</code></pre>
<h3 id="Javascript的事件流模型都有什么"><a href="#Javascript的事件流模型都有什么" class="headerlink" title="Javascript的事件流模型都有什么?"></a>Javascript的事件流模型都有什么?</h3><pre><code>“事件冒泡”：事件开始由最具体的元素接受，然后逐级向上传播

“事件捕捉”：事件由最不具体的节点先接收，然后逐级向下，一直到最具体的

“DOM事件流”：三个阶段：事件捕捉，目标阶段，事件冒泡</code></pre>
<h3 id="希望获取到页面中所有的checkbox怎么做？-不使用第三方框架"><a href="#希望获取到页面中所有的checkbox怎么做？-不使用第三方框架" class="headerlink" title="希望获取到页面中所有的checkbox怎么做？(不使用第三方框架)"></a>希望获取到页面中所有的checkbox怎么做？(不使用第三方框架)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var inputs &#x3D; document.getElementsByTagName(&quot;input&quot;);&#x2F;&#x2F;获取所有的input标签对象</span><br><span class="line">var checkboxArray &#x3D; [];&#x2F;&#x2F;初始化空数组，用来存放checkbox对象。</span><br><span class="line">for(var i&#x3D;0;i&lt;inputs.length;i++)&#123;</span><br><span class="line">    var obj &#x3D; inputs[i];</span><br><span class="line">    if(obj.type&#x3D;&#x3D;&#39;checkbox&#39;)&#123;</span><br><span class="line">        checkboxArray.push(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="如何获取javascript三个数中的最大值和最小值？"><a href="#如何获取javascript三个数中的最大值和最小值？" class="headerlink" title="如何获取javascript三个数中的最大值和最小值？"></a>如何获取javascript三个数中的最大值和最小值？</h3><pre><code>Math.max(a,b,c);//最大值

Math.min(a,b,c)//最小值</code></pre>
<h3 id="javascript是面向对象的，怎么体现javascript的继承关系？"><a href="#javascript是面向对象的，怎么体现javascript的继承关系？" class="headerlink" title="javascript是面向对象的，怎么体现javascript的继承关系？"></a>javascript是面向对象的，怎么体现javascript的继承关系？</h3><pre><code>使用prototype原型来实现。</code></pre>
<h3 id="列举javaScript的3种主要数据类型，2种复合数据类型和2种特殊数据类型。"><a href="#列举javaScript的3种主要数据类型，2种复合数据类型和2种特殊数据类型。" class="headerlink" title="列举javaScript的3种主要数据类型，2种复合数据类型和2种特殊数据类型。"></a>列举javaScript的3种主要数据类型，2种复合数据类型和2种特殊数据类型。</h3><pre><code>主要数据类型：string, boolean, number

复合数据类型：function, object

特殊类型：undefined，null</code></pre>
<h3 id="解释什么是Json"><a href="#解释什么是Json" class="headerlink" title="解释什么是Json:"></a>解释什么是Json:</h3><pre><code>(1)JSON 是一种轻量级的数据交换格式。

(2)JSON 独立于语言和平台，JSON 解析器和 JSON 库支持许多不同的编程语言。

(3)JSON的语法表示三种类型值，简单值(字符串，数值，布尔值，null),数组，对象</code></pre>
<h3 id="js中的3种弹出式消息提醒（警告窗口，确认窗口，信息输入窗口）的命令式什么？"><a href="#js中的3种弹出式消息提醒（警告窗口，确认窗口，信息输入窗口）的命令式什么？" class="headerlink" title="js中的3种弹出式消息提醒（警告窗口，确认窗口，信息输入窗口）的命令式什么？"></a>js中的3种弹出式消息提醒（警告窗口，确认窗口，信息输入窗口）的命令式什么？</h3><pre><code>alert
confirm
prompt</code></pre>
<h4 id="浏览器的滚动距离："><a href="#浏览器的滚动距离：" class="headerlink" title="浏览器的滚动距离："></a>浏览器的滚动距离：</h4><pre><code>可视区域距离页面顶部的距离

scrollTop=document.documentElement.scrollTop||document.body.scrollTop</code></pre>
<h3 id="innerHTML、innerText和outerHTML的区别"><a href="#innerHTML、innerText和outerHTML的区别" class="headerlink" title="innerHTML、innerText和outerHTML的区别"></a>innerHTML、innerText和outerHTML的区别</h3><pre><code>innerHTML(元素内包含的内容）

innerText(元素的文本内容）

outerHTML(自己以及元素内的内容）</code></pre>
<h3 id="offsetWidth-offsetHeight和clientWidth-clientHeight的区别"><a href="#offsetWidth-offsetHeight和clientWidth-clientHeight的区别" class="headerlink" title="offsetWidth offsetHeight和clientWidth clientHeight的区别"></a>offsetWidth offsetHeight和clientWidth clientHeight的区别</h3><pre><code>(1)offsetWidth （content宽度+padding宽度+border宽度）

(2)offsetHeight（content高度+padding高度+border高度）

(3)clientWidth（content宽度+padding宽度）

(4)clientHeight（content高度+padding高度）</code></pre>
<h3 id="请解释一下什么是语义化的HTML。"><a href="#请解释一下什么是语义化的HTML。" class="headerlink" title="请解释一下什么是语义化的HTML。"></a>请解释一下什么是语义化的HTML。</h3><pre><code>内容使用特定标签，通过标签就能大概了解整体页面的布局分布</code></pre>
<h3 id="请说出三种减低页面加载时间的方法"><a href="#请说出三种减低页面加载时间的方法" class="headerlink" title="请说出三种减低页面加载时间的方法"></a>请说出三种减低页面加载时间的方法</h3><pre><code>1、压缩css、js文件
2、合并js、css文件，减少http请求
3、外部js、css文件放在最底下
4、减少dom操作，尽可能用变量替代不必要的dom操作</code></pre>
<h3 id="请解释什么是Javascript的模块模式，并举出实用实例。"><a href="#请解释什么是Javascript的模块模式，并举出实用实例。" class="headerlink" title="请解释什么是Javascript的模块模式，并举出实用实例。"></a>请解释什么是Javascript的模块模式，并举出实用实例。</h3><pre><code>js模块化mvc（数据层、表现层、控制层）
seajs
命名空间</code></pre>
<h3 id="你如何组织自己的代码？是使用模块模式，还是使用经典继承的方法？"><a href="#你如何组织自己的代码？是使用模块模式，还是使用经典继承的方法？" class="headerlink" title="你如何组织自己的代码？是使用模块模式，还是使用经典继承的方法？"></a>你如何组织自己的代码？是使用模块模式，还是使用经典继承的方法？</h3><pre><code>对内：模块模式
对外：继承</code></pre>
<h3 id="你如何优化自己的代码？"><a href="#你如何优化自己的代码？" class="headerlink" title="你如何优化自己的代码？"></a>你如何优化自己的代码？</h3><pre><code>代码重用
避免全局变量（命名空间，封闭空间，模块化mvc..）
拆分函数避免函数过于臃肿
注释</code></pre>
<h4 id="你能解释一下JavaScript中的继承是如何工作的吗？"><a href="#你能解释一下JavaScript中的继承是如何工作的吗？" class="headerlink" title="你能解释一下JavaScript中的继承是如何工作的吗？"></a>你能解释一下JavaScript中的继承是如何工作的吗？</h4><pre><code>子构造函数中执行父构造函数，并用call\apply改变this
克隆父构造函数原型上的方法</code></pre>
<h3 id="最简单的一道题"><a href="#最简单的一道题" class="headerlink" title="最简单的一道题"></a>最简单的一道题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; 2, b &#x3D; 3;</span><br><span class="line">var c &#x3D; a++ + b; </span><br><span class="line">&#x2F;&#x2F; c &#x3D; 5</span><br></pre></td></tr></table></figure>
<h3 id="dom事件委托什么原理，有什么优缺点"><a href="#dom事件委托什么原理，有什么优缺点" class="headerlink" title="dom事件委托什么原理，有什么优缺点"></a>dom事件委托什么原理，有什么优缺点</h3><pre><code>事件委托原理:事件冒泡机制

优点
1.可以大量节省内存占用，减少事件注册。比如ul上代理所有li的click事件就很不错。
2.可以实现当新增子对象时，无需再对其进行事件绑定，对于动态内容部分尤为合适

缺点
事件代理的常用应用应该仅限于上述需求，如果把所有事件都用事件代理，可能会出现事件误判。即本不该被触发的事件被绑定上了事件。</code></pre>
<h3 id="js基础数据类型和引用类型分别是什么？这个前提条件下写一个getType，返回相应的类型"><a href="#js基础数据类型和引用类型分别是什么？这个前提条件下写一个getType，返回相应的类型" class="headerlink" title="js基础数据类型和引用类型分别是什么？这个前提条件下写一个getType，返回相应的类型"></a>js基础数据类型和引用类型分别是什么？这个前提条件下写一个getType，返回相应的类型</h3><pre><code>1.基本数据类型（自身不可拆分的）：Undefined、Null、Boolean、Number、String
2.引用数据类型（对象）：Object （Array，Date，RegExp，Function）
ES6基本数据类型多了个symbol 据说这道题刷了百分之二十的人 感谢Abbyshen提出</code></pre>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function gettype(nm)&#123;</span><br><span class="line">    return Object.prototype.toString.call(nm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="js垃圾回收机制知道哪些，垃圾回收机制的好处和坏处"><a href="#js垃圾回收机制知道哪些，垃圾回收机制的好处和坏处" class="headerlink" title="js垃圾回收机制知道哪些，垃圾回收机制的好处和坏处"></a>js垃圾回收机制知道哪些，垃圾回收机制的好处和坏处</h3><h4 id="什么是垃圾回收机制"><a href="#什么是垃圾回收机制" class="headerlink" title="什么是垃圾回收机制"></a>什么是垃圾回收机制</h4><p>JS的垃圾回收机制是为了以防内存泄漏，内存泄漏的含义就是当已经不需要某块内存时这块内存还存在着，垃圾回收机制就是间歇的不定期的寻找到不再使用的变量，并释放掉它们所指向的内存。</p>
<h4 id="内存泄漏的原因"><a href="#内存泄漏的原因" class="headerlink" title="内存泄漏的原因"></a>内存泄漏的原因</h4><p>内存泄漏指由于疏忽或错误造成程序未能释放已经不再使用的内存。内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，导致在释放该段内存之前就失去了对该段内存的控制，<br>从而造成了内存的浪费。这里就讲一些常见会带来内存泄露的原因。</p>
<h4 id="垃圾回收的方式"><a href="#垃圾回收的方式" class="headerlink" title="垃圾回收的方式"></a>垃圾回收的方式</h4><pre><code>1 标记清除（mark and sweep）
s中最常用的垃圾回收方式就是标记清除。当变量进入环境时，例如，在一个函数中声明一个变量，就将这个变量标记为&quot;进入环境&quot;，从逻辑上讲，永远不能释放进入环境变量所占用的内存，
因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其标记为&quot;离开环境&quot;。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function test()&#123;</span><br><span class="line">    var a &#x3D; 10;    &#x2F;&#x2F;被标记&quot;进入环境&quot;</span><br><span class="line">    var b &#x3D; &quot;hello&quot;;    &#x2F;&#x2F;被标记&quot;进入环境&quot;</span><br><span class="line">&#125;</span><br><span class="line">test();    &#x2F;&#x2F;执行完毕后之后，a和b又被标记&quot;离开环境&quot;，被回收</span><br></pre></td></tr></table></figure>
垃圾回收机制在运行的时候会给存储再内存中的所有变量都加上标记（可以是任何标记方式），然后，它会去掉处在环境中的变量及被环境中的变量引用的变量标记（闭包）。而在此之后剩下的带有标记的变量被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后垃圾回收机制到下一个周期运行时，将释放这些变量的内存，回收它们所占用的空间。

2 引用计数（reference counting）

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let arr &#x3D; [1,2,3,4];</span><br><span class="line">console.log(&quot;hello world&quot;);</span><br><span class="line">arr &#x3D; null;</span><br></pre></td></tr></table></figure>
上面的代码中，数组[1,2,3,4]是一个值，会占用内存。变量arr是仅有的对这个值的引用，因此引用次数为1。尽管后面的代码没有用到arr，它是会持续占用内存。

如果增加一行代码，解除arr对[1,2,3,4]引用，这块内存就可以被垃圾回收机制释放了。</code></pre>
<p>好处：大幅简化程序的内存管理代码，减轻程序猿负担，并且减少因为长时间运转而带来的内存泄露问题。</p>
<p>坏处：自动回收意味着程序猿无法掌控内存。ECMAScript中没有暴露垃圾回收的借口，我们无法强迫其进行垃圾回收，更加无法干预内存管理。</p>
<h3 id="setTimeout-和-setInterval-细谈"><a href="#setTimeout-和-setInterval-细谈" class="headerlink" title="setTimeout 和 setInterval 细谈"></a>setTimeout 和 setInterval 细谈</h3><pre><code>常问的点，前者是在一定时间过后将函数添加至执行队列，执行时间=延迟时间+之前函数代码执行时间+执行函数时间。
后者是不管前一次是否执行完毕，每隔一定时间重复执行，用于精准执行互相没有影响的重复操作。
如果需要控制前后执行顺序，最好使用setTimeout模拟setInterval</code></pre>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var time &#x3D; 400, times &#x3D; 0, max &#x3D; 10;</span><br><span class="line">function func()&#123;</span><br><span class="line">times++;</span><br><span class="line">if(times &lt; max)&#123;</span><br><span class="line">    &#x2F;&#x2F;code here</span><br><span class="line">    setTimeout(func, time);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    console.log(&quot;finished&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">setTimeout(func, time);</span><br></pre></td></tr></table></figure>
<h3 id="判断数组"><a href="#判断数组" class="headerlink" title="判断数组"></a>判断数组</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function isArray(arr)&#123;</span><br><span class="line">    return Object.prototype.toString.call(arr) &#x3D;&#x3D;&#x3D; &#39;[Object Array]&#39;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="window-name"><a href="#window-name" class="headerlink" title="window.name"></a>window.name</h3><pre><code>即使在页面打开多层iframe后，每个iframe中window.name 属性值都是相同的，以此用作数据传输的工具。
但由于跨域的限制，是无法获取另一个frame中的window.name数据，所以要使用一个同域的代理(proxy.html)：</code></pre>
<h3 id="forEach和map的区别"><a href="#forEach和map的区别" class="headerlink" title="forEach和map的区别"></a>forEach和map的区别</h3><h4 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h4><pre><code>都是循环遍历数组中的每一项
forEach和map方法里每次执行匿名函数都支持3个参数，参数分别是item（当前每一项）、index（索引值）、arr（原数组）
匿名函数中的this都是指向window
只能遍历数组
都有兼容问题</code></pre>
<h4 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h4><pre><code>map速度比foreach快
map会返回一个新数组，不对原数组产生影响,foreach不会产生新数组，
map因为返回数组所以可以链式操作，foreach不能</code></pre>
<h3 id="面向对象——原型与原型链"><a href="#面向对象——原型与原型链" class="headerlink" title="面向对象——原型与原型链"></a>面向对象——原型与原型链</h3><h4 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h4><pre><code>每一个对象被创建的时候都有一个属性——prototype
这个属性会将创建出来的对象复制一个一模一样的复制品，
这个复制品通过prototype做链接指向，将对象中所有的属性及方法全部复制一遍，这个复制品成为对象的原型

每一个对象创建的时候都会形成两个&#39;对象&#39;：
    1.对象本身————类
    2.原型对象————类.prototype</code></pre>
<h4 id="原型链与隐式原型"><a href="#原型链与隐式原型" class="headerlink" title="原型链与隐式原型"></a>原型链与隐式原型</h4><pre><code>从一个对象上找属性的时候，他会先找自身，如果没有的话会去隐式原型（__proto__）上找,如果没有，接着去下一个隐式原型上找，任何一个对象都有__proto__属性，指向的都是原型对象。
这样形成的链式结构就是原型链。</code></pre>
<h4 id="面向对象三部曲"><a href="#面向对象三部曲" class="headerlink" title="面向对象三部曲"></a>面向对象三部曲</h4><pre><code>1.创建类
2.原型对象
3.实例化</code></pre>
<h4 id="面向对象关键名称总结"><a href="#面向对象关键名称总结" class="headerlink" title="面向对象关键名称总结"></a>面向对象关键名称总结</h4><pre><code>1.类
2.实例
3.静态属性、方法
4.成员属性、方法
5.构造函数
6.原型
7.隐式原型
8.实例、类、原型、隐式原型的关系
    类===类.prototype.constructor  //true
    实例.__proto__ === 类.prototype</code></pre>
<h5 id="原型链案例"><a href="#原型链案例" class="headerlink" title="原型链案例"></a>原型链案例</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">function Arr(name,age)&#123;</span><br><span class="line">    this.name&#x3D;name,    &#x2F;&#x2F;this生成的方法、属性都是成员方法或属性</span><br><span class="line">    this.age&#x3D;age,</span><br><span class="line">    this.fn&#x3D;function()&#123;</span><br><span class="line">        console.log(this.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;生成静态方法、属性</span><br><span class="line">Arr.name2&#x3D;&#39;李四&#39;</span><br><span class="line">Arr.fn2&#x3D;function()&#123;</span><br><span class="line">        console.log(Arr.name2)</span><br><span class="line">&#125;</span><br><span class="line">console.log(Arr.name2)  &#x2F;&#x2F;李四</span><br><span class="line">console.log(Arr.fn2)  &#x2F;&#x2F;打印出一个方法</span><br><span class="line">Arr.fn2()  &#x2F;&#x2F;李四</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;生成实例</span><br><span class="line">const MyArr &#x3D; new Arr(&#39;张三&#39;,&#39;23&#39;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;实例访问成员属性</span><br><span class="line">console.log(MyArr.name) &#x2F;&#x2F;张三</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;实例访问静态属性</span><br><span class="line">&#x2F;&#x2F; console.log(MyArr.name2)  &#x2F;&#x2F;undefined   用实例去操作静态属性时会是undefined，而方法会报错，如下：</span><br><span class="line">&#x2F;&#x2F; console.log(MyArr.fn2())</span><br><span class="line">&#x2F;&#x2F; MyArr.fn2() &#x2F;&#x2F;报错  MyArr.fn2 is not a function</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 创建实例方法(实例私有的)</span><br><span class="line">MyArr.fn3&#x3D;function()&#123;</span><br><span class="line">    console.log(MyArr.name)  &#x2F;&#x2F;张三  访问不到静态方法、属性  如下：</span><br><span class="line">    console.log(Arr.fn2)   &#x2F;&#x2F;打印出一个方法</span><br><span class="line">    Arr.fn2()  &#x2F;&#x2F;李四</span><br><span class="line">&#125;</span><br><span class="line">MyArr.fn3()</span><br><span class="line">console.log(MyArr)  &#x2F;&#x2F;打印结果如下</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Arr &#123;name: &quot;张三&quot;, age: &quot;23&quot;, fn: ƒ, fn3: ƒ&#125;</span><br><span class="line">&#x2F;&#x2F; age: &quot;23&quot;</span><br><span class="line">&#x2F;&#x2F; fn: ƒ ()</span><br><span class="line">&#x2F;&#x2F; fn3: ƒ ()</span><br><span class="line">&#x2F;&#x2F; name: &quot;张三&quot;</span><br><span class="line">&#x2F;&#x2F; __proto__: Object</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 很明显看不到静态方法和属性</span><br></pre></td></tr></table></figure>
<h3 id="tcp三次握手和4次挥手"><a href="#tcp三次握手和4次挥手" class="headerlink" title="tcp三次握手和4次挥手"></a>tcp三次握手和4次挥手</h3><p>字段    含义<br>URG    紧急指针是否有效。为1，表示某一位需要被优先处理<br>ACK    确认号是否有效，一般置为1。<br>PSH    提示接收端应用程序立即从TCP缓冲区把数据读走。<br>RST    对方要求重新建立连接，复位。<br>SYN    请求建立连接，并在其序列号的字段进行序列号的初始值设定。建立连接，设置为1<br>FIN        希望断开连接。<br>————————————————</p>
<h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><pre><code>第一次握手：建立连接时，客户端发送syn包（syn=x）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。

第二次握手：服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（syn=y），即SYN+ACK包，此时服务器进入SYN_RECV状态；

第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=y+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。
————————————————</code></pre>
<h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><pre><code>第一次挥手：客户端A发送一个FIN = 1、初始化序列号seq = u，到服务器B，用来主动关闭客户A到服务器B的数据传送，客户机A进入FIN-WAIT-1状态，等待服务器B发送FIN；

第二次挥手：服务器B收到这个FIN，它发回ACK = 1、确认序号ack number为收到的序号加1（ack number=u+1）；和SYN一样，一个FIN将占用一个序号seq = v，
客户机A进入FIN-WAIT-2，稍后关闭连接，服务器B进入CLOSE_WAIT，等待关闭连接;

第三次挥手：服务器B关闭与客户端A的连接，发回标识位FIN = 1，ACK = 1,seq = w和确认码ack number=u+1给客户端A，服务器B进入LAST_ACK，等待最后一次ACK确认;

第四次挥手：客户端A发送ACK = 1报文确认，并将确认序号设置为收到序号加1（ack number=w+1）到服务器B，客户机A进入TIME-WAIT等待2MAL后进入CLOSE可用状态，服务器B进入CLOSE可用状态
————————————————</code></pre>
<p>问题1】为什么连接的时候是三次握手，关闭的时候却是四次握手？</p>
<pre><code>答：因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。
但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，&quot;你发的FIN报文我收到了&quot;。
只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。</code></pre>
<p>【问题2】为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？</p>
<pre><code>答：虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。
所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。在Client发送出最后的ACK回复，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片段。
所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。
如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。
MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。</code></pre>
<p>【问题3】为什么不能用两次握手进行连接？</p>
<pre><code>答：3次握手完成两个重要的功能，既要双方做好发送数据的准备工作(双方都知道彼此已准备好)，也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。

       现在把三次握手改成仅需要两次握手，死锁是可能发生的。作为例子，考虑计算机S和C之间的通信，假定C给S发送一个连接请求分组，S收到了这个分组，并发 送了确认应答分组。
按照两次握手的协定，S认为连接已经成功地建立了，可以开始发送数据分组。可是，C在S的应答分组在传输中被丢失的情况下，将不知道S 是否已准备好，不知道S建立什么样的序列号，
C甚至怀疑S是否收到自己的连接请求分组。在这种情况下，C认为连接还未建立成功，将忽略S发来的任何数据分 组，只等待连接确认应答分组。而S在发出的分组超时后，重复发送同样的分组。这样就形成了死锁。</code></pre>
<p>【问题4】如果已经建立了连接，但是客户端突然出现故障了怎么办？</p>
<pre><code>TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，
时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。
————————————————</code></pre>
</div><div id="reward-container"><span class="hty-icon-button button-glow" id="reward-button" title="Donate" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === &quot;none&quot;) ? &quot;block&quot; : &quot;none&quot;;"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-hand-coin-line"></use></svg></span><div id="reward-comment">喜欢的话就打赏点吧</div><div id="qr" style="display:none;"><div style="display:inline-block"></div><div style="display:inline-block"></div><div style="display:inline-block"></div></div></div><ul class="post-copyright"><li class="post-copyright-author"><strong>Post author: </strong>sun</li><li class="post-copyright-link"><strong>Post link: </strong><a href="http://example.com/2021/02/22/JS%E9%9D%A2%E8%AF%95%E9%A2%98/" title="JS面试题">http://example.com/2021/02/22/JS%E9%9D%A2%E8%AF%95%E9%A2%98/</a></li><li class="post-copyright-license"><strong>Copyright Notice: </strong>All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0 "><svg class="icon"><use xlink:href="#icon-creative-commons-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-by-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-nc-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-sa-line"></use></svg></a> unless otherwise stated.</li></ul></section></article><div class="post-nav"><div class="post-nav-item"><a class="post-nav-prev" href="/2021/02/22/vue%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="prev" title="vue、react面试题"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-left-s-line"></use></svg><span class="post-nav-text">vue、react面试题</span></a></div><div class="post-nav-item"><a class="post-nav-next" href="/2021/02/21/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/" rel="next" title="前端面试题总结"><span class="post-nav-text">前端面试题总结</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-right-s-line"></use></svg></a></div></div></div><div id="comment"><div class="comment-tooltip text-center"><span>点击按钮跳转 GitHub Issues 评论。</span><br><span>若没有本文 Issue，您可以使用 Comment 模版新建。</span><br><a class="hty-button hty-button--raised" id="github-issues" target="_blank" rel="noopener" href="https://github.com/YunYouJun/yunyoujun.github.io/issues?q=is:issue+JS面试题">GitHub Issues</a></div></div></main><footer class="sidebar-translate" id="footer"><div class="copyright"><span>&copy; 2019 – 2021 </span><span class="with-love" id="animate"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-cloud-line"></use></svg></span><span class="author"> sun</span></div><div class="powered"><span>Powered by <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> v5.3.0</span><span class="footer-separator">|</span><span>Theme - <a rel="noopener" href="https://github.com/YunYouJun/hexo-theme-yun" target="_blank"><span>Yun</span></a> v1.3.0</span></div></footer><a class="hty-icon-button" id="goUp" aria-label="back-to-top" href="#"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-up-s-line"></use></svg><svg class="progress-circle-container" viewBox="0 0 100 100"><circle class="progress-circle" id="progressCircle" cx="50" cy="50" r="48" fill="none" stroke="#0078E7" stroke-width="2" stroke-linecap="round"></circle></svg></a></div><script defer src="/js/utils.js"></script><script defer src="/js/hexo-theme-yun.js"></script></body></html>